{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addConstants = addConstants;\nexports.addJimpMethods = addJimpMethods;\nexports.jimpEvMethod = jimpEvMethod;\nexports.jimpEvChange = jimpEvChange;\nObject.defineProperty(exports, \"addType\", {\n  enumerable: true,\n  get: function get() {\n    return MIME.addType;\n  }\n});\nexports[\"default\"] = void 0;\n\nvar _construct2 = _interopRequireDefault(require(\"@babel/runtime/helpers/construct\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _events = _interopRequireDefault(require(\"events\"));\n\nvar _utils = require(\"@jimp/utils\");\n\nvar _anyBase = _interopRequireDefault(require(\"any-base\"));\n\nvar _mkdirp = _interopRequireDefault(require(\"mkdirp\"));\n\nvar _pixelmatch = _interopRequireDefault(require(\"pixelmatch\"));\n\nvar _tinycolor = _interopRequireDefault(require(\"tinycolor2\"));\n\nvar _phash = _interopRequireDefault(require(\"./modules/phash\"));\n\nvar _request = _interopRequireDefault(require(\"./request\"));\n\nvar _composite = _interopRequireDefault(require(\"./composite\"));\n\nvar _promisify = _interopRequireDefault(require(\"./utils/promisify\"));\n\nvar MIME = _interopRequireWildcard(require(\"./utils/mime\"));\n\nvar _imageBitmap = require(\"./utils/image-bitmap\");\n\nvar constants = _interopRequireWildcard(require(\"./constants\"));\n\nvar alphabet = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'; // an array storing the maximum string length of hashes at various bases\n// 0 and 1 do not exist as possible hash lengths\n\nvar maxHashLength = [NaN, NaN];\n\nfor (var i = 2; i < 65; i++) {\n  var maxHash = (0, _anyBase[\"default\"])(_anyBase[\"default\"].BIN, alphabet.slice(0, i))(new Array(64 + 1).join('1'));\n  maxHashLength.push(maxHash.length);\n} // no operation\n\n\nfunction noop() {} // error checking methods\n\n\nfunction isArrayBuffer(test) {\n  return Object.prototype.toString.call(test).toLowerCase().indexOf('arraybuffer') > -1;\n} // Prepare a Buffer object from the arrayBuffer. Necessary in the browser > node conversion,\n// But this function is not useful when running in node directly\n\n\nfunction bufferFromArrayBuffer(arrayBuffer) {\n  var buffer = Buffer.alloc(arrayBuffer.byteLength);\n  var view = new Uint8Array(arrayBuffer);\n\n  for (var _i = 0; _i < buffer.length; ++_i) {\n    buffer[_i] = view[_i];\n  }\n\n  return buffer;\n}\n\nfunction loadFromURL(options, cb) {\n  (0, _request[\"default\"])(options, function (err, response, data) {\n    if (err) {\n      return cb(err);\n    }\n\n    if ('headers' in response && 'location' in response.headers) {\n      options.url = response.headers.location;\n      return loadFromURL(options, cb);\n    }\n\n    if ((0, _typeof2[\"default\"])(data) === 'object' && Buffer.isBuffer(data)) {\n      return cb(null, data);\n    }\n\n    var msg = 'Could not load Buffer from <' + options.url + '> ' + '(HTTP: ' + response.statusCode + ')';\n    return new Error(msg);\n  });\n}\n\nfunction loadBufferFromPath(src, cb) {\n  if (_fs[\"default\"] && typeof _fs[\"default\"].readFile === 'function' && !src.match(/^(http|ftp)s?:\\/\\/./)) {\n    _fs[\"default\"].readFile(src, cb);\n  } else {\n    loadFromURL({\n      url: src\n    }, cb);\n  }\n}\n\nfunction isRawRGBAData(obj) {\n  return obj && (0, _typeof2[\"default\"])(obj) === 'object' && typeof obj.width === 'number' && typeof obj.height === 'number' && (Buffer.isBuffer(obj.data) || obj.data instanceof Uint8Array || typeof Uint8ClampedArray === 'function' && obj.data instanceof Uint8ClampedArray) && (obj.data.length === obj.width * obj.height * 4 || obj.data.length === obj.width * obj.height * 3);\n}\n\nfunction makeRGBABufferFromRGB(buffer) {\n  if (buffer.length % 3 !== 0) {\n    throw new Error('Buffer length is incorrect');\n  }\n\n  var rgbaBuffer = Buffer.allocUnsafe(buffer.length / 3 * 4);\n  var j = 0;\n\n  for (var _i2 = 0; _i2 < buffer.length; _i2++) {\n    rgbaBuffer[j] = buffer[_i2];\n\n    if ((_i2 + 1) % 3 === 0) {\n      rgbaBuffer[++j] = 255;\n    }\n\n    j++;\n  }\n\n  return rgbaBuffer;\n}\n\nvar emptyBitmap = {\n  data: null,\n  width: null,\n  height: null\n};\n/**\n * Jimp constructor (from a file)\n * @param path a path to the image\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (from a url with options)\n * @param options { url, otherOptions}\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (from another Jimp image or raw image data)\n * @param image a Jimp image to clone\n * @param {function(Error, Jimp)} cb a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (from a Buffer)\n * @param data a Buffer containing the image data\n * @param {function(Error, Jimp)} cb a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (to generate a new image)\n * @param w the width of the image\n * @param h the height of the image\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (to generate a new image)\n * @param w the width of the image\n * @param h the height of the image\n * @param background color to fill the image with\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\nvar Jimp =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  (0, _inherits2[\"default\"])(Jimp, _EventEmitter); // An object representing a bitmap in memory, comprising:\n  //  - data: a buffer of the bitmap data\n  //  - width: the width of the image in pixels\n  //  - height: the height of the image in pixels\n  // Default colour to use for new pixels\n  // Default MIME is PNG\n  // Exif data for the image\n  // Whether Transparency supporting formats will be exported as RGB or RGBA\n\n  function Jimp() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    (0, _classCallCheck2[\"default\"])(this, Jimp);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(Jimp).call(this));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"bitmap\", emptyBitmap);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_background\", 0x00000000);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_originalMime\", Jimp.MIME_PNG);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_exif\", null);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_rgba\", true);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"writeAsync\", function (path) {\n      return (0, _promisify[\"default\"])(_this.write, (0, _assertThisInitialized2[\"default\"])(_this), path);\n    });\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"getBase64Async\", function (mime) {\n      return (0, _promisify[\"default\"])(_this.getBase64, (0, _assertThisInitialized2[\"default\"])(_this), mime);\n    });\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"getBuffer\", _imageBitmap.getBuffer);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"getBufferAsync\", _imageBitmap.getBufferAsync);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"getPixelColour\", _this.getPixelColor);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"setPixelColour\", _this.setPixelColor);\n    var jimpInstance = (0, _assertThisInitialized2[\"default\"])(_this);\n    var cb = noop;\n\n    if (isArrayBuffer(args[0])) {\n      args[0] = bufferFromArrayBuffer(args[0]);\n    }\n\n    function finish() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var err = args[0];\n      var evData = err || {};\n      evData.methodName = 'constructor';\n      setTimeout(function () {\n        var _cb; // run on next tick.\n\n\n        if (err && cb === noop) {\n          jimpInstance.emitError('constructor', err);\n        } else if (!err) {\n          jimpInstance.emitMulti('constructor', 'initialized');\n        }\n\n        (_cb = cb).call.apply(_cb, [jimpInstance].concat(args));\n      }, 1);\n    }\n\n    if (typeof args[0] === 'number' && typeof args[1] === 'number' || parseInt(args[0], 10) && parseInt(args[1], 10)) {\n      // create a new image\n      var w = parseInt(args[0], 10);\n      var h = parseInt(args[1], 10);\n      cb = args[2]; // with a hex color\n\n      if (typeof args[2] === 'number') {\n        _this._background = args[2];\n        cb = args[3];\n      } // with a css color\n\n\n      if (typeof args[2] === 'string') {\n        _this._background = Jimp.cssColorToHex(args[2]);\n        cb = args[3];\n      }\n\n      if (typeof cb === 'undefined') {\n        cb = noop;\n      }\n\n      if (typeof cb !== 'function') {\n        return (0, _possibleConstructorReturn2[\"default\"])(_this, _utils.throwError.call((0, _assertThisInitialized2[\"default\"])(_this), 'cb must be a function', finish));\n      }\n\n      _this.bitmap = {\n        data: Buffer.alloc(w * h * 4),\n        width: w,\n        height: h\n      };\n\n      for (var _i3 = 0; _i3 < _this.bitmap.data.length; _i3 += 4) {\n        _this.bitmap.data.writeUInt32BE(_this._background, _i3);\n      }\n\n      finish(null, (0, _assertThisInitialized2[\"default\"])(_this));\n    } else if ((0, _typeof2[\"default\"])(args[0]) === 'object' && args[0].url) {\n      cb = args[1] || noop;\n\n      if (typeof cb !== 'function') {\n        return (0, _possibleConstructorReturn2[\"default\"])(_this, _utils.throwError.call((0, _assertThisInitialized2[\"default\"])(_this), 'cb must be a function', finish));\n      }\n\n      loadFromURL(args[0], function (err, data) {\n        if (err) {\n          return _utils.throwError.call((0, _assertThisInitialized2[\"default\"])(_this), err, finish);\n        }\n\n        _this.parseBitmap(data, args[0].url, finish);\n      });\n    } else if (args[0] instanceof Jimp) {\n      // clone an existing Jimp\n      var original = args[0];\n      cb = args[1];\n\n      if (typeof cb === 'undefined') {\n        cb = noop;\n      }\n\n      if (typeof cb !== 'function') {\n        return (0, _possibleConstructorReturn2[\"default\"])(_this, _utils.throwError.call((0, _assertThisInitialized2[\"default\"])(_this), 'cb must be a function', finish));\n      }\n\n      _this.bitmap = {\n        data: Buffer.from(original.bitmap.data),\n        width: original.bitmap.width,\n        height: original.bitmap.height\n      };\n      _this._quality = original._quality;\n      _this._deflateLevel = original._deflateLevel;\n      _this._deflateStrategy = original._deflateStrategy;\n      _this._filterType = original._filterType;\n      _this._rgba = original._rgba;\n      _this._background = original._background;\n      _this._originalMime = original._originalMime;\n      finish(null, (0, _assertThisInitialized2[\"default\"])(_this));\n    } else if (isRawRGBAData(args[0])) {\n      var imageData = args[0];\n      cb = args[1] || noop;\n      var isRGBA = imageData.width * imageData.height * 4 === imageData.data.length;\n      var buffer = isRGBA ? Buffer.from(imageData.data) : makeRGBABufferFromRGB(imageData.data);\n      _this.bitmap = {\n        data: buffer,\n        width: imageData.width,\n        height: imageData.height\n      };\n      finish(null, (0, _assertThisInitialized2[\"default\"])(_this));\n    } else if (typeof args[0] === 'string') {\n      // read from a path\n      var path = args[0];\n      cb = args[1];\n\n      if (typeof cb === 'undefined') {\n        cb = noop;\n      }\n\n      if (typeof cb !== 'function') {\n        return (0, _possibleConstructorReturn2[\"default\"])(_this, _utils.throwError.call((0, _assertThisInitialized2[\"default\"])(_this), 'cb must be a function', finish));\n      }\n\n      loadBufferFromPath(path, function (err, data) {\n        if (err) {\n          return _utils.throwError.call((0, _assertThisInitialized2[\"default\"])(_this), err, finish);\n        }\n\n        _this.parseBitmap(data, path, finish);\n      });\n    } else if ((0, _typeof2[\"default\"])(args[0]) === 'object' && Buffer.isBuffer(args[0])) {\n      // read from a buffer\n      var data = args[0];\n      cb = args[1];\n\n      if (typeof cb !== 'function') {\n        return (0, _possibleConstructorReturn2[\"default\"])(_this, _utils.throwError.call((0, _assertThisInitialized2[\"default\"])(_this), 'cb must be a function', finish));\n      }\n\n      _this.parseBitmap(data, null, finish);\n    } else {\n      // Allow client libs to add new ways to build a Jimp object.\n      // Extra constructors must be added by `Jimp.appendConstructorOption()`\n      cb = args[args.length - 1];\n\n      if (typeof cb !== 'function') {\n        // TODO: try to solve the args after cb problem.\n        cb = args[args.length - 2];\n\n        if (typeof cb !== 'function') {\n          cb = noop;\n        }\n      }\n\n      var extraConstructor = Jimp.__extraConstructors.find(function (c) {\n        return c.test.apply(c, args);\n      });\n\n      if (extraConstructor) {\n        new Promise(function (resolve, reject) {\n          var _extraConstructor$run;\n\n          return (_extraConstructor$run = extraConstructor.run).call.apply(_extraConstructor$run, [(0, _assertThisInitialized2[\"default\"])(_this), resolve, reject].concat(args));\n        }).then(function () {\n          return finish(null, (0, _assertThisInitialized2[\"default\"])(_this));\n        })[\"catch\"](finish);\n      } else {\n        return (0, _possibleConstructorReturn2[\"default\"])(_this, _utils.throwError.call((0, _assertThisInitialized2[\"default\"])(_this), 'No matching constructor overloading was found. ' + 'Please see the docs for how to call the Jimp constructor.', finish));\n      }\n    }\n\n    return _this;\n  }\n  /**\n   * Parse a bitmap with the loaded image types.\n   *\n   * @param {Buffer} data raw image data\n   * @param {string} path optional path to file\n   * @param {function(Error, Jimp)} finish (optional) a callback for when complete\n   * @memberof Jimp\n   */\n\n\n  (0, _createClass2[\"default\"])(Jimp, [{\n    key: \"parseBitmap\",\n    value: function parseBitmap(data, path, finish) {\n      _imageBitmap.parseBitmap.call(this, data, null, finish);\n    }\n    /**\n     * Sets the type of the image (RGB or RGBA) when saving in a format that supports transparency (default is RGBA)\n     * @param {boolean} bool A Boolean, true to use RGBA or false to use RGB\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp} this for chaining of methods\n     */\n\n  }, {\n    key: \"rgba\",\n    value: function rgba(bool, cb) {\n      if (typeof bool !== 'boolean') {\n        return _utils.throwError.call(this, 'bool must be a boolean, true for RGBA or false for RGB', cb);\n      }\n\n      this._rgba = bool;\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    }\n    /**\n     * Emit for multiple listeners\n     * @param {string} methodName name of the method to emit an error for\n     * @param {string} eventName name of the eventName to emit an error for\n     * @param {object} data to emit\n     */\n\n  }, {\n    key: \"emitMulti\",\n    value: function emitMulti(methodName, eventName) {\n      var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      data = Object.assign(data, {\n        methodName: methodName,\n        eventName: eventName\n      });\n      this.emit('any', data);\n\n      if (methodName) {\n        this.emit(methodName, data);\n      }\n\n      this.emit(eventName, data);\n    }\n  }, {\n    key: \"emitError\",\n    value: function emitError(methodName, err) {\n      this.emitMulti(methodName, 'error', err);\n    }\n    /**\n     * Get the current height of the image\n     * @return {number} height of the image\n     */\n\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return this.bitmap.height;\n    }\n    /**\n     * Get the current width of the image\n     * @return {number} width of the image\n     */\n\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return this.bitmap.width;\n    }\n    /**\n     * Nicely format Jimp object when sent to the console e.g. console.log(image)\n     * @returns {string} pretty printed\n     */\n\n  }, {\n    key: \"inspect\",\n    value: function inspect() {\n      return '<Jimp ' + (this.bitmap === emptyBitmap ? 'pending...' : this.bitmap.width + 'x' + this.bitmap.height) + '>';\n    }\n    /**\n     * Nicely format Jimp object when converted to a string\n     * @returns {string} pretty printed\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return '[object Jimp]';\n    }\n    /**\n     * Returns the original MIME of the image (default: \"image/png\")\n     * @returns {string} the MIME\n     */\n\n  }, {\n    key: \"getMIME\",\n    value: function getMIME() {\n      var mime = this._originalMime || Jimp.MIME_PNG;\n      return mime;\n    }\n    /**\n     * Returns the appropriate file extension for the original MIME of the image (default: \"png\")\n     * @returns {string} the file extension\n     */\n\n  }, {\n    key: \"getExtension\",\n    value: function getExtension() {\n      var mime = this.getMIME();\n      return MIME.getExtension(mime);\n    }\n    /**\n     * Writes the image to a file\n     * @param {string} path a path to the destination file\n     * @param {function(Error, Jimp)} cb (optional) a function to call when the image is saved to disk\n     * @returns {Jimp} this for chaining of methods\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(path, cb) {\n      var _this2 = this;\n\n      if (!_fs[\"default\"] || !_fs[\"default\"].createWriteStream) {\n        throw new Error('Cant access the filesystem. You can use the getBase64 method.');\n      }\n\n      if (typeof path !== 'string') {\n        return _utils.throwError.call(this, 'path must be a string', cb);\n      }\n\n      if (typeof cb === 'undefined') {\n        cb = noop;\n      }\n\n      if (typeof cb !== 'function') {\n        return _utils.throwError.call(this, 'cb must be a function', cb);\n      }\n\n      var mime = MIME.getType(path) || this.getMIME();\n\n      var pathObj = _path[\"default\"].parse(path);\n\n      if (pathObj.dir) {\n        _mkdirp[\"default\"].sync(pathObj.dir);\n      }\n\n      this.getBuffer(mime, function (err, buffer) {\n        if (err) {\n          return _utils.throwError.call(_this2, err, cb);\n        }\n\n        var stream = _fs[\"default\"].createWriteStream(path);\n\n        stream.on('open', function () {\n          stream.write(buffer);\n          stream.end();\n        }).on('error', function (err) {\n          return _utils.throwError.call(_this2, err, cb);\n        });\n        stream.on('finish', function () {\n          cb.call(_this2, null, _this2);\n        });\n      });\n      return this;\n    }\n  }, {\n    key: \"getBase64\",\n\n    /**\n     * Converts the image to a base 64 string\n     * @param {string} mime the mime type of the image data to be created\n     * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n     * @returns {Jimp} this for chaining of methods\n     */\n    value: function getBase64(mime, cb) {\n      if (mime === Jimp.AUTO) {\n        // allow auto MIME detection\n        mime = this.getMIME();\n      }\n\n      if (typeof mime !== 'string') {\n        return _utils.throwError.call(this, 'mime must be a string', cb);\n      }\n\n      if (typeof cb !== 'function') {\n        return _utils.throwError.call(this, 'cb must be a function', cb);\n      }\n\n      this.getBuffer(mime, function (err, data) {\n        if (err) {\n          return _utils.throwError.call(this, err, cb);\n        }\n\n        var src = 'data:' + mime + ';base64,' + data.toString('base64');\n        cb.call(this, null, src);\n      });\n      return this;\n    }\n  }, {\n    key: \"hash\",\n\n    /**\n     * Generates a perceptual hash of the image <https://en.wikipedia.org/wiki/Perceptual_hashing>. And pads the string. Can configure base.\n     * @param {number} base (optional) a number between 2 and 64 representing the base for the hash (e.g. 2 is binary, 10 is decimal, 16 is hex, 64 is base 64). Defaults to 64.\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {string} a string representing the hash\n     */\n    value: function hash(base, cb) {\n      base = base || 64;\n\n      if (typeof base === 'function') {\n        cb = base;\n        base = 64;\n      }\n\n      if (typeof base !== 'number') {\n        return _utils.throwError.call(this, 'base must be a number', cb);\n      }\n\n      if (base < 2 || base > 64) {\n        return _utils.throwError.call(this, 'base must be a number between 2 and 64', cb);\n      }\n\n      var hash = this.pHash();\n      hash = (0, _anyBase[\"default\"])(_anyBase[\"default\"].BIN, alphabet.slice(0, base))(hash);\n\n      while (hash.length < maxHashLength[base]) {\n        hash = '0' + hash; // pad out with leading zeros\n      }\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, hash);\n      }\n\n      return hash;\n    }\n    /**\n     * Calculates the perceptual hash\n     * @returns {number} the perceptual hash\n     */\n\n  }, {\n    key: \"pHash\",\n    value: function pHash() {\n      var pHash = new _phash[\"default\"]();\n      return pHash.getHash(this);\n    }\n    /**\n     * Calculates the hamming distance of the current image and a hash based on their perceptual hash\n     * @param {hash} compareHash hash to compare to\n     * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical\n     */\n\n  }, {\n    key: \"distanceFromHash\",\n    value: function distanceFromHash(compareHash) {\n      var pHash = new _phash[\"default\"]();\n      var currentHash = pHash.getHash(this);\n      return pHash.distance(currentHash, compareHash);\n    }\n    /**\n     * Converts the image to a buffer\n     * @param {string} mime the mime type of the image buffer to be created\n     * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n     * @returns {Jimp} this for chaining of methods\n     */\n\n  }, {\n    key: \"getPixelIndex\",\n\n    /**\n     * Returns the offset of a pixel in the bitmap buffer\n     * @param {number} x the x coordinate\n     * @param {number} y the y coordinate\n     * @param {string} edgeHandling (optional) define how to sum pixels from outside the border\n     * @param {number} cb (optional) a callback for when complete\n     * @returns {number} the index of the pixel or -1 if not found\n     */\n    value: function getPixelIndex(x, y, edgeHandling, cb) {\n      var xi;\n      var yi;\n\n      if (typeof edgeHandling === 'function' && typeof cb === 'undefined') {\n        cb = edgeHandling;\n        edgeHandling = null;\n      }\n\n      if (!edgeHandling) {\n        edgeHandling = Jimp.EDGE_EXTEND;\n      }\n\n      if (typeof x !== 'number' || typeof y !== 'number') {\n        return _utils.throwError.call(this, 'x and y must be numbers', cb);\n      } // round input\n\n\n      x = Math.round(x);\n      y = Math.round(y);\n      xi = x;\n      yi = y;\n\n      if (edgeHandling === Jimp.EDGE_EXTEND) {\n        if (x < 0) xi = 0;\n        if (x >= this.bitmap.width) xi = this.bitmap.width - 1;\n        if (y < 0) yi = 0;\n        if (y >= this.bitmap.height) yi = this.bitmap.height - 1;\n      }\n\n      if (edgeHandling === Jimp.EDGE_WRAP) {\n        if (x < 0) {\n          xi = this.bitmap.width + x;\n        }\n\n        if (x >= this.bitmap.width) {\n          xi = x % this.bitmap.width;\n        }\n\n        if (y < 0) {\n          xi = this.bitmap.height + y;\n        }\n\n        if (y >= this.bitmap.height) {\n          yi = y % this.bitmap.height;\n        }\n      }\n\n      var i = this.bitmap.width * yi + xi << 2; // if out of bounds index is -1\n\n      if (xi < 0 || xi >= this.bitmap.width) {\n        i = -1;\n      }\n\n      if (yi < 0 || yi >= this.bitmap.height) {\n        i = -1;\n      }\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, i);\n      }\n\n      return i;\n    }\n    /**\n     * Returns the hex colour value of a pixel\n     * @param {number} x the x coordinate\n     * @param {number} y the y coordinate\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {number} the color of the pixel\n     */\n\n  }, {\n    key: \"getPixelColor\",\n    value: function getPixelColor(x, y, cb) {\n      if (typeof x !== 'number' || typeof y !== 'number') return _utils.throwError.call(this, 'x and y must be numbers', cb); // round input\n\n      x = Math.round(x);\n      y = Math.round(y);\n      var idx = this.getPixelIndex(x, y);\n      var hex = this.bitmap.data.readUInt32BE(idx);\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, hex);\n      }\n\n      return hex;\n    }\n  }, {\n    key: \"setPixelColor\",\n\n    /**\n     * Returns the hex colour value of a pixel\n     * @param {number} hex color to set\n     * @param {number} x the x coordinate\n     * @param {number} y the y coordinate\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {number} the index of the pixel or -1 if not found\n     */\n    value: function setPixelColor(hex, x, y, cb) {\n      if (typeof hex !== 'number' || typeof x !== 'number' || typeof y !== 'number') return _utils.throwError.call(this, 'hex, x and y must be numbers', cb); // round input\n\n      x = Math.round(x);\n      y = Math.round(y);\n      var idx = this.getPixelIndex(x, y);\n      this.bitmap.data.writeUInt32BE(hex, idx);\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"hasAlpha\",\n\n    /**\n     * Determine if the image contains opaque pixels.\n     * @return {boolean} hasAlpha whether the image contains opaque pixels\n     */\n    value: function hasAlpha() {\n      for (var yIndex = 0; yIndex < this.bitmap.height; yIndex++) {\n        for (var xIndex = 0; xIndex < this.bitmap.width; xIndex++) {\n          var idx = this.bitmap.width * yIndex + xIndex << 2;\n          var alpha = this.bitmap.data[idx + 3];\n\n          if (alpha !== 0xff) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Iterate scan through a region of the bitmap\n     * @param {number} x the x coordinate to begin the scan at\n     * @param {number} y the y coordinate to begin the scan at\n     * @param w the width of the scan region\n     * @param h the height of the scan region\n     * @returns {IterableIterator<{x: number, y: number, idx: number, image: Jimp}>}\n     */\n\n  }, {\n    key: \"scanIterator\",\n    value: function scanIterator(x, y, w, h) {\n      if (typeof x !== 'number' || typeof y !== 'number') {\n        return _utils.throwError.call(this, 'x and y must be numbers');\n      }\n\n      if (typeof w !== 'number' || typeof h !== 'number') {\n        return _utils.throwError.call(this, 'w and h must be numbers');\n      }\n\n      return (0, _utils.scanIterator)(this, x, y, w, h);\n    }\n  }]);\n  return Jimp;\n}(_events[\"default\"]);\n\nfunction addConstants(constants) {\n  var jimpInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Jimp;\n  Object.entries(constants).forEach(function (_ref) {\n    var _ref2 = (0, _slicedToArray2[\"default\"])(_ref, 2),\n        name = _ref2[0],\n        value = _ref2[1];\n\n    jimpInstance[name] = value;\n  });\n}\n\nfunction addJimpMethods(methods) {\n  var jimpInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Jimp;\n  Object.entries(methods).forEach(function (_ref3) {\n    var _ref4 = (0, _slicedToArray2[\"default\"])(_ref3, 2),\n        name = _ref4[0],\n        value = _ref4[1];\n\n    jimpInstance.prototype[name] = value;\n  });\n}\n\naddConstants(constants);\naddJimpMethods({\n  composite: _composite[\"default\"]\n});\nJimp.__extraConstructors = [];\n/**\n * Allow client libs to add new ways to build a Jimp object.\n * @param {string} name identify the extra constructor.\n * @param {function} test a function that returns true when it accepts the arguments passed to the main constructor.\n * @param {function} run where the magic happens.\n */\n\nJimp.appendConstructorOption = function (name, test, run) {\n  Jimp.__extraConstructors.push({\n    name: name,\n    test: test,\n    run: run\n  });\n};\n/**\n * Read an image from a file or a Buffer. Takes the same args as the constructor\n * @returns {Promise} a promise\n */\n\n\nJimp.read = function () {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n\n  return new Promise(function (resolve, reject) {\n    (0, _construct2[\"default\"])(Jimp, args.concat([function (err, image) {\n      if (err) reject(err);else resolve(image);\n    }]));\n  });\n};\n\nJimp.create = Jimp.read;\n/**\n * A static helper method that converts RGBA values to a single integer value\n * @param {number} r the red value (0-255)\n * @param {number} g the green value (0-255)\n * @param {number} b the blue value (0-255)\n * @param {number} a the alpha value (0-255)\n * @param {function(Error, Jimp)} cb (optional) A callback for when complete\n * @returns {number} an single integer colour value\n */\n\nJimp.rgbaToInt = function (r, g, b, a, cb) {\n  if (typeof r !== 'number' || typeof g !== 'number' || typeof b !== 'number' || typeof a !== 'number') {\n    return _utils.throwError.call(this, 'r, g, b and a must be numbers', cb);\n  }\n\n  if (r < 0 || r > 255) {\n    return _utils.throwError.call(this, 'r must be between 0 and 255', cb);\n  }\n\n  if (g < 0 || g > 255) {\n    _utils.throwError.call(this, 'g must be between 0 and 255', cb);\n  }\n\n  if (b < 0 || b > 255) {\n    return _utils.throwError.call(this, 'b must be between 0 and 255', cb);\n  }\n\n  if (a < 0 || a > 255) {\n    return _utils.throwError.call(this, 'a must be between 0 and 255', cb);\n  }\n\n  r = Math.round(r);\n  b = Math.round(b);\n  g = Math.round(g);\n  a = Math.round(a);\n  var i = r * Math.pow(256, 3) + g * Math.pow(256, 2) + b * Math.pow(256, 1) + a * Math.pow(256, 0);\n\n  if ((0, _utils.isNodePattern)(cb)) {\n    cb.call(this, null, i);\n  }\n\n  return i;\n};\n/**\n * A static helper method that converts RGBA values to a single integer value\n * @param {number} i a single integer value representing an RGBA colour (e.g. 0xFF0000FF for red)\n * @param {function(Error, Jimp)} cb (optional) A callback for when complete\n * @returns {object} an object with the properties r, g, b and a representing RGBA values\n */\n\n\nJimp.intToRGBA = function (i, cb) {\n  if (typeof i !== 'number') {\n    return _utils.throwError.call(this, 'i must be a number', cb);\n  }\n\n  var rgba = {};\n  rgba.r = Math.floor(i / Math.pow(256, 3));\n  rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));\n  rgba.b = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1));\n  rgba.a = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0));\n\n  if ((0, _utils.isNodePattern)(cb)) {\n    cb.call(this, null, rgba);\n  }\n\n  return rgba;\n};\n/**\n * Converts a css color (Hex, 8-digit (RGBA) Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to a hex number\n * @param {string} cssColor a number\n * @returns {number} a hex number representing a color\n */\n\n\nJimp.cssColorToHex = function (cssColor) {\n  cssColor = cssColor || 0; // 0, null, undefined, NaN\n\n  if (typeof cssColor === 'number') return Number(cssColor);\n  return parseInt((0, _tinycolor[\"default\"])(cssColor).toHex8(), 16);\n};\n/**\n * Limits a number to between 0 or 255\n * @param {number} n a number\n * @returns {number} the number limited to between 0 or 255\n */\n\n\nJimp.limit255 = function (n) {\n  n = Math.max(n, 0);\n  n = Math.min(n, 255);\n  return n;\n};\n/**\n * Diffs two images and returns\n * @param {Jimp} img1 a Jimp image to compare\n * @param {Jimp} img2 a Jimp image to compare\n * @param {number} threshold (optional) a number, 0 to 1, the smaller the value the more sensitive the comparison (default: 0.1)\n * @returns {object} an object { percent: percent similar, diff: a Jimp image highlighting differences }\n */\n\n\nJimp.diff = function (img1, img2) {\n  var threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;\n  if (!(img1 instanceof Jimp) || !(img2 instanceof Jimp)) return _utils.throwError.call(this, 'img1 and img2 must be an Jimp images');\n  var bmp1 = img1.bitmap;\n  var bmp2 = img2.bitmap;\n\n  if (bmp1.width !== bmp2.width || bmp1.height !== bmp2.height) {\n    if (bmp1.width * bmp1.height > bmp2.width * bmp2.height) {\n      // img1 is bigger\n      img1 = img1.cloneQuiet().resize(bmp2.width, bmp2.height);\n    } else {\n      // img2 is bigger (or they are the same in area)\n      img2 = img2.cloneQuiet().resize(bmp1.width, bmp1.height);\n    }\n  }\n\n  if (typeof threshold !== 'number' || threshold < 0 || threshold > 1) {\n    return _utils.throwError.call(this, 'threshold must be a number between 0 and 1');\n  }\n\n  var diff = new Jimp(bmp1.width, bmp1.height, 0xffffffff);\n  var numDiffPixels = (0, _pixelmatch[\"default\"])(bmp1.data, bmp2.data, diff.bitmap.data, diff.bitmap.width, diff.bitmap.height, {\n    threshold: threshold\n  });\n  return {\n    percent: numDiffPixels / (diff.bitmap.width * diff.bitmap.height),\n    image: diff\n  };\n};\n/**\n * Calculates the hamming distance of two images based on their perceptual hash\n * @param {Jimp} img1 a Jimp image to compare\n * @param {Jimp} img2 a Jimp image to compare\n * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical\n */\n\n\nJimp.distance = function (img1, img2) {\n  var phash = new _phash[\"default\"]();\n  var hash1 = phash.getHash(img1);\n  var hash2 = phash.getHash(img2);\n  return phash.distance(hash1, hash2);\n};\n/**\n * Calculates the hamming distance of two images based on their perceptual hash\n * @param {hash} hash1 a pHash\n * @param {hash} hash2 a pHash\n * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical\n */\n\n\nJimp.compareHashes = function (hash1, hash2) {\n  var phash = new _phash[\"default\"]();\n  return phash.distance(hash1, hash2);\n};\n/**\n * Compute color difference\n * 0 means no difference, 1 means maximum difference.\n * @param {number} rgba1:    first color to compare.\n * @param {number} rgba2:    second color to compare.\n * Both parameters must be an color object {r:val, g:val, b:val, a:val}\n * Where `a` is optional and `val` is an integer between 0 and 255.\n * @returns {number} float between 0 and 1.\n */\n\n\nJimp.colorDiff = function (rgba1, rgba2) {\n  var pow = function pow(n) {\n    return Math.pow(n, 2);\n  };\n\n  var max = Math.max;\n  var maxVal = 255 * 255 * 3;\n\n  if (rgba1.a !== 0 && !rgba1.a) {\n    rgba1.a = 255;\n  }\n\n  if (rgba2.a !== 0 && !rgba2.a) {\n    rgba2.a = 255;\n  }\n\n  return (max(pow(rgba1.r - rgba2.r), pow(rgba1.r - rgba2.r - rgba1.a + rgba2.a)) + max(pow(rgba1.g - rgba2.g), pow(rgba1.g - rgba2.g - rgba1.a + rgba2.a)) + max(pow(rgba1.b - rgba2.b), pow(rgba1.b - rgba2.b - rgba1.a + rgba2.a))) / maxVal;\n};\n/**\n * Helper to create Jimp methods that emit events before and after its execution.\n * @param {string} methodName   The name to be appended to Jimp prototype.\n * @param {string} evName       The event name to be called.\n *                     It will be prefixed by `before-` and emitted when on method call.\n *                     It will be appended by `ed` and emitted after the method run.\n * @param {function} method       A function implementing the method itself.\n * It will also create a quiet version that will not emit events, to not\n * mess the user code with many `changed` event calls. You can call with\n * `methodName + \"Quiet\"`.\n *\n * The emitted event comes with a object parameter to the listener with the\n * `methodName` as one attribute.\n */\n\n\nfunction jimpEvMethod(methodName, evName, method) {\n  var evNameBefore = 'before-' + evName;\n  var evNameAfter = evName.replace(/e$/, '') + 'ed';\n\n  Jimp.prototype[methodName] = function () {\n    var wrappedCb;\n\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    var cb = args[method.length - 1];\n    var jimpInstance = this;\n\n    if (typeof cb === 'function') {\n      wrappedCb = function wrappedCb() {\n        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          args[_key5] = arguments[_key5];\n        }\n\n        var err = args[0],\n            data = args[1];\n\n        if (err) {\n          jimpInstance.emitError(methodName, err);\n        } else {\n          jimpInstance.emitMulti(methodName, evNameAfter, (0, _defineProperty2[\"default\"])({}, methodName, data));\n        }\n\n        cb.apply(this, args);\n      };\n\n      args[args.length - 1] = wrappedCb;\n    } else {\n      wrappedCb = false;\n    }\n\n    this.emitMulti(methodName, evNameBefore);\n    var result;\n\n    try {\n      result = method.apply(this, args);\n\n      if (!wrappedCb) {\n        this.emitMulti(methodName, evNameAfter, (0, _defineProperty2[\"default\"])({}, methodName, result));\n      }\n    } catch (error) {\n      error.methodName = methodName;\n      this.emitError(methodName, error);\n    }\n\n    return result;\n  };\n\n  Jimp.prototype[methodName + 'Quiet'] = method;\n}\n/**\n * Creates a new image that is a clone of this one.\n * @param {function(Error, Jimp)} cb (optional) A callback for when complete\n * @returns the new image\n */\n\n\njimpEvMethod('clone', 'clone', function (cb) {\n  var clone = new Jimp(this);\n\n  if ((0, _utils.isNodePattern)(cb)) {\n    cb.call(clone, null, clone);\n  }\n\n  return clone;\n});\n/**\n * Simplify jimpEvMethod call for the common `change` evName.\n * @param {string} methodName name of the method\n * @param {function} method to watch changes for\n */\n\nfunction jimpEvChange(methodName, method) {\n  jimpEvMethod(methodName, 'change', method);\n}\n/**\n * Sets the type of the image (RGB or RGBA) when saving as PNG format (default is RGBA)\n * @param b A Boolean, true to use RGBA or false to use RGB\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n\n\njimpEvChange('background', function (hex, cb) {\n  if (typeof hex !== 'number') {\n    return _utils.throwError.call(this, 'hex must be a hexadecimal rgba value', cb);\n  }\n\n  this._background = hex;\n\n  if ((0, _utils.isNodePattern)(cb)) {\n    cb.call(this, null, this);\n  }\n\n  return this;\n});\n/**\n * Scans through a region of the bitmap, calling a function for each pixel.\n * @param {number} x the x coordinate to begin the scan at\n * @param {number} y the y coordinate to begin the scan at\n * @param w the width of the scan region\n * @param h the height of the scan region\n * @param f a function to call on even pixel; the (x, y) position of the pixel\n * and the index of the pixel in the bitmap buffer are passed to the function\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n\njimpEvChange('scan', function (x, y, w, h, f, cb) {\n  if (typeof x !== 'number' || typeof y !== 'number') {\n    return _utils.throwError.call(this, 'x and y must be numbers', cb);\n  }\n\n  if (typeof w !== 'number' || typeof h !== 'number') {\n    return _utils.throwError.call(this, 'w and h must be numbers', cb);\n  }\n\n  if (typeof f !== 'function') {\n    return _utils.throwError.call(this, 'f must be a function', cb);\n  }\n\n  var result = (0, _utils.scan)(this, x, y, w, h, f);\n\n  if ((0, _utils.isNodePattern)(cb)) {\n    cb.call(this, null, result);\n  }\n\n  return result;\n});\n\nif (process.env.ENVIRONMENT === 'BROWSER') {\n  // For use in a web browser or web worker\n\n  /* global self */\n  var gl;\n\n  if (typeof window !== 'undefined' && (typeof window === \"undefined\" ? \"undefined\" : (0, _typeof2[\"default\"])(window)) === 'object') {\n    gl = window;\n  }\n\n  if (typeof self !== 'undefined' && (typeof self === \"undefined\" ? \"undefined\" : (0, _typeof2[\"default\"])(self)) === 'object') {\n    gl = self;\n  }\n\n  gl.Jimp = Jimp;\n  gl.Buffer = Buffer;\n}\n\nvar _default = Jimp;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../src/index.js"],"names":["alphabet","maxHashLength","i","maxHash","anyBase","Object","buffer","Buffer","arrayBuffer","view","cb","response","options","loadFromURL","msg","fs","src","url","obj","rgbaBuffer","j","emptyBitmap","data","width","height","Jimp","EventEmitter","MIME_PNG","args","jimpInstance","isArrayBuffer","bufferFromArrayBuffer","err","evData","setTimeout","parseInt","w","h","throwError","finish","original","isRawRGBAData","imageData","isRGBA","makeRGBABufferFromRGB","path","loadBufferFromPath","extraConstructor","c","parseBitmap","bool","methodName","eventName","mime","MIME","pathObj","Path","mkdirp","stream","base","hash","pHash","ImagePHash","compareHash","currentHash","getBuffer","getBufferAsync","x","y","edgeHandling","Math","xi","yi","idx","hex","yIndex","xIndex","alpha","name","value","addConstants","addJimpMethods","composite","test","run","reject","resolve","r","g","b","a","rgba","cssColor","Number","n","threshold","img1","img2","bmp1","bmp2","diff","numDiffPixels","percent","image","phash","hash1","hash2","pow","max","maxVal","rgba1","rgba2","evNameBefore","evNameAfter","evName","method","wrappedCb","result","error","jimpEvMethod","clone","jimpEvChange","process","gl"],"mappings":"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","sourcesContent":["import fs from 'fs';\nimport Path from 'path';\nimport EventEmitter from 'events';\n\nimport { isNodePattern, throwError, scan, scanIterator } from '@jimp/utils';\nimport anyBase from 'any-base';\nimport mkdirp from 'mkdirp';\nimport pixelMatch from 'pixelmatch';\nimport tinyColor from 'tinycolor2';\n\nimport ImagePHash from './modules/phash';\nimport request from './request';\n\nimport composite from './composite';\nimport promisify from './utils/promisify';\nimport * as MIME from './utils/mime';\nimport { parseBitmap, getBuffer, getBufferAsync } from './utils/image-bitmap';\nimport * as constants from './constants';\n\nconst alphabet =\n  '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_';\n\n// an array storing the maximum string length of hashes at various bases\n// 0 and 1 do not exist as possible hash lengths\nconst maxHashLength = [NaN, NaN];\n\nfor (let i = 2; i < 65; i++) {\n  const maxHash = anyBase(anyBase.BIN, alphabet.slice(0, i))(\n    new Array(64 + 1).join('1')\n  );\n  maxHashLength.push(maxHash.length);\n}\n\n// no operation\nfunction noop() {}\n\n// error checking methods\n\nfunction isArrayBuffer(test) {\n  return (\n    Object.prototype.toString\n      .call(test)\n      .toLowerCase()\n      .indexOf('arraybuffer') > -1\n  );\n}\n\n// Prepare a Buffer object from the arrayBuffer. Necessary in the browser > node conversion,\n// But this function is not useful when running in node directly\nfunction bufferFromArrayBuffer(arrayBuffer) {\n  const buffer = Buffer.alloc(arrayBuffer.byteLength);\n  const view = new Uint8Array(arrayBuffer);\n\n  for (let i = 0; i < buffer.length; ++i) {\n    buffer[i] = view[i];\n  }\n\n  return buffer;\n}\n\nfunction loadFromURL(options, cb) {\n  request(options, (err, response, data) => {\n    if (err) {\n      return cb(err);\n    }\n\n    if ('headers' in response && 'location' in response.headers) {\n      options.url = response.headers.location;\n      return loadFromURL(options, cb);\n    }\n\n    if (typeof data === 'object' && Buffer.isBuffer(data)) {\n      return cb(null, data);\n    }\n\n    const msg =\n      'Could not load Buffer from <' +\n      options.url +\n      '> ' +\n      '(HTTP: ' +\n      response.statusCode +\n      ')';\n\n    return new Error(msg);\n  });\n}\n\nfunction loadBufferFromPath(src, cb) {\n  if (\n    fs &&\n    typeof fs.readFile === 'function' &&\n    !src.match(/^(http|ftp)s?:\\/\\/./)\n  ) {\n    fs.readFile(src, cb);\n  } else {\n    loadFromURL({ url: src }, cb);\n  }\n}\n\nfunction isRawRGBAData(obj) {\n  return (\n    obj &&\n    typeof obj === 'object' &&\n    typeof obj.width === 'number' &&\n    typeof obj.height === 'number' &&\n    (Buffer.isBuffer(obj.data) ||\n      obj.data instanceof Uint8Array ||\n      (typeof Uint8ClampedArray === 'function' &&\n        obj.data instanceof Uint8ClampedArray)) &&\n    (obj.data.length === obj.width * obj.height * 4 ||\n      obj.data.length === obj.width * obj.height * 3)\n  );\n}\n\nfunction makeRGBABufferFromRGB(buffer) {\n  if (buffer.length % 3 !== 0) {\n    throw new Error('Buffer length is incorrect');\n  }\n\n  const rgbaBuffer = Buffer.allocUnsafe((buffer.length / 3) * 4);\n  let j = 0;\n\n  for (let i = 0; i < buffer.length; i++) {\n    rgbaBuffer[j] = buffer[i];\n\n    if ((i + 1) % 3 === 0) {\n      rgbaBuffer[++j] = 255;\n    }\n\n    j++;\n  }\n\n  return rgbaBuffer;\n}\n\nconst emptyBitmap = {\n  data: null,\n  width: null,\n  height: null\n};\n\n/**\n * Jimp constructor (from a file)\n * @param path a path to the image\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (from a url with options)\n * @param options { url, otherOptions}\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (from another Jimp image or raw image data)\n * @param image a Jimp image to clone\n * @param {function(Error, Jimp)} cb a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (from a Buffer)\n * @param data a Buffer containing the image data\n * @param {function(Error, Jimp)} cb a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (to generate a new image)\n * @param w the width of the image\n * @param h the height of the image\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (to generate a new image)\n * @param w the width of the image\n * @param h the height of the image\n * @param background color to fill the image with\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\nclass Jimp extends EventEmitter {\n  // An object representing a bitmap in memory, comprising:\n  //  - data: a buffer of the bitmap data\n  //  - width: the width of the image in pixels\n  //  - height: the height of the image in pixels\n  bitmap = emptyBitmap;\n\n  // Default colour to use for new pixels\n  _background = 0x00000000;\n\n  // Default MIME is PNG\n  _originalMime = Jimp.MIME_PNG;\n\n  // Exif data for the image\n  _exif = null;\n\n  // Whether Transparency supporting formats will be exported as RGB or RGBA\n  _rgba = true;\n\n  constructor(...args) {\n    super();\n\n    const jimpInstance = this;\n    let cb = noop;\n\n    if (isArrayBuffer(args[0])) {\n      args[0] = bufferFromArrayBuffer(args[0]);\n    }\n\n    function finish(...args) {\n      const [err] = args;\n      const evData = err || {};\n      evData.methodName = 'constructor';\n\n      setTimeout(() => {\n        // run on next tick.\n        if (err && cb === noop) {\n          jimpInstance.emitError('constructor', err);\n        } else if (!err) {\n          jimpInstance.emitMulti('constructor', 'initialized');\n        }\n\n        cb.call(jimpInstance, ...args);\n      }, 1);\n    }\n\n    if (\n      (typeof args[0] === 'number' && typeof args[1] === 'number') ||\n      (parseInt(args[0], 10) && parseInt(args[1], 10))\n    ) {\n      // create a new image\n      const w = parseInt(args[0], 10);\n      const h = parseInt(args[1], 10);\n      cb = args[2];\n\n      // with a hex color\n      if (typeof args[2] === 'number') {\n        this._background = args[2];\n        cb = args[3];\n      }\n\n      // with a css color\n      if (typeof args[2] === 'string') {\n        this._background = Jimp.cssColorToHex(args[2]);\n        cb = args[3];\n      }\n\n      if (typeof cb === 'undefined') {\n        cb = noop;\n      }\n\n      if (typeof cb !== 'function') {\n        return throwError.call(this, 'cb must be a function', finish);\n      }\n\n      this.bitmap = {\n        data: Buffer.alloc(w * h * 4),\n        width: w,\n        height: h\n      };\n\n      for (let i = 0; i < this.bitmap.data.length; i += 4) {\n        this.bitmap.data.writeUInt32BE(this._background, i);\n      }\n\n      finish(null, this);\n    } else if (typeof args[0] === 'object' && args[0].url) {\n      cb = args[1] || noop;\n\n      if (typeof cb !== 'function') {\n        return throwError.call(this, 'cb must be a function', finish);\n      }\n\n      loadFromURL(args[0], (err, data) => {\n        if (err) {\n          return throwError.call(this, err, finish);\n        }\n\n        this.parseBitmap(data, args[0].url, finish);\n      });\n    } else if (args[0] instanceof Jimp) {\n      // clone an existing Jimp\n      const [original] = args;\n      cb = args[1];\n\n      if (typeof cb === 'undefined') {\n        cb = noop;\n      }\n\n      if (typeof cb !== 'function') {\n        return throwError.call(this, 'cb must be a function', finish);\n      }\n\n      this.bitmap = {\n        data: Buffer.from(original.bitmap.data),\n        width: original.bitmap.width,\n        height: original.bitmap.height\n      };\n\n      this._quality = original._quality;\n      this._deflateLevel = original._deflateLevel;\n      this._deflateStrategy = original._deflateStrategy;\n      this._filterType = original._filterType;\n      this._rgba = original._rgba;\n      this._background = original._background;\n      this._originalMime = original._originalMime;\n\n      finish(null, this);\n    } else if (isRawRGBAData(args[0])) {\n      const [imageData] = args;\n      cb = args[1] || noop;\n\n      const isRGBA =\n        imageData.width * imageData.height * 4 === imageData.data.length;\n      const buffer = isRGBA\n        ? Buffer.from(imageData.data)\n        : makeRGBABufferFromRGB(imageData.data);\n\n      this.bitmap = {\n        data: buffer,\n        width: imageData.width,\n        height: imageData.height\n      };\n\n      finish(null, this);\n    } else if (typeof args[0] === 'string') {\n      // read from a path\n      const path = args[0];\n      cb = args[1];\n\n      if (typeof cb === 'undefined') {\n        cb = noop;\n      }\n\n      if (typeof cb !== 'function') {\n        return throwError.call(this, 'cb must be a function', finish);\n      }\n\n      loadBufferFromPath(path, (err, data) => {\n        if (err) {\n          return throwError.call(this, err, finish);\n        }\n\n        this.parseBitmap(data, path, finish);\n      });\n    } else if (typeof args[0] === 'object' && Buffer.isBuffer(args[0])) {\n      // read from a buffer\n      const data = args[0];\n      cb = args[1];\n\n      if (typeof cb !== 'function') {\n        return throwError.call(this, 'cb must be a function', finish);\n      }\n\n      this.parseBitmap(data, null, finish);\n    } else {\n      // Allow client libs to add new ways to build a Jimp object.\n      // Extra constructors must be added by `Jimp.appendConstructorOption()`\n      cb = args[args.length - 1];\n\n      if (typeof cb !== 'function') {\n        // TODO: try to solve the args after cb problem.\n        cb = args[args.length - 2];\n\n        if (typeof cb !== 'function') {\n          cb = noop;\n        }\n      }\n\n      const extraConstructor = Jimp.__extraConstructors.find(c =>\n        c.test(...args)\n      );\n\n      if (extraConstructor) {\n        new Promise((resolve, reject) =>\n          extraConstructor.run.call(this, resolve, reject, ...args)\n        )\n          .then(() => finish(null, this))\n          .catch(finish);\n      } else {\n        return throwError.call(\n          this,\n          'No matching constructor overloading was found. ' +\n            'Please see the docs for how to call the Jimp constructor.',\n          finish\n        );\n      }\n    }\n  }\n\n  /**\n   * Parse a bitmap with the loaded image types.\n   *\n   * @param {Buffer} data raw image data\n   * @param {string} path optional path to file\n   * @param {function(Error, Jimp)} finish (optional) a callback for when complete\n   * @memberof Jimp\n   */\n  parseBitmap(data, path, finish) {\n    parseBitmap.call(this, data, null, finish);\n  }\n\n  /**\n   * Sets the type of the image (RGB or RGBA) when saving in a format that supports transparency (default is RGBA)\n   * @param {boolean} bool A Boolean, true to use RGBA or false to use RGB\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  rgba(bool, cb) {\n    if (typeof bool !== 'boolean') {\n      return throwError.call(\n        this,\n        'bool must be a boolean, true for RGBA or false for RGB',\n        cb\n      );\n    }\n\n    this._rgba = bool;\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  }\n\n  /**\n   * Emit for multiple listeners\n   * @param {string} methodName name of the method to emit an error for\n   * @param {string} eventName name of the eventName to emit an error for\n   * @param {object} data to emit\n   */\n  emitMulti(methodName, eventName, data = {}) {\n    data = Object.assign(data, { methodName, eventName });\n    this.emit('any', data);\n\n    if (methodName) {\n      this.emit(methodName, data);\n    }\n\n    this.emit(eventName, data);\n  }\n\n  emitError(methodName, err) {\n    this.emitMulti(methodName, 'error', err);\n  }\n\n  /**\n   * Get the current height of the image\n   * @return {number} height of the image\n   */\n  getHeight() {\n    return this.bitmap.height;\n  }\n\n  /**\n   * Get the current width of the image\n   * @return {number} width of the image\n   */\n  getWidth() {\n    return this.bitmap.width;\n  }\n\n  /**\n   * Nicely format Jimp object when sent to the console e.g. console.log(image)\n   * @returns {string} pretty printed\n   */\n  inspect() {\n    return (\n      '<Jimp ' +\n      (this.bitmap === emptyBitmap\n        ? 'pending...'\n        : this.bitmap.width + 'x' + this.bitmap.height) +\n      '>'\n    );\n  }\n\n  /**\n   * Nicely format Jimp object when converted to a string\n   * @returns {string} pretty printed\n   */\n  toString() {\n    return '[object Jimp]';\n  }\n\n  /**\n   * Returns the original MIME of the image (default: \"image/png\")\n   * @returns {string} the MIME\n   */\n  getMIME() {\n    const mime = this._originalMime || Jimp.MIME_PNG;\n\n    return mime;\n  }\n\n  /**\n   * Returns the appropriate file extension for the original MIME of the image (default: \"png\")\n   * @returns {string} the file extension\n   */\n  getExtension() {\n    const mime = this.getMIME();\n\n    return MIME.getExtension(mime);\n  }\n\n  /**\n   * Writes the image to a file\n   * @param {string} path a path to the destination file\n   * @param {function(Error, Jimp)} cb (optional) a function to call when the image is saved to disk\n   * @returns {Jimp} this for chaining of methods\n   */\n  write(path, cb) {\n    if (!fs || !fs.createWriteStream) {\n      throw new Error(\n        'Cant access the filesystem. You can use the getBase64 method.'\n      );\n    }\n\n    if (typeof path !== 'string') {\n      return throwError.call(this, 'path must be a string', cb);\n    }\n\n    if (typeof cb === 'undefined') {\n      cb = noop;\n    }\n\n    if (typeof cb !== 'function') {\n      return throwError.call(this, 'cb must be a function', cb);\n    }\n\n    const mime = MIME.getType(path) || this.getMIME();\n    const pathObj = Path.parse(path);\n\n    if (pathObj.dir) {\n      mkdirp.sync(pathObj.dir);\n    }\n\n    this.getBuffer(mime, (err, buffer) => {\n      if (err) {\n        return throwError.call(this, err, cb);\n      }\n\n      const stream = fs.createWriteStream(path);\n\n      stream\n        .on('open', () => {\n          stream.write(buffer);\n          stream.end();\n        })\n        .on('error', err => {\n          return throwError.call(this, err, cb);\n        });\n      stream.on('finish', () => {\n        cb.call(this, null, this);\n      });\n    });\n\n    return this;\n  }\n\n  writeAsync = path => promisify(this.write, this, path);\n\n  /**\n   * Converts the image to a base 64 string\n   * @param {string} mime the mime type of the image data to be created\n   * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n   * @returns {Jimp} this for chaining of methods\n   */\n  getBase64(mime, cb) {\n    if (mime === Jimp.AUTO) {\n      // allow auto MIME detection\n      mime = this.getMIME();\n    }\n\n    if (typeof mime !== 'string') {\n      return throwError.call(this, 'mime must be a string', cb);\n    }\n\n    if (typeof cb !== 'function') {\n      return throwError.call(this, 'cb must be a function', cb);\n    }\n\n    this.getBuffer(mime, function(err, data) {\n      if (err) {\n        return throwError.call(this, err, cb);\n      }\n\n      const src = 'data:' + mime + ';base64,' + data.toString('base64');\n      cb.call(this, null, src);\n    });\n\n    return this;\n  }\n\n  getBase64Async = mime => promisify(this.getBase64, this, mime);\n\n  /**\n   * Generates a perceptual hash of the image <https://en.wikipedia.org/wiki/Perceptual_hashing>. And pads the string. Can configure base.\n   * @param {number} base (optional) a number between 2 and 64 representing the base for the hash (e.g. 2 is binary, 10 is decimal, 16 is hex, 64 is base 64). Defaults to 64.\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {string} a string representing the hash\n   */\n  hash(base, cb) {\n    base = base || 64;\n\n    if (typeof base === 'function') {\n      cb = base;\n      base = 64;\n    }\n\n    if (typeof base !== 'number') {\n      return throwError.call(this, 'base must be a number', cb);\n    }\n\n    if (base < 2 || base > 64) {\n      return throwError.call(\n        this,\n        'base must be a number between 2 and 64',\n        cb\n      );\n    }\n\n    let hash = this.pHash();\n    hash = anyBase(anyBase.BIN, alphabet.slice(0, base))(hash);\n\n    while (hash.length < maxHashLength[base]) {\n      hash = '0' + hash; // pad out with leading zeros\n    }\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, hash);\n    }\n\n    return hash;\n  }\n\n  /**\n   * Calculates the perceptual hash\n   * @returns {number} the perceptual hash\n   */\n  pHash() {\n    const pHash = new ImagePHash();\n    return pHash.getHash(this);\n  }\n\n  /**\n   * Calculates the hamming distance of the current image and a hash based on their perceptual hash\n   * @param {hash} compareHash hash to compare to\n   * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical\n   */\n  distanceFromHash(compareHash) {\n    const pHash = new ImagePHash();\n    const currentHash = pHash.getHash(this);\n\n    return pHash.distance(currentHash, compareHash);\n  }\n\n  /**\n   * Converts the image to a buffer\n   * @param {string} mime the mime type of the image buffer to be created\n   * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n   * @returns {Jimp} this for chaining of methods\n   */\n  getBuffer = getBuffer;\n\n  getBufferAsync = getBufferAsync;\n\n  /**\n   * Returns the offset of a pixel in the bitmap buffer\n   * @param {number} x the x coordinate\n   * @param {number} y the y coordinate\n   * @param {string} edgeHandling (optional) define how to sum pixels from outside the border\n   * @param {number} cb (optional) a callback for when complete\n   * @returns {number} the index of the pixel or -1 if not found\n   */\n  getPixelIndex(x, y, edgeHandling, cb) {\n    let xi;\n    let yi;\n\n    if (typeof edgeHandling === 'function' && typeof cb === 'undefined') {\n      cb = edgeHandling;\n      edgeHandling = null;\n    }\n\n    if (!edgeHandling) {\n      edgeHandling = Jimp.EDGE_EXTEND;\n    }\n\n    if (typeof x !== 'number' || typeof y !== 'number') {\n      return throwError.call(this, 'x and y must be numbers', cb);\n    }\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n    xi = x;\n    yi = y;\n\n    if (edgeHandling === Jimp.EDGE_EXTEND) {\n      if (x < 0) xi = 0;\n      if (x >= this.bitmap.width) xi = this.bitmap.width - 1;\n      if (y < 0) yi = 0;\n      if (y >= this.bitmap.height) yi = this.bitmap.height - 1;\n    }\n\n    if (edgeHandling === Jimp.EDGE_WRAP) {\n      if (x < 0) {\n        xi = this.bitmap.width + x;\n      }\n\n      if (x >= this.bitmap.width) {\n        xi = x % this.bitmap.width;\n      }\n\n      if (y < 0) {\n        xi = this.bitmap.height + y;\n      }\n\n      if (y >= this.bitmap.height) {\n        yi = y % this.bitmap.height;\n      }\n    }\n\n    let i = (this.bitmap.width * yi + xi) << 2;\n\n    // if out of bounds index is -1\n    if (xi < 0 || xi >= this.bitmap.width) {\n      i = -1;\n    }\n\n    if (yi < 0 || yi >= this.bitmap.height) {\n      i = -1;\n    }\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, i);\n    }\n\n    return i;\n  }\n\n  /**\n   * Returns the hex colour value of a pixel\n   * @param {number} x the x coordinate\n   * @param {number} y the y coordinate\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {number} the color of the pixel\n   */\n  getPixelColor(x, y, cb) {\n    if (typeof x !== 'number' || typeof y !== 'number')\n      return throwError.call(this, 'x and y must be numbers', cb);\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n\n    const idx = this.getPixelIndex(x, y);\n    const hex = this.bitmap.data.readUInt32BE(idx);\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, hex);\n    }\n\n    return hex;\n  }\n\n  getPixelColour = this.getPixelColor;\n\n  /**\n   * Returns the hex colour value of a pixel\n   * @param {number} hex color to set\n   * @param {number} x the x coordinate\n   * @param {number} y the y coordinate\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {number} the index of the pixel or -1 if not found\n   */\n  setPixelColor(hex, x, y, cb) {\n    if (\n      typeof hex !== 'number' ||\n      typeof x !== 'number' ||\n      typeof y !== 'number'\n    )\n      return throwError.call(this, 'hex, x and y must be numbers', cb);\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n\n    const idx = this.getPixelIndex(x, y);\n    this.bitmap.data.writeUInt32BE(hex, idx);\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  }\n\n  setPixelColour = this.setPixelColor;\n\n  /**\n   * Determine if the image contains opaque pixels.\n   * @return {boolean} hasAlpha whether the image contains opaque pixels\n   */\n  hasAlpha() {\n    for (let yIndex = 0; yIndex < this.bitmap.height; yIndex++) {\n      for (let xIndex = 0; xIndex < this.bitmap.width; xIndex++) {\n        const idx = (this.bitmap.width * yIndex + xIndex) << 2;\n        const alpha = this.bitmap.data[idx + 3];\n\n        if (alpha !== 0xff) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Iterate scan through a region of the bitmap\n   * @param {number} x the x coordinate to begin the scan at\n   * @param {number} y the y coordinate to begin the scan at\n   * @param w the width of the scan region\n   * @param h the height of the scan region\n   * @returns {IterableIterator<{x: number, y: number, idx: number, image: Jimp}>}\n   */\n  scanIterator(x, y, w, h) {\n    if (typeof x !== 'number' || typeof y !== 'number') {\n      return throwError.call(this, 'x and y must be numbers');\n    }\n\n    if (typeof w !== 'number' || typeof h !== 'number') {\n      return throwError.call(this, 'w and h must be numbers');\n    }\n\n    return scanIterator(this, x, y, w, h);\n  }\n}\n\nexport function addConstants(constants, jimpInstance = Jimp) {\n  Object.entries(constants).forEach(([name, value]) => {\n    jimpInstance[name] = value;\n  });\n}\n\nexport function addJimpMethods(methods, jimpInstance = Jimp) {\n  Object.entries(methods).forEach(([name, value]) => {\n    jimpInstance.prototype[name] = value;\n  });\n}\n\naddConstants(constants);\naddJimpMethods({ composite });\n\nJimp.__extraConstructors = [];\n\n/**\n * Allow client libs to add new ways to build a Jimp object.\n * @param {string} name identify the extra constructor.\n * @param {function} test a function that returns true when it accepts the arguments passed to the main constructor.\n * @param {function} run where the magic happens.\n */\nJimp.appendConstructorOption = function(name, test, run) {\n  Jimp.__extraConstructors.push({ name, test, run });\n};\n\n/**\n * Read an image from a file or a Buffer. Takes the same args as the constructor\n * @returns {Promise} a promise\n */\nJimp.read = function(...args) {\n  return new Promise((resolve, reject) => {\n    new Jimp(...args, (err, image) => {\n      if (err) reject(err);\n      else resolve(image);\n    });\n  });\n};\n\nJimp.create = Jimp.read;\n\n/**\n * A static helper method that converts RGBA values to a single integer value\n * @param {number} r the red value (0-255)\n * @param {number} g the green value (0-255)\n * @param {number} b the blue value (0-255)\n * @param {number} a the alpha value (0-255)\n * @param {function(Error, Jimp)} cb (optional) A callback for when complete\n * @returns {number} an single integer colour value\n */\nJimp.rgbaToInt = function(r, g, b, a, cb) {\n  if (\n    typeof r !== 'number' ||\n    typeof g !== 'number' ||\n    typeof b !== 'number' ||\n    typeof a !== 'number'\n  ) {\n    return throwError.call(this, 'r, g, b and a must be numbers', cb);\n  }\n\n  if (r < 0 || r > 255) {\n    return throwError.call(this, 'r must be between 0 and 255', cb);\n  }\n\n  if (g < 0 || g > 255) {\n    throwError.call(this, 'g must be between 0 and 255', cb);\n  }\n\n  if (b < 0 || b > 255) {\n    return throwError.call(this, 'b must be between 0 and 255', cb);\n  }\n\n  if (a < 0 || a > 255) {\n    return throwError.call(this, 'a must be between 0 and 255', cb);\n  }\n\n  r = Math.round(r);\n  b = Math.round(b);\n  g = Math.round(g);\n  a = Math.round(a);\n\n  const i =\n    r * Math.pow(256, 3) +\n    g * Math.pow(256, 2) +\n    b * Math.pow(256, 1) +\n    a * Math.pow(256, 0);\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, i);\n  }\n\n  return i;\n};\n\n/**\n * A static helper method that converts RGBA values to a single integer value\n * @param {number} i a single integer value representing an RGBA colour (e.g. 0xFF0000FF for red)\n * @param {function(Error, Jimp)} cb (optional) A callback for when complete\n * @returns {object} an object with the properties r, g, b and a representing RGBA values\n */\nJimp.intToRGBA = function(i, cb) {\n  if (typeof i !== 'number') {\n    return throwError.call(this, 'i must be a number', cb);\n  }\n\n  const rgba = {};\n\n  rgba.r = Math.floor(i / Math.pow(256, 3));\n  rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));\n  rgba.b = Math.floor(\n    (i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) /\n      Math.pow(256, 1)\n  );\n  rgba.a = Math.floor(\n    (i -\n      rgba.r * Math.pow(256, 3) -\n      rgba.g * Math.pow(256, 2) -\n      rgba.b * Math.pow(256, 1)) /\n      Math.pow(256, 0)\n  );\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, rgba);\n  }\n\n  return rgba;\n};\n\n/**\n * Converts a css color (Hex, 8-digit (RGBA) Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to a hex number\n * @param {string} cssColor a number\n * @returns {number} a hex number representing a color\n */\nJimp.cssColorToHex = function(cssColor) {\n  cssColor = cssColor || 0; // 0, null, undefined, NaN\n\n  if (typeof cssColor === 'number') return Number(cssColor);\n\n  return parseInt(tinyColor(cssColor).toHex8(), 16);\n};\n\n/**\n * Limits a number to between 0 or 255\n * @param {number} n a number\n * @returns {number} the number limited to between 0 or 255\n */\nJimp.limit255 = function(n) {\n  n = Math.max(n, 0);\n  n = Math.min(n, 255);\n\n  return n;\n};\n\n/**\n * Diffs two images and returns\n * @param {Jimp} img1 a Jimp image to compare\n * @param {Jimp} img2 a Jimp image to compare\n * @param {number} threshold (optional) a number, 0 to 1, the smaller the value the more sensitive the comparison (default: 0.1)\n * @returns {object} an object { percent: percent similar, diff: a Jimp image highlighting differences }\n */\nJimp.diff = function(img1, img2, threshold = 0.1) {\n  if (!(img1 instanceof Jimp) || !(img2 instanceof Jimp))\n    return throwError.call(this, 'img1 and img2 must be an Jimp images');\n\n  const bmp1 = img1.bitmap;\n  const bmp2 = img2.bitmap;\n\n  if (bmp1.width !== bmp2.width || bmp1.height !== bmp2.height) {\n    if (bmp1.width * bmp1.height > bmp2.width * bmp2.height) {\n      // img1 is bigger\n      img1 = img1.cloneQuiet().resize(bmp2.width, bmp2.height);\n    } else {\n      // img2 is bigger (or they are the same in area)\n      img2 = img2.cloneQuiet().resize(bmp1.width, bmp1.height);\n    }\n  }\n\n  if (typeof threshold !== 'number' || threshold < 0 || threshold > 1) {\n    return throwError.call(this, 'threshold must be a number between 0 and 1');\n  }\n\n  const diff = new Jimp(bmp1.width, bmp1.height, 0xffffffff);\n\n  const numDiffPixels = pixelMatch(\n    bmp1.data,\n    bmp2.data,\n    diff.bitmap.data,\n    diff.bitmap.width,\n    diff.bitmap.height,\n    { threshold }\n  );\n\n  return {\n    percent: numDiffPixels / (diff.bitmap.width * diff.bitmap.height),\n    image: diff\n  };\n};\n\n/**\n * Calculates the hamming distance of two images based on their perceptual hash\n * @param {Jimp} img1 a Jimp image to compare\n * @param {Jimp} img2 a Jimp image to compare\n * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical\n */\nJimp.distance = function(img1, img2) {\n  const phash = new ImagePHash();\n  const hash1 = phash.getHash(img1);\n  const hash2 = phash.getHash(img2);\n\n  return phash.distance(hash1, hash2);\n};\n\n/**\n * Calculates the hamming distance of two images based on their perceptual hash\n * @param {hash} hash1 a pHash\n * @param {hash} hash2 a pHash\n * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical\n */\nJimp.compareHashes = function(hash1, hash2) {\n  const phash = new ImagePHash();\n\n  return phash.distance(hash1, hash2);\n};\n\n/**\n * Compute color difference\n * 0 means no difference, 1 means maximum difference.\n * @param {number} rgba1:    first color to compare.\n * @param {number} rgba2:    second color to compare.\n * Both parameters must be an color object {r:val, g:val, b:val, a:val}\n * Where `a` is optional and `val` is an integer between 0 and 255.\n * @returns {number} float between 0 and 1.\n */\nJimp.colorDiff = function(rgba1, rgba2) {\n  const pow = n => Math.pow(n, 2);\n  const { max } = Math;\n  const maxVal = 255 * 255 * 3;\n\n  if (rgba1.a !== 0 && !rgba1.a) {\n    rgba1.a = 255;\n  }\n\n  if (rgba2.a !== 0 && !rgba2.a) {\n    rgba2.a = 255;\n  }\n\n  return (\n    (max(pow(rgba1.r - rgba2.r), pow(rgba1.r - rgba2.r - rgba1.a + rgba2.a)) +\n      max(pow(rgba1.g - rgba2.g), pow(rgba1.g - rgba2.g - rgba1.a + rgba2.a)) +\n      max(pow(rgba1.b - rgba2.b), pow(rgba1.b - rgba2.b - rgba1.a + rgba2.a))) /\n    maxVal\n  );\n};\n\n/**\n * Helper to create Jimp methods that emit events before and after its execution.\n * @param {string} methodName   The name to be appended to Jimp prototype.\n * @param {string} evName       The event name to be called.\n *                     It will be prefixed by `before-` and emitted when on method call.\n *                     It will be appended by `ed` and emitted after the method run.\n * @param {function} method       A function implementing the method itself.\n * It will also create a quiet version that will not emit events, to not\n * mess the user code with many `changed` event calls. You can call with\n * `methodName + \"Quiet\"`.\n *\n * The emitted event comes with a object parameter to the listener with the\n * `methodName` as one attribute.\n */\nexport function jimpEvMethod(methodName, evName, method) {\n  const evNameBefore = 'before-' + evName;\n  const evNameAfter = evName.replace(/e$/, '') + 'ed';\n\n  Jimp.prototype[methodName] = function(...args) {\n    let wrappedCb;\n    const cb = args[method.length - 1];\n    const jimpInstance = this;\n\n    if (typeof cb === 'function') {\n      wrappedCb = function(...args) {\n        const [err, data] = args;\n\n        if (err) {\n          jimpInstance.emitError(methodName, err);\n        } else {\n          jimpInstance.emitMulti(methodName, evNameAfter, {\n            [methodName]: data\n          });\n        }\n\n        cb.apply(this, args);\n      };\n\n      args[args.length - 1] = wrappedCb;\n    } else {\n      wrappedCb = false;\n    }\n\n    this.emitMulti(methodName, evNameBefore);\n\n    let result;\n\n    try {\n      result = method.apply(this, args);\n\n      if (!wrappedCb) {\n        this.emitMulti(methodName, evNameAfter, {\n          [methodName]: result\n        });\n      }\n    } catch (error) {\n      error.methodName = methodName;\n      this.emitError(methodName, error);\n    }\n\n    return result;\n  };\n\n  Jimp.prototype[methodName + 'Quiet'] = method;\n}\n\n/**\n * Creates a new image that is a clone of this one.\n * @param {function(Error, Jimp)} cb (optional) A callback for when complete\n * @returns the new image\n */\njimpEvMethod('clone', 'clone', function(cb) {\n  const clone = new Jimp(this);\n\n  if (isNodePattern(cb)) {\n    cb.call(clone, null, clone);\n  }\n\n  return clone;\n});\n\n/**\n * Simplify jimpEvMethod call for the common `change` evName.\n * @param {string} methodName name of the method\n * @param {function} method to watch changes for\n */\nexport function jimpEvChange(methodName, method) {\n  jimpEvMethod(methodName, 'change', method);\n}\n\n/**\n * Sets the type of the image (RGB or RGBA) when saving as PNG format (default is RGBA)\n * @param b A Boolean, true to use RGBA or false to use RGB\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\njimpEvChange('background', function(hex, cb) {\n  if (typeof hex !== 'number') {\n    return throwError.call(this, 'hex must be a hexadecimal rgba value', cb);\n  }\n\n  this._background = hex;\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, this);\n  }\n\n  return this;\n});\n\n/**\n * Scans through a region of the bitmap, calling a function for each pixel.\n * @param {number} x the x coordinate to begin the scan at\n * @param {number} y the y coordinate to begin the scan at\n * @param w the width of the scan region\n * @param h the height of the scan region\n * @param f a function to call on even pixel; the (x, y) position of the pixel\n * and the index of the pixel in the bitmap buffer are passed to the function\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\njimpEvChange('scan', function(x, y, w, h, f, cb) {\n  if (typeof x !== 'number' || typeof y !== 'number') {\n    return throwError.call(this, 'x and y must be numbers', cb);\n  }\n\n  if (typeof w !== 'number' || typeof h !== 'number') {\n    return throwError.call(this, 'w and h must be numbers', cb);\n  }\n\n  if (typeof f !== 'function') {\n    return throwError.call(this, 'f must be a function', cb);\n  }\n\n  const result = scan(this, x, y, w, h, f);\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, result);\n  }\n\n  return result;\n});\n\nif (process.env.ENVIRONMENT === 'BROWSER') {\n  // For use in a web browser or web worker\n  /* global self */\n  let gl;\n\n  if (typeof window !== 'undefined' && typeof window === 'object') {\n    gl = window;\n  }\n\n  if (typeof self !== 'undefined' && typeof self === 'object') {\n    gl = self;\n  }\n\n  gl.Jimp = Jimp;\n  gl.Buffer = Buffer;\n}\n\nexport { addType } from './utils/mime';\n\nexport default Jimp;\n"]},"metadata":{},"sourceType":"script"}