{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/* global XMLHttpRequest */\n\n\nif (process.browser || process.env.ENVIRONMENT === 'BROWSER' || typeof process.versions.electron !== 'undefined' && process.type === 'renderer' && typeof XMLHttpRequest === 'function') {\n  // If we run into a browser or the electron renderer process,\n  // use XHR method instead of Request node module.\n  module.exports = function (options, cb) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', options.url, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.addEventListener('load', function () {\n      if (xhr.status < 400) {\n        try {\n          var data = Buffer.from(this.response);\n          cb(null, xhr, data);\n        } catch (error) {\n          return cb(new Error('Response is not a buffer for url ' + options.url + '. Error: ' + error.message));\n        }\n      } else {\n        cb(new Error('HTTP Status ' + xhr.status + ' for url ' + options.url));\n      }\n    });\n    xhr.addEventListener('error', function (e) {\n      cb(e);\n    });\n    xhr.send();\n  };\n} else {\n  module.exports = function (_ref, cb) {\n    var options = (0, _extends2[\"default\"])({}, _ref);\n\n    var p = require('phin');\n\n    p(_objectSpread({\n      compression: true\n    }, options), function (err, res) {\n      if (err === null) {\n        cb(null, res, res.body);\n      } else {\n        cb(err);\n      }\n    });\n  };\n}","map":{"version":3,"sources":["../src/request.js"],"names":["process","module","xhr","options","data","Buffer","cb","error","p","require","compression","err","res"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;AAEA,IACEA,OAAO,CAAPA,OAAAA,IACAA,OAAO,CAAPA,GAAAA,CAAAA,WAAAA,KADAA,SAAAA,IAEC,OAAOA,OAAO,CAAPA,QAAAA,CAAP,QAAA,KAAA,WAAA,IACCA,OAAO,CAAPA,IAAAA,KADD,UAAA,IAEC,OAAA,cAAA,KALJ,UAAA,EAME;AACA;AACA;AAEAC,EAAAA,MAAM,CAANA,OAAAA,GAAiB,UAAA,OAAA,EAAA,EAAA,EAAsB;AACrC,QAAMC,GAAG,GAAG,IAAZ,cAAY,EAAZ;AACAA,IAAAA,GAAG,CAAHA,IAAAA,CAAAA,KAAAA,EAAgBC,OAAO,CAAvBD,GAAAA,EAAAA,IAAAA;AACAA,IAAAA,GAAG,CAAHA,YAAAA,GAAAA,aAAAA;AACAA,IAAAA,GAAG,CAAHA,gBAAAA,CAAAA,MAAAA,EAA6B,YAAW;AACtC,UAAIA,GAAG,CAAHA,MAAAA,GAAJ,GAAA,EAAsB;AACpB,YAAI;AACF,cAAME,IAAI,GAAGC,MAAM,CAANA,IAAAA,CAAY,KAAzB,QAAaA,CAAb;AACAC,UAAAA,EAAE,CAAA,IAAA,EAAA,GAAA,EAAFA,IAAE,CAAFA;AAFF,SAAA,CAGE,OAAA,KAAA,EAAc;AACd,iBAAOA,EAAE,CACP,IAAA,KAAA,CACE,sCACEH,OAAO,CADT,GAAA,GAAA,WAAA,GAGEI,KAAK,CALX,OACE,CADO,CAAT;AAQD;AAbH,OAAA,MAcO;AACLD,QAAAA,EAAE,CAAC,IAAA,KAAA,CAAU,iBAAiBJ,GAAG,CAApB,MAAA,GAAA,WAAA,GAA4CC,OAAO,CAAhEG,GAAG,CAAD,CAAFA;AACD;AAjBHJ,KAAAA;AAmBAA,IAAAA,GAAG,CAAHA,gBAAAA,CAAAA,OAAAA,EAA8B,UAAA,CAAA,EAAK;AACjCI,MAAAA,EAAE,CAAFA,CAAE,CAAFA;AADFJ,KAAAA;AAGAA,IAAAA,GAAG,CAAHA,IAAAA;AA1BFD,GAAAA;AAVF,CAAA,MAsCO;AACLA,EAAAA,MAAM,CAANA,OAAAA,GAAiB,UAAA,IAAA,EAAA,EAAA,EAA6B;AAAA,QAAfE,OAAe,GAAA,CAAA,GAAA,SAAA,CAAA,SAAA,CAAA,EAAA,EAAA,EAAA,IAAA,CAAA;;AAC5C,QAAMK,CAAC,GAAGC,OAAO,CAAjB,MAAiB,CAAjB;;AAEAD,IAAAA,CAAC,CAAA,aAAA,CAAA;AAAGE,MAAAA,WAAW,EAAE;AAAhB,KAAA,EAAA,OAAA,CAAA,EAAoC,UAAA,GAAA,EAAA,GAAA,EAAc;AACjD,UAAIC,GAAG,KAAP,IAAA,EAAkB;AAChBL,QAAAA,EAAE,CAAA,IAAA,EAAA,GAAA,EAAYM,GAAG,CAAjBN,IAAE,CAAFA;AADF,OAAA,MAEO;AACLA,QAAAA,EAAE,CAAFA,GAAE,CAAFA;AACD;AALHE,KAAC,CAADA;AAHFP,GAAAA;AAWD","sourcesContent":["/* global XMLHttpRequest */\n\nif (\n  process.browser ||\n  process.env.ENVIRONMENT === 'BROWSER' ||\n  (typeof process.versions.electron !== 'undefined' &&\n    process.type === 'renderer' &&\n    typeof XMLHttpRequest === 'function')\n) {\n  // If we run into a browser or the electron renderer process,\n  // use XHR method instead of Request node module.\n\n  module.exports = function(options, cb) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', options.url, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.addEventListener('load', function() {\n      if (xhr.status < 400) {\n        try {\n          const data = Buffer.from(this.response);\n          cb(null, xhr, data);\n        } catch (error) {\n          return cb(\n            new Error(\n              'Response is not a buffer for url ' +\n                options.url +\n                '. Error: ' +\n                error.message\n            )\n          );\n        }\n      } else {\n        cb(new Error('HTTP Status ' + xhr.status + ' for url ' + options.url));\n      }\n    });\n    xhr.addEventListener('error', e => {\n      cb(e);\n    });\n    xhr.send();\n  };\n} else {\n  module.exports = function({ ...options }, cb) {\n    const p = require('phin');\n\n    p({ compression: true, ...options }, (err, res) => {\n      if (err === null) {\n        cb(null, res, res.body);\n      } else {\n        cb(err);\n      }\n    });\n  };\n}\n"]},"metadata":{},"sourceType":"script"}