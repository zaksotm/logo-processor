{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _utils = require(\"@jimp/utils\");\n\nvar _default = function _default() {\n  return {\n    /**\n     * Uniformly scales the image by a factor.\n     * @param {number} f the factor to scale the image by\n     * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp} this for chaining of methods\n     */\n    scale: function scale(f, mode, cb) {\n      if (typeof f !== 'number') {\n        return _utils.throwError.call(this, 'f must be a number', cb);\n      }\n\n      if (f < 0) {\n        return _utils.throwError.call(this, 'f must be a positive number', cb);\n      }\n\n      if (typeof mode === 'function' && typeof cb === 'undefined') {\n        cb = mode;\n        mode = null;\n      }\n\n      var w = this.bitmap.width * f;\n      var h = this.bitmap.height * f;\n      this.resize(w, h, mode);\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    },\n\n    /**\n     * Scale the image to the largest size that fits inside the rectangle that has the given width and height.\n     * @param {number} w the width to resize the image to\n     * @param {number} h the height to resize the image to\n     * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp} this for chaining of methods\n     */\n    scaleToFit: function scaleToFit(w, h, mode, cb) {\n      if (typeof w !== 'number' || typeof h !== 'number') {\n        return _utils.throwError.call(this, 'w and h must be numbers', cb);\n      }\n\n      if (typeof mode === 'function' && typeof cb === 'undefined') {\n        cb = mode;\n        mode = null;\n      }\n\n      var f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width;\n      this.scale(f, mode);\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    }\n  };\n};\n\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../src/index.js"],"names":["scale","throwError","f","cb","mode","w","h","scaleToFit"],"mappings":";;;;;;;AAAA,IAAA,MAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;eAEe,SAAA,QAAA,GAAA;AAAA,SAAO;AACpB;;;;;;;AAOAA,IAAAA,KARoB,EAAA,SAAA,KAAA,CAAA,CAAA,EAAA,IAAA,EAAA,EAAA,EAQD;AACjB,UAAI,OAAA,CAAA,KAAJ,QAAA,EAA2B;AACzB,eAAOC,MAAAA,CAAAA,UAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAAA,oBAAAA,EAAP,EAAOA,CAAP;AACD;;AAED,UAAIC,CAAC,GAAL,CAAA,EAAW;AACT,eAAOD,MAAAA,CAAAA,UAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAAA,6BAAAA,EAAP,EAAOA,CAAP;AACD;;AAED,UAAI,OAAA,IAAA,KAAA,UAAA,IAA8B,OAAA,EAAA,KAAlC,WAAA,EAA6D;AAC3DE,QAAAA,EAAE,GAAFA,IAAAA;AACAC,QAAAA,IAAI,GAAJA,IAAAA;AACD;;AAED,UAAMC,CAAC,GAAG,KAAA,MAAA,CAAA,KAAA,GAAV,CAAA;AACA,UAAMC,CAAC,GAAG,KAAA,MAAA,CAAA,MAAA,GAAV,CAAA;AACA,WAAA,MAAA,CAAA,CAAA,EAAA,CAAA,EAAA,IAAA;;AAEA,UAAI,CAAA,GAAA,MAAA,CAAA,aAAA,EAAJ,EAAI,CAAJ,EAAuB;AACrBH,QAAAA,EAAE,CAAFA,IAAAA,CAAAA,IAAAA,EAAAA,IAAAA,EAAAA,IAAAA;AACD;;AAED,aAAA,IAAA;AA9BkB,KAAA;;AAiCpB;;;;;;;;AAQAI,IAAAA,UAzCoB,EAAA,SAAA,UAAA,CAAA,CAAA,EAAA,CAAA,EAAA,IAAA,EAAA,EAAA,EAyCO;AACzB,UAAI,OAAA,CAAA,KAAA,QAAA,IAAyB,OAAA,CAAA,KAA7B,QAAA,EAAoD;AAClD,eAAON,MAAAA,CAAAA,UAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAAA,yBAAAA,EAAP,EAAOA,CAAP;AACD;;AAED,UAAI,OAAA,IAAA,KAAA,UAAA,IAA8B,OAAA,EAAA,KAAlC,WAAA,EAA6D;AAC3DE,QAAAA,EAAE,GAAFA,IAAAA;AACAC,QAAAA,IAAI,GAAJA,IAAAA;AACD;;AAED,UAAMF,CAAC,GACLG,CAAC,GAADA,CAAAA,GAAQ,KAAA,MAAA,CAAA,KAAA,GAAoB,KAAA,MAAA,CAA5BA,MAAAA,GACIC,CAAC,GAAG,KAAA,MAAA,CADRD,MAAAA,GAEIA,CAAC,GAAG,KAAA,MAAA,CAHV,KAAA;AAIA,WAAA,KAAA,CAAA,CAAA,EAAA,IAAA;;AAEA,UAAI,CAAA,GAAA,MAAA,CAAA,aAAA,EAAJ,EAAI,CAAJ,EAAuB;AACrBF,QAAAA,EAAE,CAAFA,IAAAA,CAAAA,IAAAA,EAAAA,IAAAA,EAAAA,IAAAA;AACD;;AAED,aAAA,IAAA;AACD;AA9DmB,GAAP","sourcesContent":["import { isNodePattern, throwError } from '@jimp/utils';\n\nexport default () => ({\n  /**\n   * Uniformly scales the image by a factor.\n   * @param {number} f the factor to scale the image by\n   * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  scale(f, mode, cb) {\n    if (typeof f !== 'number') {\n      return throwError.call(this, 'f must be a number', cb);\n    }\n\n    if (f < 0) {\n      return throwError.call(this, 'f must be a positive number', cb);\n    }\n\n    if (typeof mode === 'function' && typeof cb === 'undefined') {\n      cb = mode;\n      mode = null;\n    }\n\n    const w = this.bitmap.width * f;\n    const h = this.bitmap.height * f;\n    this.resize(w, h, mode);\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Scale the image to the largest size that fits inside the rectangle that has the given width and height.\n   * @param {number} w the width to resize the image to\n   * @param {number} h the height to resize the image to\n   * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  scaleToFit(w, h, mode, cb) {\n    if (typeof w !== 'number' || typeof h !== 'number') {\n      return throwError.call(this, 'w and h must be numbers', cb);\n    }\n\n    if (typeof mode === 'function' && typeof cb === 'undefined') {\n      cb = mode;\n      mode = null;\n    }\n\n    const f =\n      w / h > this.bitmap.width / this.bitmap.height\n        ? h / this.bitmap.height\n        : w / this.bitmap.width;\n    this.scale(f, mode);\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  }\n});\n"]},"metadata":{},"sourceType":"script"}