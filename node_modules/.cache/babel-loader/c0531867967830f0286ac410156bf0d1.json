{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = pluginCrop;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _utils = require(\"@jimp/utils\");\n/* eslint-disable no-labels */\n\n\nfunction pluginCrop(event) {\n  /**\n   * Crops the image at a given point to a give size\n   * @param {number} x the x coordinate to crop form\n   * @param {number} y the y coordinate to crop form\n   * @param w the width of the crop region\n   * @param h the height of the crop region\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  event('crop', function (x, y, w, h, cb) {\n    if (typeof x !== 'number' || typeof y !== 'number') return _utils.throwError.call(this, 'x and y must be numbers', cb);\n    if (typeof w !== 'number' || typeof h !== 'number') return _utils.throwError.call(this, 'w and h must be numbers', cb); // round input\n\n    x = Math.round(x);\n    y = Math.round(y);\n    w = Math.round(w);\n    h = Math.round(h);\n\n    if (x === 0 && w === this.bitmap.width) {\n      // shortcut\n      var start = w * y + x << 2;\n      var end = start + h * w << 2;\n      this.bitmap.data = this.bitmap.data.slice(start, end);\n    } else {\n      var bitmap = Buffer.allocUnsafe(w * h * 4);\n      var offset = 0;\n      this.scanQuiet(x, y, w, h, function (x, y, idx) {\n        var data = this.bitmap.data.readUInt32BE(idx, true);\n        bitmap.writeUInt32BE(data, offset, true);\n        offset += 4;\n      });\n      this.bitmap.data = bitmap;\n    }\n\n    this.bitmap.width = w;\n    this.bitmap.height = h;\n\n    if ((0, _utils.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  });\n  return {\n    \"class\": {\n      /**\n       * Autocrop same color borders from this image\n       * @param {number} tolerance (optional): a percent value of tolerance for pixels color difference (default: 0.0002%)\n       * @param {boolean} cropOnlyFrames (optional): flag to crop only real frames: all 4 sides of the image must have some border (default: true)\n       * @param {function(Error, Jimp)} cb (optional): a callback for when complete (default: no callback)\n       * @returns {Jimp} this for chaining of methods\n       */\n      autocrop: function autocrop() {\n        var w = this.bitmap.width;\n        var h = this.bitmap.height;\n        var minPixelsPerSide = 1; // to avoid cropping completely the image, resulting in an invalid 0 sized image\n\n        var cb; // callback\n\n        var leaveBorder = 0; // Amount of pixels in border to leave\n\n        var tolerance = 0.0002; // percent of color difference tolerance (default value)\n\n        var cropOnlyFrames = true; // flag to force cropping only if the image has a real \"frame\"\n        // i.e. all 4 sides have some border (default value)\n\n        var cropSymmetric = false; // flag to force cropping top be symmetric.\n        // i.e. north and south / east and west are cropped by the same value\n        // parse arguments\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        for (var a = 0, len = args.length; a < len; a++) {\n          if (typeof args[a] === 'number') {\n            // tolerance value passed\n            tolerance = args[a];\n          }\n\n          if (typeof args[a] === 'boolean') {\n            // cropOnlyFrames value passed\n            cropOnlyFrames = args[a];\n          }\n\n          if (typeof args[a] === 'function') {\n            // callback value passed\n            cb = args[a];\n          }\n\n          if ((0, _typeof2[\"default\"])(args[a]) === 'object') {\n            // config object passed\n            var config = args[a];\n\n            if (typeof config.tolerance !== 'undefined') {\n              tolerance = config.tolerance;\n            }\n\n            if (typeof config.cropOnlyFrames !== 'undefined') {\n              cropOnlyFrames = config.cropOnlyFrames;\n            }\n\n            if (typeof config.cropSymmetric !== 'undefined') {\n              cropSymmetric = config.cropSymmetric;\n            }\n\n            if (typeof config.leaveBorder !== 'undefined') {\n              leaveBorder = config.leaveBorder;\n            }\n          }\n        }\n        /**\n         * All borders must be of the same color as the top left pixel, to be cropped.\n         * It should be possible to crop borders each with a different color,\n         * but since there are many ways for corners to intersect, it would\n         * introduce unnecessary complexity to the algorithm.\n         */\n        // scan each side for same color borders\n\n\n        var colorTarget = this.getPixelColor(0, 0); // top left pixel color is the target color\n\n        var rgba1 = this.constructor.intToRGBA(colorTarget); // for north and east sides\n\n        var northPixelsToCrop = 0;\n        var eastPixelsToCrop = 0;\n        var southPixelsToCrop = 0;\n        var westPixelsToCrop = 0; // north side (scan rows from north to south)\n\n        colorTarget = this.getPixelColor(0, 0);\n\n        north: for (var y = 0; y < h - minPixelsPerSide; y++) {\n          for (var x = 0; x < w; x++) {\n            var colorXY = this.getPixelColor(x, y);\n            var rgba2 = this.constructor.intToRGBA(colorXY);\n\n            if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n              // this pixel is too distant from the first one: abort this side scan\n              break north;\n            }\n          } // this row contains all pixels with the same color: increment this side pixels to crop\n\n\n          northPixelsToCrop++;\n        } // east side (scan columns from east to west)\n\n\n        colorTarget = this.getPixelColor(w, 0);\n\n        east: for (var _x = 0; _x < w - minPixelsPerSide; _x++) {\n          for (var _y = 0 + northPixelsToCrop; _y < h; _y++) {\n            var _colorXY = this.getPixelColor(_x, _y);\n\n            var _rgba = this.constructor.intToRGBA(_colorXY);\n\n            if (this.constructor.colorDiff(rgba1, _rgba) > tolerance) {\n              // this pixel is too distant from the first one: abort this side scan\n              break east;\n            }\n          } // this column contains all pixels with the same color: increment this side pixels to crop\n\n\n          eastPixelsToCrop++;\n        } // south side (scan rows from south to north)\n\n\n        colorTarget = this.getPixelColor(0, h);\n\n        south: for (var _y2 = h - 1; _y2 >= northPixelsToCrop + minPixelsPerSide; _y2--) {\n          for (var _x2 = w - eastPixelsToCrop - 1; _x2 >= 0; _x2--) {\n            var _colorXY2 = this.getPixelColor(_x2, _y2);\n\n            var _rgba2 = this.constructor.intToRGBA(_colorXY2);\n\n            if (this.constructor.colorDiff(rgba1, _rgba2) > tolerance) {\n              // this pixel is too distant from the first one: abort this side scan\n              break south;\n            }\n          } // this row contains all pixels with the same color: increment this side pixels to crop\n\n\n          southPixelsToCrop++;\n        } // west side (scan columns from west to east)\n\n\n        colorTarget = this.getPixelColor(w, h);\n\n        west: for (var _x3 = w - 1; _x3 >= 0 + eastPixelsToCrop + minPixelsPerSide; _x3--) {\n          for (var _y3 = h - 1; _y3 >= 0 + northPixelsToCrop; _y3--) {\n            var _colorXY3 = this.getPixelColor(_x3, _y3);\n\n            var _rgba3 = this.constructor.intToRGBA(_colorXY3);\n\n            if (this.constructor.colorDiff(rgba1, _rgba3) > tolerance) {\n              // this pixel is too distant from the first one: abort this side scan\n              break west;\n            }\n          } // this column contains all pixels with the same color: increment this side pixels to crop\n\n\n          westPixelsToCrop++;\n        } // decide if a crop is needed\n\n\n        var doCrop = false; // apply leaveBorder\n\n        westPixelsToCrop -= leaveBorder;\n        eastPixelsToCrop -= leaveBorder;\n        northPixelsToCrop -= leaveBorder;\n        southPixelsToCrop -= leaveBorder;\n\n        if (cropSymmetric) {\n          var horizontal = Math.min(eastPixelsToCrop, westPixelsToCrop);\n          var vertical = Math.min(northPixelsToCrop, southPixelsToCrop);\n          westPixelsToCrop = horizontal;\n          eastPixelsToCrop = horizontal;\n          northPixelsToCrop = vertical;\n          southPixelsToCrop = vertical;\n        } // make sure that crops are >= 0\n\n\n        westPixelsToCrop = westPixelsToCrop >= 0 ? westPixelsToCrop : 0;\n        eastPixelsToCrop = eastPixelsToCrop >= 0 ? eastPixelsToCrop : 0;\n        northPixelsToCrop = northPixelsToCrop >= 0 ? northPixelsToCrop : 0;\n        southPixelsToCrop = southPixelsToCrop >= 0 ? southPixelsToCrop : 0; // safety checks\n\n        var widthOfRemainingPixels = w - (westPixelsToCrop + eastPixelsToCrop);\n        var heightOfRemainingPixels = h - (southPixelsToCrop + northPixelsToCrop);\n\n        if (cropOnlyFrames) {\n          // crop image if all sides should be cropped\n          doCrop = eastPixelsToCrop !== 0 && northPixelsToCrop !== 0 && westPixelsToCrop !== 0 && southPixelsToCrop !== 0;\n        } else {\n          // crop image if at least one side should be cropped\n          doCrop = eastPixelsToCrop !== 0 || northPixelsToCrop !== 0 || westPixelsToCrop !== 0 || southPixelsToCrop !== 0;\n        }\n\n        if (doCrop) {\n          // do the real crop\n          this.crop(eastPixelsToCrop, northPixelsToCrop, widthOfRemainingPixels, heightOfRemainingPixels);\n        }\n\n        if ((0, _utils.isNodePattern)(cb)) {\n          cb.call(this, null, this);\n        }\n\n        return this;\n      }\n    }\n  };\n}","map":{"version":3,"sources":["../src/index.js"],"names":["event","throwError","x","Math","y","w","h","start","end","bitmap","Buffer","offset","data","cb","autocrop","args","minPixelsPerSide","leaveBorder","tolerance","cropOnlyFrames","cropSymmetric","a","len","config","colorTarget","rgba1","northPixelsToCrop","eastPixelsToCrop","southPixelsToCrop","westPixelsToCrop","north","colorXY","rgba2","east","south","west","doCrop","horizontal","vertical","widthOfRemainingPixels","heightOfRemainingPixels"],"mappings":"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","sourcesContent":["/* eslint-disable no-labels */\n\nimport { throwError, isNodePattern } from '@jimp/utils';\n\nexport default function pluginCrop(event) {\n  /**\n   * Crops the image at a given point to a give size\n   * @param {number} x the x coordinate to crop form\n   * @param {number} y the y coordinate to crop form\n   * @param w the width of the crop region\n   * @param h the height of the crop region\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  event('crop', function(x, y, w, h, cb) {\n    if (typeof x !== 'number' || typeof y !== 'number')\n      return throwError.call(this, 'x and y must be numbers', cb);\n    if (typeof w !== 'number' || typeof h !== 'number')\n      return throwError.call(this, 'w and h must be numbers', cb);\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n    w = Math.round(w);\n    h = Math.round(h);\n\n    if (x === 0 && w === this.bitmap.width) {\n      // shortcut\n      const start = (w * y + x) << 2;\n      const end = (start + h * w) << 2;\n\n      this.bitmap.data = this.bitmap.data.slice(start, end);\n    } else {\n      const bitmap = Buffer.allocUnsafe(w * h * 4);\n      let offset = 0;\n\n      this.scanQuiet(x, y, w, h, function(x, y, idx) {\n        const data = this.bitmap.data.readUInt32BE(idx, true);\n        bitmap.writeUInt32BE(data, offset, true);\n        offset += 4;\n      });\n\n      this.bitmap.data = bitmap;\n    }\n\n    this.bitmap.width = w;\n    this.bitmap.height = h;\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  });\n\n  return {\n    class: {\n      /**\n       * Autocrop same color borders from this image\n       * @param {number} tolerance (optional): a percent value of tolerance for pixels color difference (default: 0.0002%)\n       * @param {boolean} cropOnlyFrames (optional): flag to crop only real frames: all 4 sides of the image must have some border (default: true)\n       * @param {function(Error, Jimp)} cb (optional): a callback for when complete (default: no callback)\n       * @returns {Jimp} this for chaining of methods\n       */\n      autocrop(...args) {\n        const w = this.bitmap.width;\n        const h = this.bitmap.height;\n        const minPixelsPerSide = 1; // to avoid cropping completely the image, resulting in an invalid 0 sized image\n\n        let cb; // callback\n        let leaveBorder = 0; // Amount of pixels in border to leave\n        let tolerance = 0.0002; // percent of color difference tolerance (default value)\n        let cropOnlyFrames = true; // flag to force cropping only if the image has a real \"frame\"\n        // i.e. all 4 sides have some border (default value)\n        let cropSymmetric = false; // flag to force cropping top be symmetric.\n        // i.e. north and south / east and west are cropped by the same value\n\n        // parse arguments\n        for (let a = 0, len = args.length; a < len; a++) {\n          if (typeof args[a] === 'number') {\n            // tolerance value passed\n            tolerance = args[a];\n          }\n\n          if (typeof args[a] === 'boolean') {\n            // cropOnlyFrames value passed\n            cropOnlyFrames = args[a];\n          }\n\n          if (typeof args[a] === 'function') {\n            // callback value passed\n            cb = args[a];\n          }\n\n          if (typeof args[a] === 'object') {\n            // config object passed\n            const config = args[a];\n\n            if (typeof config.tolerance !== 'undefined') {\n              ({ tolerance } = config);\n            }\n\n            if (typeof config.cropOnlyFrames !== 'undefined') {\n              ({ cropOnlyFrames } = config);\n            }\n\n            if (typeof config.cropSymmetric !== 'undefined') {\n              ({ cropSymmetric } = config);\n            }\n\n            if (typeof config.leaveBorder !== 'undefined') {\n              ({ leaveBorder } = config);\n            }\n          }\n        }\n\n        /**\n         * All borders must be of the same color as the top left pixel, to be cropped.\n         * It should be possible to crop borders each with a different color,\n         * but since there are many ways for corners to intersect, it would\n         * introduce unnecessary complexity to the algorithm.\n         */\n\n        // scan each side for same color borders\n        let colorTarget = this.getPixelColor(0, 0); // top left pixel color is the target color\n        const rgba1 = this.constructor.intToRGBA(colorTarget);\n\n        // for north and east sides\n        let northPixelsToCrop = 0;\n        let eastPixelsToCrop = 0;\n        let southPixelsToCrop = 0;\n        let westPixelsToCrop = 0;\n\n        // north side (scan rows from north to south)\n        colorTarget = this.getPixelColor(0, 0);\n        north: for (let y = 0; y < h - minPixelsPerSide; y++) {\n          for (let x = 0; x < w; x++) {\n            const colorXY = this.getPixelColor(x, y);\n            const rgba2 = this.constructor.intToRGBA(colorXY);\n\n            if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n              // this pixel is too distant from the first one: abort this side scan\n              break north;\n            }\n          }\n\n          // this row contains all pixels with the same color: increment this side pixels to crop\n          northPixelsToCrop++;\n        }\n\n        // east side (scan columns from east to west)\n        colorTarget = this.getPixelColor(w, 0);\n        east: for (let x = 0; x < w - minPixelsPerSide; x++) {\n          for (let y = 0 + northPixelsToCrop; y < h; y++) {\n            const colorXY = this.getPixelColor(x, y);\n            const rgba2 = this.constructor.intToRGBA(colorXY);\n\n            if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n              // this pixel is too distant from the first one: abort this side scan\n              break east;\n            }\n          }\n\n          // this column contains all pixels with the same color: increment this side pixels to crop\n          eastPixelsToCrop++;\n        }\n\n        // south side (scan rows from south to north)\n        colorTarget = this.getPixelColor(0, h);\n        south: for (\n          let y = h - 1;\n          y >= northPixelsToCrop + minPixelsPerSide;\n          y--\n        ) {\n          for (let x = w - eastPixelsToCrop - 1; x >= 0; x--) {\n            const colorXY = this.getPixelColor(x, y);\n            const rgba2 = this.constructor.intToRGBA(colorXY);\n\n            if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n              // this pixel is too distant from the first one: abort this side scan\n              break south;\n            }\n          }\n\n          // this row contains all pixels with the same color: increment this side pixels to crop\n          southPixelsToCrop++;\n        }\n\n        // west side (scan columns from west to east)\n        colorTarget = this.getPixelColor(w, h);\n        west: for (\n          let x = w - 1;\n          x >= 0 + eastPixelsToCrop + minPixelsPerSide;\n          x--\n        ) {\n          for (let y = h - 1; y >= 0 + northPixelsToCrop; y--) {\n            const colorXY = this.getPixelColor(x, y);\n            const rgba2 = this.constructor.intToRGBA(colorXY);\n\n            if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n              // this pixel is too distant from the first one: abort this side scan\n              break west;\n            }\n          }\n\n          // this column contains all pixels with the same color: increment this side pixels to crop\n          westPixelsToCrop++;\n        }\n\n        // decide if a crop is needed\n        let doCrop = false;\n\n        // apply leaveBorder\n        westPixelsToCrop -= leaveBorder;\n        eastPixelsToCrop -= leaveBorder;\n        northPixelsToCrop -= leaveBorder;\n        southPixelsToCrop -= leaveBorder;\n\n        if (cropSymmetric) {\n          const horizontal = Math.min(eastPixelsToCrop, westPixelsToCrop);\n          const vertical = Math.min(northPixelsToCrop, southPixelsToCrop);\n          westPixelsToCrop = horizontal;\n          eastPixelsToCrop = horizontal;\n          northPixelsToCrop = vertical;\n          southPixelsToCrop = vertical;\n        }\n\n        // make sure that crops are >= 0\n        westPixelsToCrop = westPixelsToCrop >= 0 ? westPixelsToCrop : 0;\n        eastPixelsToCrop = eastPixelsToCrop >= 0 ? eastPixelsToCrop : 0;\n        northPixelsToCrop = northPixelsToCrop >= 0 ? northPixelsToCrop : 0;\n        southPixelsToCrop = southPixelsToCrop >= 0 ? southPixelsToCrop : 0;\n\n        // safety checks\n        const widthOfRemainingPixels =\n          w - (westPixelsToCrop + eastPixelsToCrop);\n        const heightOfRemainingPixels =\n          h - (southPixelsToCrop + northPixelsToCrop);\n\n        if (cropOnlyFrames) {\n          // crop image if all sides should be cropped\n          doCrop =\n            eastPixelsToCrop !== 0 &&\n            northPixelsToCrop !== 0 &&\n            westPixelsToCrop !== 0 &&\n            southPixelsToCrop !== 0;\n        } else {\n          // crop image if at least one side should be cropped\n          doCrop =\n            eastPixelsToCrop !== 0 ||\n            northPixelsToCrop !== 0 ||\n            westPixelsToCrop !== 0 ||\n            southPixelsToCrop !== 0;\n        }\n\n        if (doCrop) {\n          // do the real crop\n          this.crop(\n            eastPixelsToCrop,\n            northPixelsToCrop,\n            widthOfRemainingPixels,\n            heightOfRemainingPixels\n          );\n        }\n\n        if (isNodePattern(cb)) {\n          cb.call(this, null, this);\n        }\n\n        return this;\n      }\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"script"}