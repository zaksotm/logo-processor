{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _utils = require(\"@jimp/utils\");\n/**\n * Applies a true Gaussian blur to the image (warning: this is VERY slow)\n * @param {number} r the pixel radius of the blur\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n\n\nvar _default = function _default() {\n  return {\n    gaussian: function gaussian(r, cb) {\n      // http://blog.ivank.net/fastest-gaussian-blur.html\n      if (typeof r !== 'number') {\n        return _utils.throwError.call(this, 'r must be a number', cb);\n      }\n\n      if (r < 1) {\n        return _utils.throwError.call(this, 'r must be greater than 0', cb);\n      }\n\n      var rs = Math.ceil(r * 2.57); // significant radius\n\n      var range = rs * 2 + 1;\n      var rr2 = r * r * 2;\n      var rr2pi = rr2 * Math.PI;\n      var weights = [];\n\n      for (var y = 0; y < range; y++) {\n        weights[y] = [];\n\n        for (var x = 0; x < range; x++) {\n          var dsq = Math.pow(x - rs, 2) + Math.pow(y - rs, 2);\n          weights[y][x] = Math.exp(-dsq / rr2) / rr2pi;\n        }\n      }\n\n      for (var _y = 0; _y < this.bitmap.height; _y++) {\n        for (var _x = 0; _x < this.bitmap.width; _x++) {\n          var red = 0;\n          var green = 0;\n          var blue = 0;\n          var alpha = 0;\n          var wsum = 0;\n\n          for (var iy = 0; iy < range; iy++) {\n            for (var ix = 0; ix < range; ix++) {\n              var x1 = Math.min(this.bitmap.width - 1, Math.max(0, ix + _x - rs));\n              var y1 = Math.min(this.bitmap.height - 1, Math.max(0, iy + _y - rs));\n              var weight = weights[iy][ix];\n\n              var _idx = y1 * this.bitmap.width + x1 << 2;\n\n              red += this.bitmap.data[_idx] * weight;\n              green += this.bitmap.data[_idx + 1] * weight;\n              blue += this.bitmap.data[_idx + 2] * weight;\n              alpha += this.bitmap.data[_idx + 3] * weight;\n              wsum += weight;\n            }\n\n            var idx = _y * this.bitmap.width + _x << 2;\n            this.bitmap.data[idx] = Math.round(red / wsum);\n            this.bitmap.data[idx + 1] = Math.round(green / wsum);\n            this.bitmap.data[idx + 2] = Math.round(blue / wsum);\n            this.bitmap.data[idx + 3] = Math.round(alpha / wsum);\n          }\n        }\n      }\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    }\n  };\n};\n\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../src/index.js"],"names":["gaussian","throwError","r","rs","Math","range","rr2","rr2pi","weights","y","x","dsq","red","green","blue","alpha","wsum","iy","ix","x1","y1","weight","idx","cb"],"mappings":";;;;;;;AAAA,IAAA,MAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAEA;;;;;;;;eAMe,SAAA,QAAA,GAAA;AAAA,SAAO;AACpBA,IAAAA,QADoB,EAAA,SAAA,QAAA,CAAA,CAAA,EAAA,EAAA,EACJ;AACd;AACA,UAAI,OAAA,CAAA,KAAJ,QAAA,EAA2B;AACzB,eAAOC,MAAAA,CAAAA,UAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAAA,oBAAAA,EAAP,EAAOA,CAAP;AACD;;AAED,UAAIC,CAAC,GAAL,CAAA,EAAW;AACT,eAAOD,MAAAA,CAAAA,UAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAAA,0BAAAA,EAAP,EAAOA,CAAP;AACD;;AAED,UAAME,EAAE,GAAGC,IAAI,CAAJA,IAAAA,CAAUF,CAAC,GAVR,IAUHE,CAAX,CAVc,CAUkB;;AAChC,UAAMC,KAAK,GAAGF,EAAE,GAAFA,CAAAA,GAAd,CAAA;AACA,UAAMG,GAAG,GAAGJ,CAAC,GAADA,CAAAA,GAAZ,CAAA;AACA,UAAMK,KAAK,GAAGD,GAAG,GAAGF,IAAI,CAAxB,EAAA;AAEA,UAAMI,OAAO,GAAb,EAAA;;AAEA,WAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,KAAA,EAA2BA,CAA3B,EAAA,EAAgC;AAC9BD,QAAAA,OAAO,CAAPA,CAAO,CAAPA,GAAAA,EAAAA;;AACA,aAAK,IAAIE,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,KAAA,EAA2BA,CAA3B,EAAA,EAAgC;AAC9B,cAAMC,GAAG,GAAG,IAAA,CAAA,GAAA,CAACD,CAAC,GAAF,EAAA,EAAA,CAAA,IAAA,IAAA,CAAA,GAAA,CAAiBD,CAAC,GAAlB,EAAA,EAAZ,CAAY,CAAZ;AACAD,UAAAA,OAAO,CAAPA,CAAO,CAAPA,CAAAA,CAAAA,IAAgBJ,IAAI,CAAJA,GAAAA,CAAS,CAAA,GAAA,GAATA,GAAAA,IAAhBI,KAAAA;AACD;AACF;;AAED,WAAK,IAAIC,EAAC,GAAV,CAAA,EAAgBA,EAAC,GAAG,KAAA,MAAA,CAApB,MAAA,EAAwCA,EAAxC,EAAA,EAA6C;AAC3C,aAAK,IAAIC,EAAC,GAAV,CAAA,EAAgBA,EAAC,GAAG,KAAA,MAAA,CAApB,KAAA,EAAuCA,EAAvC,EAAA,EAA4C;AAC1C,cAAIE,GAAG,GAAP,CAAA;AACA,cAAIC,KAAK,GAAT,CAAA;AACA,cAAIC,IAAI,GAAR,CAAA;AACA,cAAIC,KAAK,GAAT,CAAA;AACA,cAAIC,IAAI,GAAR,CAAA;;AAEA,eAAK,IAAIC,EAAE,GAAX,CAAA,EAAiBA,EAAE,GAAnB,KAAA,EAA6BA,EAA7B,EAAA,EAAmC;AACjC,iBAAK,IAAIC,EAAE,GAAX,CAAA,EAAiBA,EAAE,GAAnB,KAAA,EAA6BA,EAA7B,EAAA,EAAmC;AACjC,kBAAMC,EAAE,GAAGf,IAAI,CAAJA,GAAAA,CAAS,KAAA,MAAA,CAAA,KAAA,GAATA,CAAAA,EAAgCA,IAAI,CAAJA,GAAAA,CAAAA,CAAAA,EAAYc,EAAE,GAAFA,EAAAA,GAAvD,EAA2Cd,CAAhCA,CAAX;AACA,kBAAMgB,EAAE,GAAGhB,IAAI,CAAJA,GAAAA,CAAS,KAAA,MAAA,CAAA,MAAA,GAATA,CAAAA,EAAiCA,IAAI,CAAJA,GAAAA,CAAAA,CAAAA,EAAYa,EAAE,GAAFA,EAAAA,GAAxD,EAA4Cb,CAAjCA,CAAX;AACA,kBAAMiB,MAAM,GAAGb,OAAO,CAAPA,EAAO,CAAPA,CAAf,EAAeA,CAAf;;AACA,kBAAMc,IAAG,GAAIF,EAAE,GAAG,KAAA,MAAA,CAALA,KAAAA,GAAD,EAACA,IAAb,CAAA;;AAEAR,cAAAA,GAAG,IAAI,KAAA,MAAA,CAAA,IAAA,CAAA,IAAA,IAAPA,MAAAA;AACAC,cAAAA,KAAK,IAAI,KAAA,MAAA,CAAA,IAAA,CAAiBS,IAAG,GAApB,CAAA,IAATT,MAAAA;AACAC,cAAAA,IAAI,IAAI,KAAA,MAAA,CAAA,IAAA,CAAiBQ,IAAG,GAApB,CAAA,IAARR,MAAAA;AACAC,cAAAA,KAAK,IAAI,KAAA,MAAA,CAAA,IAAA,CAAiBO,IAAG,GAApB,CAAA,IAATP,MAAAA;AACAC,cAAAA,IAAI,IAAJA,MAAAA;AACD;;AAED,gBAAMM,GAAG,GAAIb,EAAC,GAAG,KAAA,MAAA,CAAJA,KAAAA,GAAD,EAACA,IAAb,CAAA;AAEA,iBAAA,MAAA,CAAA,IAAA,CAAA,GAAA,IAAwBL,IAAI,CAAJA,KAAAA,CAAWQ,GAAG,GAAtC,IAAwBR,CAAxB;AACA,iBAAA,MAAA,CAAA,IAAA,CAAiBkB,GAAG,GAApB,CAAA,IAA4BlB,IAAI,CAAJA,KAAAA,CAAWS,KAAK,GAA5C,IAA4BT,CAA5B;AACA,iBAAA,MAAA,CAAA,IAAA,CAAiBkB,GAAG,GAApB,CAAA,IAA4BlB,IAAI,CAAJA,KAAAA,CAAWU,IAAI,GAA3C,IAA4BV,CAA5B;AACA,iBAAA,MAAA,CAAA,IAAA,CAAiBkB,GAAG,GAApB,CAAA,IAA4BlB,IAAI,CAAJA,KAAAA,CAAWW,KAAK,GAA5C,IAA4BX,CAA5B;AACD;AACF;AACF;;AAED,UAAI,CAAA,GAAA,MAAA,CAAA,aAAA,EAAJ,EAAI,CAAJ,EAAuB;AACrBmB,QAAAA,EAAE,CAAFA,IAAAA,CAAAA,IAAAA,EAAAA,IAAAA,EAAAA,IAAAA;AACD;;AAED,aAAA,IAAA;AACD;AA/DmB,GAAP","sourcesContent":["import { isNodePattern, throwError } from '@jimp/utils';\n\n/**\n * Applies a true Gaussian blur to the image (warning: this is VERY slow)\n * @param {number} r the pixel radius of the blur\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport default () => ({\n  gaussian(r, cb) {\n    // http://blog.ivank.net/fastest-gaussian-blur.html\n    if (typeof r !== 'number') {\n      return throwError.call(this, 'r must be a number', cb);\n    }\n\n    if (r < 1) {\n      return throwError.call(this, 'r must be greater than 0', cb);\n    }\n\n    const rs = Math.ceil(r * 2.57); // significant radius\n    const range = rs * 2 + 1;\n    const rr2 = r * r * 2;\n    const rr2pi = rr2 * Math.PI;\n\n    const weights = [];\n\n    for (let y = 0; y < range; y++) {\n      weights[y] = [];\n      for (let x = 0; x < range; x++) {\n        const dsq = (x - rs) ** 2 + (y - rs) ** 2 ;\n        weights[y][x] = Math.exp(-dsq / rr2) / rr2pi;\n      }\n    }\n\n    for (let y = 0; y < this.bitmap.height; y++) {\n      for (let x = 0; x < this.bitmap.width; x++) {\n        let red = 0;\n        let green = 0;\n        let blue = 0;\n        let alpha = 0;\n        let wsum = 0;\n\n        for (let iy = 0; iy < range; iy++) {\n          for (let ix = 0; ix < range; ix++) {\n            const x1 = Math.min(this.bitmap.width - 1, Math.max(0, ix + x - rs ));\n            const y1 = Math.min(this.bitmap.height - 1, Math.max(0, iy + y - rs));\n            const weight = weights[iy][ix];\n            const idx = (y1 * this.bitmap.width + x1) << 2;\n\n            red += this.bitmap.data[idx] * weight;\n            green += this.bitmap.data[idx + 1] * weight;\n            blue += this.bitmap.data[idx + 2] * weight;\n            alpha += this.bitmap.data[idx + 3] * weight;\n            wsum += weight;\n          }\n\n          const idx = (y * this.bitmap.width + x) << 2;\n\n          this.bitmap.data[idx] = Math.round(red / wsum);\n          this.bitmap.data[idx + 1] = Math.round(green / wsum);\n          this.bitmap.data[idx + 2] = Math.round(blue / wsum);\n          this.bitmap.data[idx + 3] = Math.round(alpha / wsum);\n        }\n      }\n    }\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  }\n});\n"]},"metadata":{},"sourceType":"script"}