{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _utils = require(\"@jimp/utils\");\n/**\n * Get an image's histogram\n * @return {object} An object with an array of color occurrence counts for each channel (r,g,b)\n */\n\n\nfunction histogram() {\n  var histogram = {\n    r: new Array(256).fill(0),\n    g: new Array(256).fill(0),\n    b: new Array(256).fill(0)\n  };\n  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, index) {\n    histogram.r[this.bitmap.data[index + 0]]++;\n    histogram.g[this.bitmap.data[index + 1]]++;\n    histogram.b[this.bitmap.data[index + 2]]++;\n  });\n  return histogram;\n}\n/**\n * Normalize values\n * @param  {integer} value Pixel channel value.\n * @param  {integer} min   Minimum value for channel\n * @param  {integer} max   Maximum value for channel\n * @return {integer} normalized values\n */\n\n\nvar _normalize = function normalize(value, min, max) {\n  return (value - min) * 255 / (max - min);\n};\n\nvar getBounds = function getBounds(histogramChannel) {\n  return [histogramChannel.findIndex(function (value) {\n    return value > 0;\n  }), 255 - histogramChannel.slice().reverse().findIndex(function (value) {\n    return value > 0;\n  })];\n};\n/**\n * Normalizes the image\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n\n\nvar _default = function _default() {\n  return {\n    normalize: function normalize(cb) {\n      var h = histogram.call(this); // store bounds (minimum and maximum values)\n\n      var bounds = {\n        r: getBounds(h.r),\n        g: getBounds(h.g),\n        b: getBounds(h.b)\n      }; // apply value transformations\n\n      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        var r = this.bitmap.data[idx + 0];\n        var g = this.bitmap.data[idx + 1];\n        var b = this.bitmap.data[idx + 2];\n        this.bitmap.data[idx + 0] = _normalize(r, bounds.r[0], bounds.r[1]);\n        this.bitmap.data[idx + 1] = _normalize(g, bounds.g[0], bounds.g[1]);\n        this.bitmap.data[idx + 2] = _normalize(b, bounds.b[0], bounds.b[1]);\n      });\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    }\n  };\n};\n\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../src/index.js"],"names":["histogram","r","g","b","index","normalize","value","max","getBounds","h","bounds","idx","cb"],"mappings":"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","sourcesContent":["import { isNodePattern } from '@jimp/utils';\n\n/**\n * Get an image's histogram\n * @return {object} An object with an array of color occurrence counts for each channel (r,g,b)\n */\nfunction histogram() {\n  const histogram = {\n    r: new Array(256).fill(0),\n    g: new Array(256).fill(0),\n    b: new Array(256).fill(0)\n  };\n\n  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n    x,\n    y,\n    index\n  ) {\n    histogram.r[this.bitmap.data[index + 0]]++;\n    histogram.g[this.bitmap.data[index + 1]]++;\n    histogram.b[this.bitmap.data[index + 2]]++;\n  });\n\n  return histogram;\n}\n\n/**\n * Normalize values\n * @param  {integer} value Pixel channel value.\n * @param  {integer} min   Minimum value for channel\n * @param  {integer} max   Maximum value for channel\n * @return {integer} normalized values\n */\nconst normalize = function(value, min, max) {\n  return ((value - min) * 255) / (max - min);\n};\n\nconst getBounds = function(histogramChannel) {\n  return [\n    histogramChannel.findIndex(value => value > 0),\n    255 -\n      histogramChannel\n        .slice()\n        .reverse()\n        .findIndex(value => value > 0)\n  ];\n};\n\n/**\n * Normalizes the image\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport default () => ({\n  normalize(cb) {\n    const h = histogram.call(this);\n\n    // store bounds (minimum and maximum values)\n    const bounds = {\n      r: getBounds(h.r),\n      g: getBounds(h.g),\n      b: getBounds(h.b)\n    };\n\n    // apply value transformations\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n      x,\n      y,\n      idx\n    ) {\n      const r = this.bitmap.data[idx + 0];\n      const g = this.bitmap.data[idx + 1];\n      const b = this.bitmap.data[idx + 2];\n\n      this.bitmap.data[idx + 0] = normalize(r, bounds.r[0], bounds.r[1]);\n      this.bitmap.data[idx + 1] = normalize(g, bounds.g[0], bounds.g[1]);\n      this.bitmap.data[idx + 2] = normalize(b, bounds.b[0], bounds.b[1]);\n    });\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  }\n});\n"]},"metadata":{},"sourceType":"script"}