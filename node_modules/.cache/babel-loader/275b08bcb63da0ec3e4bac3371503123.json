{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _utils = require(\"@jimp/utils\");\n/**\n * Rotates an image clockwise by an arbitrary number of degrees. NB: 'this' must be a Jimp object.\n * @param {number} deg the number of degrees to rotate the image by\n * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed\n */\n\n\nfunction advancedRotate(deg, mode) {\n  deg %= 360;\n  var rad = deg * Math.PI / 180;\n  var cosine = Math.cos(rad);\n  var sine = Math.sin(rad); // the final width and height will change if resize == true\n\n  var w = this.bitmap.width;\n  var h = this.bitmap.height;\n\n  if (mode === true || typeof mode === 'string') {\n    // resize the image to it maximum dimension and blit the existing image\n    // onto the center so that when it is rotated the image is kept in bounds\n    // http://stackoverflow.com/questions/3231176/how-to-get-size-of-a-rotated-rectangle\n    // Plus 1 border pixel to ensure to show all rotated result for some cases.\n    w = Math.ceil(Math.abs(this.bitmap.width * cosine) + Math.abs(this.bitmap.height * sine)) + 1;\n    h = Math.ceil(Math.abs(this.bitmap.width * sine) + Math.abs(this.bitmap.height * cosine)) + 1; // Ensure destination to have even size to a better result.\n\n    if (w % 2 !== 0) {\n      w++;\n    }\n\n    if (h % 2 !== 0) {\n      h++;\n    }\n\n    var c = this.cloneQuiet();\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n      this.bitmap.data.writeUInt32BE(this._background, idx);\n    });\n    var max = Math.max(w, h, this.bitmap.width, this.bitmap.height);\n    this.resize(max, max, mode);\n    this.blit(c, this.bitmap.width / 2 - c.bitmap.width / 2, this.bitmap.height / 2 - c.bitmap.height / 2);\n  }\n\n  var bW = this.bitmap.width;\n  var bH = this.bitmap.height;\n  var dstBuffer = Buffer.alloc(this.bitmap.data.length);\n\n  function createTranslationFunction(deltaX, deltaY) {\n    return function (x, y) {\n      return {\n        x: x + deltaX,\n        y: y + deltaY\n      };\n    };\n  }\n\n  var translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));\n  var translate2Screen = createTranslationFunction(bW / 2 + 0.5, bH / 2 + 0.5);\n\n  for (var y = 1; y <= bH; y++) {\n    for (var x = 1; x <= bW; x++) {\n      var cartesian = translate2Cartesian(x, y);\n      var source = translate2Screen(cosine * cartesian.x - sine * cartesian.y, cosine * cartesian.y + sine * cartesian.x);\n      var dstIdx = bW * (y - 1) + x - 1 << 2;\n\n      if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {\n        var srcIdx = (bW * (source.y | 0) + source.x | 0) << 2;\n        var pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);\n        dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);\n      } else {\n        // reset off-image pixels\n        dstBuffer.writeUInt32BE(this._background, dstIdx);\n      }\n    }\n  }\n\n  this.bitmap.data = dstBuffer;\n\n  if (mode === true || typeof mode === 'string') {\n    // now crop the image to the final size\n    var _x = bW / 2 - w / 2;\n\n    var _y = bH / 2 - h / 2;\n\n    this.crop(_x, _y, w, h);\n  }\n}\n\nvar _default = function _default() {\n  return {\n    /**\n     * Rotates the image clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.\n     * @param {number} deg the number of degrees to rotate the image by\n     * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp} this for chaining of methods\n     */\n    rotate: function rotate(deg, mode, cb) {\n      // enable overloading\n      if (typeof mode === 'undefined' || mode === null) {\n        // e.g. image.resize(120);\n        // e.g. image.resize(120, null, cb);\n        // e.g. image.resize(120, undefined, cb);\n        mode = true;\n      }\n\n      if (typeof mode === 'function' && typeof cb === 'undefined') {\n        // e.g. image.resize(120, cb);\n        cb = mode;\n        mode = true;\n      }\n\n      if (typeof deg !== 'number') {\n        return _utils.throwError.call(this, 'deg must be a number', cb);\n      }\n\n      if (typeof mode !== 'boolean' && typeof mode !== 'string') {\n        return _utils.throwError.call(this, 'mode must be a boolean or a string', cb);\n      }\n\n      advancedRotate.call(this, deg, mode, cb);\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    }\n  };\n};\n\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../src/index.js"],"names":["deg","rad","Math","cosine","sine","w","h","mode","c","max","bW","bH","dstBuffer","Buffer","x","y","deltaY","translate2Cartesian","createTranslationFunction","translate2Screen","cartesian","source","dstIdx","srcIdx","pixelRGBA","rotate","cb","throwError","advancedRotate"],"mappings":"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","sourcesContent":["import { throwError, isNodePattern } from '@jimp/utils';\n\n/**\n * Rotates an image clockwise by an arbitrary number of degrees. NB: 'this' must be a Jimp object.\n * @param {number} deg the number of degrees to rotate the image by\n * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed\n */\nfunction advancedRotate(deg, mode) {\n  deg %= 360;\n  const rad = (deg * Math.PI) / 180;\n  const cosine = Math.cos(rad);\n  const sine = Math.sin(rad);\n\n  // the final width and height will change if resize == true\n  let w = this.bitmap.width;\n  let h = this.bitmap.height;\n\n  if (mode === true || typeof mode === 'string') {\n    // resize the image to it maximum dimension and blit the existing image\n    // onto the center so that when it is rotated the image is kept in bounds\n\n    // http://stackoverflow.com/questions/3231176/how-to-get-size-of-a-rotated-rectangle\n    // Plus 1 border pixel to ensure to show all rotated result for some cases.\n    w =\n      Math.ceil(\n        Math.abs(this.bitmap.width * cosine) +\n          Math.abs(this.bitmap.height * sine)\n      ) + 1;\n    h =\n      Math.ceil(\n        Math.abs(this.bitmap.width * sine) +\n          Math.abs(this.bitmap.height * cosine)\n      ) + 1;\n    // Ensure destination to have even size to a better result.\n    if (w % 2 !== 0) {\n      w++;\n    }\n\n    if (h % 2 !== 0) {\n      h++;\n    }\n\n    const c = this.cloneQuiet();\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n      x,\n      y,\n      idx\n    ) {\n      this.bitmap.data.writeUInt32BE(this._background, idx);\n    });\n\n    const max = Math.max(w, h, this.bitmap.width, this.bitmap.height);\n    this.resize(max, max, mode);\n\n    this.blit(\n      c,\n      this.bitmap.width / 2 - c.bitmap.width / 2,\n      this.bitmap.height / 2 - c.bitmap.height / 2\n    );\n  }\n\n  const bW = this.bitmap.width;\n  const bH = this.bitmap.height;\n  const dstBuffer = Buffer.alloc(this.bitmap.data.length);\n\n  function createTranslationFunction(deltaX, deltaY) {\n    return function(x, y) {\n      return {\n        x: x + deltaX,\n        y: y + deltaY\n      };\n    };\n  }\n\n  const translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));\n  const translate2Screen = createTranslationFunction(\n    bW / 2 + 0.5,\n    bH / 2 + 0.5\n  );\n\n  for (let y = 1; y <= bH; y++) {\n    for (let x = 1; x <= bW; x++) {\n      const cartesian = translate2Cartesian(x, y);\n      const source = translate2Screen(\n        cosine * cartesian.x - sine * cartesian.y,\n        cosine * cartesian.y + sine * cartesian.x\n      );\n      const dstIdx = (bW * (y - 1) + x - 1) << 2;\n\n      if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {\n        const srcIdx = ((bW * (source.y | 0) + source.x) | 0) << 2;\n        const pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);\n        dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);\n      } else {\n        // reset off-image pixels\n        dstBuffer.writeUInt32BE(this._background, dstIdx);\n      }\n    }\n  }\n\n  this.bitmap.data = dstBuffer;\n\n  if (mode === true || typeof mode === 'string') {\n    // now crop the image to the final size\n    const x = bW / 2 - w / 2;\n    const y = bH / 2 - h / 2;\n    this.crop(x, y, w, h);\n  }\n}\n\nexport default () => ({\n  /**\n   * Rotates the image clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.\n   * @param {number} deg the number of degrees to rotate the image by\n   * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  rotate(deg, mode, cb) {\n    // enable overloading\n    if (typeof mode === 'undefined' || mode === null) {\n      // e.g. image.resize(120);\n      // e.g. image.resize(120, null, cb);\n      // e.g. image.resize(120, undefined, cb);\n      mode = true;\n    }\n\n    if (typeof mode === 'function' && typeof cb === 'undefined') {\n      // e.g. image.resize(120, cb);\n      cb = mode;\n      mode = true;\n    }\n\n    if (typeof deg !== 'number') {\n      return throwError.call(this, 'deg must be a number', cb);\n    }\n\n    if (typeof mode !== 'boolean' && typeof mode !== 'string') {\n      return throwError.call(this, 'mode must be a boolean or a string', cb);\n    }\n\n    advancedRotate.call(this, deg, mode, cb);\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  }\n});\n"]},"metadata":{},"sourceType":"script"}