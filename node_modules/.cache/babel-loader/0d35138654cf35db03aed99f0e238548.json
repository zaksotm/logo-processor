{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _tinycolor = _interopRequireDefault(require(\"tinycolor2\"));\n\nvar _utils = require(\"@jimp/utils\");\n\nfunction applyKernel(im, kernel, x, y) {\n  var value = [0, 0, 0];\n  var size = (kernel.length - 1) / 2;\n\n  for (var kx = 0; kx < kernel.length; kx += 1) {\n    for (var ky = 0; ky < kernel[kx].length; ky += 1) {\n      var idx = im.getPixelIndex(x + kx - size, y + ky - size);\n      value[0] += im.bitmap.data[idx] * kernel[kx][ky];\n      value[1] += im.bitmap.data[idx + 1] * kernel[kx][ky];\n      value[2] += im.bitmap.data[idx + 2] * kernel[kx][ky];\n    }\n  }\n\n  return value;\n}\n\nvar isDef = function isDef(v) {\n  return typeof v !== 'undefined' && v !== null;\n};\n\nfunction greyscale(cb) {\n  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n    var grey = parseInt(0.2126 * this.bitmap.data[idx] + 0.7152 * this.bitmap.data[idx + 1] + 0.0722 * this.bitmap.data[idx + 2], 10);\n    this.bitmap.data[idx] = grey;\n    this.bitmap.data[idx + 1] = grey;\n    this.bitmap.data[idx + 2] = grey;\n  });\n\n  if ((0, _utils.isNodePattern)(cb)) {\n    cb.call(this, null, this);\n  }\n\n  return this;\n}\n\nfunction mix(clr, clr2) {\n  var p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 50;\n  return {\n    r: (clr2.r - clr.r) * (p / 100) + clr.r,\n    g: (clr2.g - clr.g) * (p / 100) + clr.g,\n    b: (clr2.b - clr.b) * (p / 100) + clr.b\n  };\n}\n\nfunction colorFn(actions, cb) {\n  var _this = this;\n\n  if (!actions || !Array.isArray(actions)) {\n    return _utils.throwError.call(this, 'actions must be an array', cb);\n  }\n\n  actions = actions.map(function (action) {\n    if (action.apply === 'xor' || action.apply === 'mix') {\n      action.params[0] = (0, _tinycolor[\"default\"])(action.params[0]).toRgb();\n    }\n\n    return action;\n  });\n  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n    var clr = {\n      r: _this.bitmap.data[idx],\n      g: _this.bitmap.data[idx + 1],\n      b: _this.bitmap.data[idx + 2]\n    };\n\n    var colorModifier = function colorModifier(i, amount) {\n      return _this.constructor.limit255(clr[i] + amount);\n    };\n\n    actions.forEach(function (action) {\n      if (action.apply === 'mix') {\n        clr = mix(clr, action.params[0], action.params[1]);\n      } else if (action.apply === 'tint') {\n        clr = mix(clr, {\n          r: 255,\n          g: 255,\n          b: 255\n        }, action.params[0]);\n      } else if (action.apply === 'shade') {\n        clr = mix(clr, {\n          r: 0,\n          g: 0,\n          b: 0\n        }, action.params[0]);\n      } else if (action.apply === 'xor') {\n        clr = {\n          r: clr.r ^ action.params[0].r,\n          g: clr.g ^ action.params[0].g,\n          b: clr.b ^ action.params[0].b\n        };\n      } else if (action.apply === 'red') {\n        clr.r = colorModifier('r', action.params[0]);\n      } else if (action.apply === 'green') {\n        clr.g = colorModifier('g', action.params[0]);\n      } else if (action.apply === 'blue') {\n        clr.b = colorModifier('b', action.params[0]);\n      } else {\n        var _clr;\n\n        if (action.apply === 'hue') {\n          action.apply = 'spin';\n        }\n\n        clr = (0, _tinycolor[\"default\"])(clr);\n\n        if (!clr[action.apply]) {\n          return _utils.throwError.call(_this, 'action ' + action.apply + ' not supported', cb);\n        }\n\n        clr = (_clr = clr)[action.apply].apply(_clr, (0, _toConsumableArray2[\"default\"])(action.params)).toRgb();\n      }\n    });\n    _this.bitmap.data[idx] = clr.r;\n    _this.bitmap.data[idx + 1] = clr.g;\n    _this.bitmap.data[idx + 2] = clr.b;\n  });\n\n  if ((0, _utils.isNodePattern)(cb)) {\n    cb.call(this, null, this);\n  }\n\n  return this;\n}\n\nvar _default = function _default() {\n  return {\n    /**\n     * Adjusts the brightness of the image\n     * @param {number} val the amount to adjust the brightness, a number between -1 and +1\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    brightness: function brightness(val, cb) {\n      if (typeof val !== 'number') {\n        return _utils.throwError.call(this, 'val must be numbers', cb);\n      }\n\n      if (val < -1 || val > +1) {\n        return _utils.throwError.call(this, 'val must be a number between -1 and +1', cb);\n      }\n\n      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        if (val < 0.0) {\n          this.bitmap.data[idx] = this.bitmap.data[idx] * (1 + val);\n          this.bitmap.data[idx + 1] = this.bitmap.data[idx + 1] * (1 + val);\n          this.bitmap.data[idx + 2] = this.bitmap.data[idx + 2] * (1 + val);\n        } else {\n          this.bitmap.data[idx] = this.bitmap.data[idx] + (255 - this.bitmap.data[idx]) * val;\n          this.bitmap.data[idx + 1] = this.bitmap.data[idx + 1] + (255 - this.bitmap.data[idx + 1]) * val;\n          this.bitmap.data[idx + 2] = this.bitmap.data[idx + 2] + (255 - this.bitmap.data[idx + 2]) * val;\n        }\n      });\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    },\n\n    /**\n     * Adjusts the contrast of the image\n     * @param {number} val the amount to adjust the contrast, a number between -1 and +1\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    contrast: function contrast(val, cb) {\n      if (typeof val !== 'number') {\n        return _utils.throwError.call(this, 'val must be numbers', cb);\n      }\n\n      if (val < -1 || val > +1) {\n        return _utils.throwError.call(this, 'val must be a number between -1 and +1', cb);\n      }\n\n      var factor = (val + 1) / (1 - val);\n\n      function adjust(value) {\n        value = Math.floor(factor * (value - 127) + 127);\n        return value < 0 ? 0 : value > 255 ? 255 : value;\n      }\n\n      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        this.bitmap.data[idx] = adjust(this.bitmap.data[idx]);\n        this.bitmap.data[idx + 1] = adjust(this.bitmap.data[idx + 1]);\n        this.bitmap.data[idx + 2] = adjust(this.bitmap.data[idx + 2]);\n      });\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    },\n\n    /**\n     * Apply a posterize effect\n     * @param {number} n the amount to adjust the contrast, minimum threshold is two\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    posterize: function posterize(n, cb) {\n      if (typeof n !== 'number') {\n        return _utils.throwError.call(this, 'n must be numbers', cb);\n      }\n\n      if (n < 2) {\n        n = 2;\n      } // minimum of 2 levels\n\n\n      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        this.bitmap.data[idx] = Math.floor(this.bitmap.data[idx] / 255 * (n - 1)) / (n - 1) * 255;\n        this.bitmap.data[idx + 1] = Math.floor(this.bitmap.data[idx + 1] / 255 * (n - 1)) / (n - 1) * 255;\n        this.bitmap.data[idx + 2] = Math.floor(this.bitmap.data[idx + 2] / 255 * (n - 1)) / (n - 1) * 255;\n      });\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    },\n\n    /**\n     * Removes colour from the image using ITU Rec 709 luminance values\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    greyscale: greyscale,\n    // Alias of greyscale for our American friends\n    grayscale: greyscale,\n\n    /**\n     * Multiplies the opacity of each pixel by a factor between 0 and 1\n     * @param {number} f A number, the factor by which to multiply the opacity of each pixel\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    opacity: function opacity(f, cb) {\n      if (typeof f !== 'number') return _utils.throwError.call(this, 'f must be a number', cb);\n      if (f < 0 || f > 1) return _utils.throwError.call(this, 'f must be a number from 0 to 1', cb);\n      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        var v = this.bitmap.data[idx + 3] * f;\n        this.bitmap.data[idx + 3] = v;\n      });\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    },\n\n    /**\n     * Applies a sepia tone to the image\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    sepia: function sepia(cb) {\n      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        var red = this.bitmap.data[idx];\n        var green = this.bitmap.data[idx + 1];\n        var blue = this.bitmap.data[idx + 2];\n        red = red * 0.393 + green * 0.769 + blue * 0.189;\n        green = red * 0.349 + green * 0.686 + blue * 0.168;\n        blue = red * 0.272 + green * 0.534 + blue * 0.131;\n        this.bitmap.data[idx] = red < 255 ? red : 255;\n        this.bitmap.data[idx + 1] = green < 255 ? green : 255;\n        this.bitmap.data[idx + 2] = blue < 255 ? blue : 255;\n      });\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    },\n\n    /**\n     * Fades each pixel by a factor between 0 and 1\n     * @param {number} f A number from 0 to 1. 0 will haven no effect. 1 will turn the image completely transparent.\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    fade: function fade(f, cb) {\n      if (typeof f !== 'number') {\n        return _utils.throwError.call(this, 'f must be a number', cb);\n      }\n\n      if (f < 0 || f > 1) {\n        return _utils.throwError.call(this, 'f must be a number from 0 to 1', cb);\n      } // this method is an alternative to opacity (which may be deprecated)\n\n\n      this.opacity(1 - f);\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    },\n\n    /**\n     * Adds each element of the image to its local neighbors, weighted by the kernel\n     * @param {array} kernel a matrix to weight the neighbors sum\n     * @param {string} edgeHandling (optional) define how to sum pixels from outside the border\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    convolution: function convolution(kernel, edgeHandling, cb) {\n      if (typeof edgeHandling === 'function' && typeof cb === 'undefined') {\n        cb = edgeHandling;\n        edgeHandling = null;\n      }\n\n      if (!edgeHandling) {\n        edgeHandling = this.constructor.EDGE_EXTEND;\n      }\n\n      var newData = Buffer.from(this.bitmap.data);\n      var kRows = kernel.length;\n      var kCols = kernel[0].length;\n      var rowEnd = Math.floor(kRows / 2);\n      var colEnd = Math.floor(kCols / 2);\n      var rowIni = -rowEnd;\n      var colIni = -colEnd;\n      var weight;\n      var rSum;\n      var gSum;\n      var bSum;\n      var ri;\n      var gi;\n      var bi;\n      var xi;\n      var yi;\n      var idxi;\n      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        bSum = 0;\n        gSum = 0;\n        rSum = 0;\n\n        for (var row = rowIni; row <= rowEnd; row++) {\n          for (var col = colIni; col <= colEnd; col++) {\n            xi = x + col;\n            yi = y + row;\n            weight = kernel[row + rowEnd][col + colEnd];\n            idxi = this.getPixelIndex(xi, yi, edgeHandling);\n\n            if (idxi === -1) {\n              bi = 0;\n              gi = 0;\n              ri = 0;\n            } else {\n              ri = this.bitmap.data[idxi + 0];\n              gi = this.bitmap.data[idxi + 1];\n              bi = this.bitmap.data[idxi + 2];\n            }\n\n            rSum += weight * ri;\n            gSum += weight * gi;\n            bSum += weight * bi;\n          }\n        }\n\n        if (rSum < 0) {\n          rSum = 0;\n        }\n\n        if (gSum < 0) {\n          gSum = 0;\n        }\n\n        if (bSum < 0) {\n          bSum = 0;\n        }\n\n        if (rSum > 255) {\n          rSum = 255;\n        }\n\n        if (gSum > 255) {\n          gSum = 255;\n        }\n\n        if (bSum > 255) {\n          bSum = 255;\n        }\n\n        newData[idx + 0] = rSum;\n        newData[idx + 1] = gSum;\n        newData[idx + 2] = bSum;\n      });\n      this.bitmap.data = newData;\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    },\n\n    /**\n     * Set the alpha channel on every pixel to fully opaque\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    opaque: function opaque(cb) {\n      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        this.bitmap.data[idx + 3] = 255;\n      });\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    },\n\n    /**\n     * Pixelates the image or a region\n     * @param {number} size the size of the pixels\n     * @param {number} x (optional) the x position of the region to pixelate\n     * @param {number} y (optional) the y position of the region to pixelate\n     * @param {number} w (optional) the width of the region to pixelate\n     * @param {number} h (optional) the height of the region to pixelate\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    pixelate: function pixelate(size, x, y, w, h, cb) {\n      if (typeof x === 'function') {\n        cb = x;\n        h = null;\n        w = null;\n        y = null;\n        x = null;\n      } else {\n        if (typeof size !== 'number') {\n          return _utils.throwError.call(this, 'size must be a number', cb);\n        }\n\n        if (isDef(x) && typeof x !== 'number') {\n          return _utils.throwError.call(this, 'x must be a number', cb);\n        }\n\n        if (isDef(y) && typeof y !== 'number') {\n          return _utils.throwError.call(this, 'y must be a number', cb);\n        }\n\n        if (isDef(w) && typeof w !== 'number') {\n          return _utils.throwError.call(this, 'w must be a number', cb);\n        }\n\n        if (isDef(h) && typeof h !== 'number') {\n          return _utils.throwError.call(this, 'h must be a number', cb);\n        }\n      }\n\n      var kernel = [[1 / 16, 2 / 16, 1 / 16], [2 / 16, 4 / 16, 2 / 16], [1 / 16, 2 / 16, 1 / 16]];\n      x = x || 0;\n      y = y || 0;\n      w = isDef(w) ? w : this.bitmap.width - x;\n      h = isDef(h) ? h : this.bitmap.height - y;\n      var source = this.cloneQuiet();\n      this.scanQuiet(x, y, w, h, function (xx, yx, idx) {\n        xx = size * Math.floor(xx / size);\n        yx = size * Math.floor(yx / size);\n        var value = applyKernel(source, kernel, xx, yx);\n        this.bitmap.data[idx] = value[0];\n        this.bitmap.data[idx + 1] = value[1];\n        this.bitmap.data[idx + 2] = value[2];\n      });\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    },\n\n    /**\n     * Applies a convolution kernel to the image or a region\n     * @param {array} kernel the convolution kernel\n     * @param {number} x (optional) the x position of the region to apply convolution to\n     * @param {number} y (optional) the y position of the region to apply convolution to\n     * @param {number} w (optional) the width of the region to apply convolution to\n     * @param {number} h (optional) the height of the region to apply convolution to\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    convolute: function convolute(kernel, x, y, w, h, cb) {\n      if (!Array.isArray(kernel)) return _utils.throwError.call(this, 'the kernel must be an array', cb);\n\n      if (typeof x === 'function') {\n        cb = x;\n        x = null;\n        y = null;\n        w = null;\n        h = null;\n      } else {\n        if (isDef(x) && typeof x !== 'number') {\n          return _utils.throwError.call(this, 'x must be a number', cb);\n        }\n\n        if (isDef(y) && typeof y !== 'number') {\n          return _utils.throwError.call(this, 'y must be a number', cb);\n        }\n\n        if (isDef(w) && typeof w !== 'number') {\n          return _utils.throwError.call(this, 'w must be a number', cb);\n        }\n\n        if (isDef(h) && typeof h !== 'number') {\n          return _utils.throwError.call(this, 'h must be a number', cb);\n        }\n      }\n\n      var ksize = (kernel.length - 1) / 2;\n      x = isDef(x) ? x : ksize;\n      y = isDef(y) ? y : ksize;\n      w = isDef(w) ? w : this.bitmap.width - x;\n      h = isDef(h) ? h : this.bitmap.height - y;\n      var source = this.cloneQuiet();\n      this.scanQuiet(x, y, w, h, function (xx, yx, idx) {\n        var value = applyKernel(source, kernel, xx, yx);\n        this.bitmap.data[idx] = this.constructor.limit255(value[0]);\n        this.bitmap.data[idx + 1] = this.constructor.limit255(value[1]);\n        this.bitmap.data[idx + 2] = this.constructor.limit255(value[2]);\n      });\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    },\n\n    /**\n     * Apply multiple color modification rules\n     * @param {array} actions list of color modification rules, in following format: { apply: '<rule-name>', params: [ <rule-parameters> ]  }\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp }this for chaining of methods\n     */\n    color: colorFn,\n    colour: colorFn\n  };\n};\n\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../src/index.js"],"names":["value","size","kernel","kx","ky","idx","im","x","y","isDef","v","grey","parseInt","cb","p","r","clr2","clr","g","b","Array","throwError","actions","action","colorModifier","mix","brightness","val","contrast","factor","Math","adjust","posterize","n","greyscale","grayscale","opacity","f","sepia","red","green","blue","fade","convolution","edgeHandling","newData","Buffer","kRows","kCols","rowEnd","colEnd","rowIni","colIni","bSum","gSum","rSum","row","col","xi","yi","weight","idxi","bi","gi","ri","opaque","pixelate","h","w","source","xx","yx","applyKernel","convolute","ksize","color","colour","colorFn"],"mappings":"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","sourcesContent":["import tinyColor from 'tinycolor2';\nimport { throwError, isNodePattern } from '@jimp/utils';\n\nfunction applyKernel(im, kernel, x, y) {\n  const value = [0, 0, 0];\n  const size = (kernel.length - 1) / 2;\n\n  for (let kx = 0; kx < kernel.length; kx += 1) {\n    for (let ky = 0; ky < kernel[kx].length; ky += 1) {\n      const idx = im.getPixelIndex(x + kx - size, y + ky - size);\n\n      value[0] += im.bitmap.data[idx] * kernel[kx][ky];\n      value[1] += im.bitmap.data[idx + 1] * kernel[kx][ky];\n      value[2] += im.bitmap.data[idx + 2] * kernel[kx][ky];\n    }\n  }\n\n  return value;\n}\n\nconst isDef = v => typeof v !== 'undefined' && v !== null;\n\nfunction greyscale(cb) {\n  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n    x,\n    y,\n    idx\n  ) {\n    const grey = parseInt(\n      0.2126 * this.bitmap.data[idx] +\n        0.7152 * this.bitmap.data[idx + 1] +\n        0.0722 * this.bitmap.data[idx + 2],\n      10\n    );\n\n    this.bitmap.data[idx] = grey;\n    this.bitmap.data[idx + 1] = grey;\n    this.bitmap.data[idx + 2] = grey;\n  });\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, this);\n  }\n\n  return this;\n}\n\nfunction mix(clr, clr2, p = 50) {\n  return {\n    r: (clr2.r - clr.r) * (p / 100) + clr.r,\n    g: (clr2.g - clr.g) * (p / 100) + clr.g,\n    b: (clr2.b - clr.b) * (p / 100) + clr.b\n  };\n}\n\nfunction colorFn(actions, cb) {\n  if (!actions || !Array.isArray(actions)) {\n    return throwError.call(this, 'actions must be an array', cb);\n  }\n\n  actions = actions.map(action => {\n    if (action.apply === 'xor' || action.apply === 'mix') {\n      action.params[0] = tinyColor(action.params[0]).toRgb();\n    }\n\n    return action;\n  });\n\n  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (x, y, idx) => {\n    let clr = {\n      r: this.bitmap.data[idx],\n      g: this.bitmap.data[idx + 1],\n      b: this.bitmap.data[idx + 2]\n    };\n\n    const colorModifier = (i, amount) =>\n      this.constructor.limit255(clr[i] + amount);\n\n    actions.forEach(action => {\n      if (action.apply === 'mix') {\n        clr = mix(clr, action.params[0], action.params[1]);\n      } else if (action.apply === 'tint') {\n        clr = mix(clr, { r: 255, g: 255, b: 255 }, action.params[0]);\n      } else if (action.apply === 'shade') {\n        clr = mix(clr, { r: 0, g: 0, b: 0 }, action.params[0]);\n      } else if (action.apply === 'xor') {\n        clr = {\n          r: clr.r ^ action.params[0].r,\n          g: clr.g ^ action.params[0].g,\n          b: clr.b ^ action.params[0].b\n        };\n      } else if (action.apply === 'red') {\n        clr.r = colorModifier('r', action.params[0]);\n      } else if (action.apply === 'green') {\n        clr.g = colorModifier('g', action.params[0]);\n      } else if (action.apply === 'blue') {\n        clr.b = colorModifier('b', action.params[0]);\n      } else {\n        if (action.apply === 'hue') {\n          action.apply = 'spin';\n        }\n\n        clr = tinyColor(clr);\n\n        if (!clr[action.apply]) {\n          return throwError.call(\n            this,\n            'action ' + action.apply + ' not supported',\n            cb\n          );\n        }\n\n        clr = clr[action.apply](...action.params).toRgb();\n      }\n    });\n\n    this.bitmap.data[idx] = clr.r;\n    this.bitmap.data[idx + 1] = clr.g;\n    this.bitmap.data[idx + 2] = clr.b;\n  });\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, this);\n  }\n\n  return this;\n}\n\nexport default () => ({\n  /**\n   * Adjusts the brightness of the image\n   * @param {number} val the amount to adjust the brightness, a number between -1 and +1\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  brightness(val, cb) {\n    if (typeof val !== 'number') {\n      return throwError.call(this, 'val must be numbers', cb);\n    }\n\n    if (val < -1 || val > +1) {\n      return throwError.call(\n        this,\n        'val must be a number between -1 and +1',\n        cb\n      );\n    }\n\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n      x,\n      y,\n      idx\n    ) {\n      if (val < 0.0) {\n        this.bitmap.data[idx] = this.bitmap.data[idx] * (1 + val);\n        this.bitmap.data[idx + 1] = this.bitmap.data[idx + 1] * (1 + val);\n        this.bitmap.data[idx + 2] = this.bitmap.data[idx + 2] * (1 + val);\n      } else {\n        this.bitmap.data[idx] =\n          this.bitmap.data[idx] + (255 - this.bitmap.data[idx]) * val;\n        this.bitmap.data[idx + 1] =\n          this.bitmap.data[idx + 1] + (255 - this.bitmap.data[idx + 1]) * val;\n        this.bitmap.data[idx + 2] =\n          this.bitmap.data[idx + 2] + (255 - this.bitmap.data[idx + 2]) * val;\n      }\n    });\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Adjusts the contrast of the image\n   * @param {number} val the amount to adjust the contrast, a number between -1 and +1\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  contrast(val, cb) {\n    if (typeof val !== 'number') {\n      return throwError.call(this, 'val must be numbers', cb);\n    }\n\n    if (val < -1 || val > +1) {\n      return throwError.call(\n        this,\n        'val must be a number between -1 and +1',\n        cb\n      );\n    }\n\n    const factor = (val + 1) / (1 - val);\n\n    function adjust(value) {\n      value = Math.floor(factor * (value - 127) + 127);\n\n      return value < 0 ? 0 : value > 255 ? 255 : value;\n    }\n\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n      x,\n      y,\n      idx\n    ) {\n      this.bitmap.data[idx] = adjust(this.bitmap.data[idx]);\n      this.bitmap.data[idx + 1] = adjust(this.bitmap.data[idx + 1]);\n      this.bitmap.data[idx + 2] = adjust(this.bitmap.data[idx + 2]);\n    });\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Apply a posterize effect\n   * @param {number} n the amount to adjust the contrast, minimum threshold is two\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  posterize(n, cb) {\n    if (typeof n !== 'number') {\n      return throwError.call(this, 'n must be numbers', cb);\n    }\n\n    if (n < 2) {\n      n = 2;\n    } // minimum of 2 levels\n\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n      x,\n      y,\n      idx\n    ) {\n      this.bitmap.data[idx] =\n        (Math.floor((this.bitmap.data[idx] / 255) * (n - 1)) / (n - 1)) * 255;\n      this.bitmap.data[idx + 1] =\n        (Math.floor((this.bitmap.data[idx + 1] / 255) * (n - 1)) / (n - 1)) *\n        255;\n      this.bitmap.data[idx + 2] =\n        (Math.floor((this.bitmap.data[idx + 2] / 255) * (n - 1)) / (n - 1)) *\n        255;\n    });\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Removes colour from the image using ITU Rec 709 luminance values\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  greyscale,\n\n  // Alias of greyscale for our American friends\n  grayscale: greyscale,\n\n  /**\n   * Multiplies the opacity of each pixel by a factor between 0 and 1\n   * @param {number} f A number, the factor by which to multiply the opacity of each pixel\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  opacity(f, cb) {\n    if (typeof f !== 'number')\n      return throwError.call(this, 'f must be a number', cb);\n    if (f < 0 || f > 1)\n      return throwError.call(this, 'f must be a number from 0 to 1', cb);\n\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n      x,\n      y,\n      idx\n    ) {\n      const v = this.bitmap.data[idx + 3] * f;\n      this.bitmap.data[idx + 3] = v;\n    });\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Applies a sepia tone to the image\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  sepia(cb) {\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n      x,\n      y,\n      idx\n    ) {\n      let red = this.bitmap.data[idx];\n      let green = this.bitmap.data[idx + 1];\n      let blue = this.bitmap.data[idx + 2];\n\n      red = red * 0.393 + green * 0.769 + blue * 0.189;\n      green = red * 0.349 + green * 0.686 + blue * 0.168;\n      blue = red * 0.272 + green * 0.534 + blue * 0.131;\n\n      this.bitmap.data[idx] = red < 255 ? red : 255;\n      this.bitmap.data[idx + 1] = green < 255 ? green : 255;\n      this.bitmap.data[idx + 2] = blue < 255 ? blue : 255;\n    });\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Fades each pixel by a factor between 0 and 1\n   * @param {number} f A number from 0 to 1. 0 will haven no effect. 1 will turn the image completely transparent.\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  fade(f, cb) {\n    if (typeof f !== 'number') {\n      return throwError.call(this, 'f must be a number', cb);\n    }\n\n    if (f < 0 || f > 1) {\n      return throwError.call(this, 'f must be a number from 0 to 1', cb);\n    }\n\n    // this method is an alternative to opacity (which may be deprecated)\n    this.opacity(1 - f);\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Adds each element of the image to its local neighbors, weighted by the kernel\n   * @param {array} kernel a matrix to weight the neighbors sum\n   * @param {string} edgeHandling (optional) define how to sum pixels from outside the border\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  convolution(kernel, edgeHandling, cb) {\n    if (typeof edgeHandling === 'function' && typeof cb === 'undefined') {\n      cb = edgeHandling;\n      edgeHandling = null;\n    }\n\n    if (!edgeHandling) {\n      edgeHandling = this.constructor.EDGE_EXTEND;\n    }\n\n    const newData = Buffer.from(this.bitmap.data);\n    const kRows = kernel.length;\n    const kCols = kernel[0].length;\n    const rowEnd = Math.floor(kRows / 2);\n    const colEnd = Math.floor(kCols / 2);\n    const rowIni = -rowEnd;\n    const colIni = -colEnd;\n\n    let weight;\n    let rSum;\n    let gSum;\n    let bSum;\n    let ri;\n    let gi;\n    let bi;\n    let xi;\n    let yi;\n    let idxi;\n\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n      x,\n      y,\n      idx\n    ) {\n      bSum = 0;\n      gSum = 0;\n      rSum = 0;\n\n      for (let row = rowIni; row <= rowEnd; row++) {\n        for (let col = colIni; col <= colEnd; col++) {\n          xi = x + col;\n          yi = y + row;\n          weight = kernel[row + rowEnd][col + colEnd];\n          idxi = this.getPixelIndex(xi, yi, edgeHandling);\n\n          if (idxi === -1) {\n            bi = 0;\n            gi = 0;\n            ri = 0;\n          } else {\n            ri = this.bitmap.data[idxi + 0];\n            gi = this.bitmap.data[idxi + 1];\n            bi = this.bitmap.data[idxi + 2];\n          }\n\n          rSum += weight * ri;\n          gSum += weight * gi;\n          bSum += weight * bi;\n        }\n      }\n\n      if (rSum < 0) {\n        rSum = 0;\n      }\n\n      if (gSum < 0) {\n        gSum = 0;\n      }\n\n      if (bSum < 0) {\n        bSum = 0;\n      }\n\n      if (rSum > 255) {\n        rSum = 255;\n      }\n\n      if (gSum > 255) {\n        gSum = 255;\n      }\n\n      if (bSum > 255) {\n        bSum = 255;\n      }\n\n      newData[idx + 0] = rSum;\n      newData[idx + 1] = gSum;\n      newData[idx + 2] = bSum;\n    });\n\n    this.bitmap.data = newData;\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Set the alpha channel on every pixel to fully opaque\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  opaque(cb) {\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n      x,\n      y,\n      idx\n    ) {\n      this.bitmap.data[idx + 3] = 255;\n    });\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Pixelates the image or a region\n   * @param {number} size the size of the pixels\n   * @param {number} x (optional) the x position of the region to pixelate\n   * @param {number} y (optional) the y position of the region to pixelate\n   * @param {number} w (optional) the width of the region to pixelate\n   * @param {number} h (optional) the height of the region to pixelate\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  pixelate(size, x, y, w, h, cb) {\n    if (typeof x === 'function') {\n      cb = x;\n      h = null;\n      w = null;\n      y = null;\n      x = null;\n    } else {\n      if (typeof size !== 'number') {\n        return throwError.call(this, 'size must be a number', cb);\n      }\n\n      if (isDef(x) && typeof x !== 'number') {\n        return throwError.call(this, 'x must be a number', cb);\n      }\n\n      if (isDef(y) && typeof y !== 'number') {\n        return throwError.call(this, 'y must be a number', cb);\n      }\n\n      if (isDef(w) && typeof w !== 'number') {\n        return throwError.call(this, 'w must be a number', cb);\n      }\n\n      if (isDef(h) && typeof h !== 'number') {\n        return throwError.call(this, 'h must be a number', cb);\n      }\n    }\n\n    const kernel = [\n      [1 / 16, 2 / 16, 1 / 16],\n      [2 / 16, 4 / 16, 2 / 16],\n      [1 / 16, 2 / 16, 1 / 16]\n    ];\n\n    x = x || 0;\n    y = y || 0;\n    w = isDef(w) ? w : this.bitmap.width - x;\n    h = isDef(h) ? h : this.bitmap.height - y;\n\n    const source = this.cloneQuiet();\n\n    this.scanQuiet(x, y, w, h, function(xx, yx, idx) {\n      xx = size * Math.floor(xx / size);\n      yx = size * Math.floor(yx / size);\n\n      const value = applyKernel(source, kernel, xx, yx);\n\n      this.bitmap.data[idx] = value[0];\n      this.bitmap.data[idx + 1] = value[1];\n      this.bitmap.data[idx + 2] = value[2];\n    });\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Applies a convolution kernel to the image or a region\n   * @param {array} kernel the convolution kernel\n   * @param {number} x (optional) the x position of the region to apply convolution to\n   * @param {number} y (optional) the y position of the region to apply convolution to\n   * @param {number} w (optional) the width of the region to apply convolution to\n   * @param {number} h (optional) the height of the region to apply convolution to\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  convolute(kernel, x, y, w, h, cb) {\n    if (!Array.isArray(kernel))\n      return throwError.call(this, 'the kernel must be an array', cb);\n\n    if (typeof x === 'function') {\n      cb = x;\n      x = null;\n      y = null;\n      w = null;\n      h = null;\n    } else {\n      if (isDef(x) && typeof x !== 'number') {\n        return throwError.call(this, 'x must be a number', cb);\n      }\n\n      if (isDef(y) && typeof y !== 'number') {\n        return throwError.call(this, 'y must be a number', cb);\n      }\n\n      if (isDef(w) && typeof w !== 'number') {\n        return throwError.call(this, 'w must be a number', cb);\n      }\n\n      if (isDef(h) && typeof h !== 'number') {\n        return throwError.call(this, 'h must be a number', cb);\n      }\n    }\n\n    const ksize = (kernel.length - 1) / 2;\n\n    x = isDef(x) ? x : ksize;\n    y = isDef(y) ? y : ksize;\n    w = isDef(w) ? w : this.bitmap.width - x;\n    h = isDef(h) ? h : this.bitmap.height - y;\n\n    const source = this.cloneQuiet();\n\n    this.scanQuiet(x, y, w, h, function(xx, yx, idx) {\n      const value = applyKernel(source, kernel, xx, yx);\n\n      this.bitmap.data[idx] = this.constructor.limit255(value[0]);\n      this.bitmap.data[idx + 1] = this.constructor.limit255(value[1]);\n      this.bitmap.data[idx + 2] = this.constructor.limit255(value[2]);\n    });\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Apply multiple color modification rules\n   * @param {array} actions list of color modification rules, in following format: { apply: '<rule-name>', params: [ <rule-parameters> ]  }\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  color: colorFn,\n  colour: colorFn\n});\n"]},"metadata":{},"sourceType":"script"}