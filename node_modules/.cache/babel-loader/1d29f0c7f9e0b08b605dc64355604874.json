{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseBitmap = parseBitmap;\nexports.getBuffer = getBuffer;\nexports.getBufferAsync = getBufferAsync;\n\nvar _fileType = _interopRequireDefault(require(\"file-type\"));\n\nvar _exifParser = _interopRequireDefault(require(\"exif-parser\"));\n\nvar _utils = require(\"@jimp/utils\");\n\nvar constants = _interopRequireWildcard(require(\"../constants\"));\n\nvar MIME = _interopRequireWildcard(require(\"./mime\"));\n\nvar _promisify = _interopRequireDefault(require(\"./promisify\"));\n\nfunction getMIMEFromBuffer(buffer, path) {\n  var fileTypeFromBuffer = (0, _fileType[\"default\"])(buffer);\n\n  if (fileTypeFromBuffer) {\n    // If fileType returns something for buffer, then return the mime given\n    return fileTypeFromBuffer.mime;\n  }\n\n  if (path) {\n    // If a path is supplied, and fileType yields no results, then retry with MIME\n    // Path can be either a file path or a url\n    return MIME.getType(path);\n  }\n\n  return null;\n}\n/*\n * Automagically rotates an image based on its EXIF data (if present)\n * @param img a constants object\n */\n\n\nfunction exifRotate(img) {\n  var exif = img._exif;\n\n  if (exif && exif.tags && exif.tags.Orientation) {\n    switch (img._exif.tags.Orientation) {\n      case 1:\n        // Horizontal (normal)\n        // do nothing\n        break;\n\n      case 2:\n        // Mirror horizontal\n        img.mirror(true, false);\n        break;\n\n      case 3:\n        // Rotate 180\n        img.rotate(180);\n        break;\n\n      case 4:\n        // Mirror vertical\n        img.mirror(false, true);\n        break;\n\n      case 5:\n        // Mirror horizontal and rotate 270 CW\n        img.rotate(-90).mirror(true, false);\n        break;\n\n      case 6:\n        // Rotate 90 CW\n        img.rotate(-90);\n        break;\n\n      case 7:\n        // Mirror horizontal and rotate 90 CW\n        img.rotate(90).mirror(true, false);\n        break;\n\n      case 8:\n        // Rotate 270 CW\n        img.rotate(-270);\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  return img;\n} // parses a bitmap from the constructor to the JIMP bitmap property\n\n\nfunction parseBitmap(data, path, cb) {\n  var mime = getMIMEFromBuffer(data, path);\n\n  if (typeof mime !== 'string') {\n    return cb(new Error('Could not find MIME for Buffer <' + path + '>'));\n  }\n\n  this._originalMime = mime.toLowerCase();\n\n  try {\n    var _mime = this.getMIME();\n\n    if (this.constructor.decoders[_mime]) {\n      this.bitmap = this.constructor.decoders[_mime](data);\n    } else {\n      return _utils.throwError.call(this, 'Unsupported MIME type: ' + _mime, cb);\n    }\n  } catch (error) {\n    return cb.call(this, error, this);\n  }\n\n  try {\n    this._exif = _exifParser[\"default\"].create(data).parse();\n    exifRotate(this); // EXIF data\n  } catch (error) {\n    /* meh */\n  }\n\n  cb.call(this, null, this);\n  return this;\n}\n\nfunction compositeBitmapOverBackground(Jimp, image) {\n  return new Jimp(image.bitmap.width, image.bitmap.height, image._background).composite(image, 0, 0).bitmap;\n}\n/**\n * Converts the image to a buffer\n * @param {string} mime the mime type of the image buffer to be created\n * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n * @returns {Jimp} this for chaining of methods\n */\n\n\nfunction getBuffer(mime, cb) {\n  if (mime === constants.AUTO) {\n    // allow auto MIME detection\n    mime = this.getMIME();\n  }\n\n  if (typeof mime !== 'string') {\n    return _utils.throwError.call(this, 'mime must be a string', cb);\n  }\n\n  if (typeof cb !== 'function') {\n    return _utils.throwError.call(this, 'cb must be a function', cb);\n  }\n\n  mime = mime.toLowerCase();\n\n  if (this._rgba && this.constructor.hasAlpha[mime]) {\n    this.bitmap.data = Buffer.from(this.bitmap.data);\n  } else {\n    // when format doesn't support alpha\n    // composite onto a new image so that the background shows through alpha channels\n    this.bitmap.data = compositeBitmapOverBackground(this.constructor, this).data;\n  }\n\n  if (this.constructor.encoders[mime]) {\n    var buffer = this.constructor.encoders[mime](this);\n    cb.call(this, null, buffer);\n  } else {\n    cb.call(this, 'Unsupported MIME type: ' + mime);\n  }\n\n  return this;\n}\n\nfunction getBufferAsync(mime) {\n  return (0, _promisify[\"default\"])(getBuffer, this, mime);\n}","map":{"version":3,"sources":["../../src/utils/image-bitmap.js"],"names":["fileTypeFromBuffer","MIME","exif","img","mime","getMIMEFromBuffer","cb","throwError","EXIFParser","exifRotate","image","constants","Buffer","compositeBitmapOverBackground","buffer"],"mappings":";;;;;;;;;;;;;AAAA,IAAA,SAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AAEA,IAAA,WAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAEA,IAAA,SAAA,GAAA,uBAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AACA,IAAA,IAAA,GAAA,uBAAA,CAAA,OAAA,CAAA,QAAA,CAAA,CAAA;;AACA,IAAA,UAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;;AAEA,SAAA,iBAAA,CAAA,MAAA,EAAA,IAAA,EAAyC;AACvC,MAAMA,kBAAkB,GAAG,CAAA,GAAA,SAAA,CAAA,SAAA,CAAA,EAA3B,MAA2B,CAA3B;;AAEA,MAAA,kBAAA,EAAwB;AACtB;AACA,WAAOA,kBAAkB,CAAzB,IAAA;AACD;;AAED,MAAA,IAAA,EAAU;AACR;AACA;AACA,WAAOC,IAAI,CAAJA,OAAAA,CAAP,IAAOA,CAAP;AACD;;AAED,SAAA,IAAA;AACD;AAED;;;;;;AAIA,SAAA,UAAA,CAAA,GAAA,EAAyB;AACvB,MAAMC,IAAI,GAAGC,GAAG,CAAhB,KAAA;;AAEA,MAAID,IAAI,IAAIA,IAAI,CAAZA,IAAAA,IAAqBA,IAAI,CAAJA,IAAAA,CAAzB,WAAA,EAAgD;AAC9C,YAAQC,GAAG,CAAHA,KAAAA,CAAAA,IAAAA,CAAR,WAAA;AACE,WAAA,CAAA;AAAQ;AACN;AACA;;AACF,WAAA,CAAA;AAAQ;AACNA,QAAAA,GAAG,CAAHA,MAAAA,CAAAA,IAAAA,EAAAA,KAAAA;AACA;;AACF,WAAA,CAAA;AAAQ;AACNA,QAAAA,GAAG,CAAHA,MAAAA,CAAAA,GAAAA;AACA;;AACF,WAAA,CAAA;AAAQ;AACNA,QAAAA,GAAG,CAAHA,MAAAA,CAAAA,KAAAA,EAAAA,IAAAA;AACA;;AACF,WAAA,CAAA;AAAQ;AACNA,QAAAA,GAAG,CAAHA,MAAAA,CAAW,CAAXA,EAAAA,EAAAA,MAAAA,CAAAA,IAAAA,EAAAA,KAAAA;AACA;;AACF,WAAA,CAAA;AAAQ;AACNA,QAAAA,GAAG,CAAHA,MAAAA,CAAW,CAAXA,EAAAA;AACA;;AACF,WAAA,CAAA;AAAQ;AACNA,QAAAA,GAAG,CAAHA,MAAAA,CAAAA,EAAAA,EAAAA,MAAAA,CAAAA,IAAAA,EAAAA,KAAAA;AACA;;AACF,WAAA,CAAA;AAAQ;AACNA,QAAAA,GAAG,CAAHA,MAAAA,CAAW,CAAXA,GAAAA;AACA;;AACF;AACE;AA1BJ;AA4BD;;AAED,SAAA,GAAA;EAGF;;;AACO,SAAA,WAAA,CAAA,IAAA,EAAA,IAAA,EAAA,EAAA,EAAqC;AAC1C,MAAMC,IAAI,GAAGC,iBAAiB,CAAA,IAAA,EAA9B,IAA8B,CAA9B;;AAEA,MAAI,OAAA,IAAA,KAAJ,QAAA,EAA8B;AAC5B,WAAOC,EAAE,CAAC,IAAA,KAAA,CAAU,qCAAA,IAAA,GAApB,GAAU,CAAD,CAAT;AACD;;AAED,OAAA,aAAA,GAAqBF,IAAI,CAAzB,WAAqBA,EAArB;;AAEA,MAAI;AACF,QAAMA,KAAI,GAAG,KAAb,OAAa,EAAb;;AAEA,QAAI,KAAA,WAAA,CAAA,QAAA,CAAJ,KAAI,CAAJ,EAAqC;AACnC,WAAA,MAAA,GAAc,KAAA,WAAA,CAAA,QAAA,CAAA,KAAA,EAAd,IAAc,CAAd;AADF,KAAA,MAEO;AACL,aAAOG,MAAAA,CAAAA,UAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAsB,4BAAtBA,KAAAA,EAAP,EAAOA,CAAP;AACD;AAPH,GAAA,CAQE,OAAA,KAAA,EAAc;AACd,WAAOD,EAAE,CAAFA,IAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAP,IAAOA,CAAP;AACD;;AAED,MAAI;AACF,SAAA,KAAA,GAAaE,WAAAA,CAAAA,SAAAA,CAAAA,CAAAA,MAAAA,CAAAA,IAAAA,EAAb,KAAaA,EAAb;AACAC,IAAAA,UAAU,CAFR,IAEQ,CAAVA,CAFE,CAEgB;AAFpB,GAAA,CAGE,OAAA,KAAA,EAAc;AACd;AACD;;AAEDH,EAAAA,EAAE,CAAFA,IAAAA,CAAAA,IAAAA,EAAAA,IAAAA,EAAAA,IAAAA;AAEA,SAAA,IAAA;AACD;;AAED,SAAA,6BAAA,CAAA,IAAA,EAAA,KAAA,EAAoD;AAClD,SAAO,IAAA,IAAA,CACLI,KAAK,CAALA,MAAAA,CADK,KAAA,EAELA,KAAK,CAALA,MAAAA,CAFK,MAAA,EAGLA,KAAK,CAHA,WAAA,EAAA,SAAA,CAAA,KAAA,EAAA,CAAA,EAAA,CAAA,EAAP,MAAA;AAKD;AAED;;;;;;;;AAMO,SAAA,SAAA,CAAA,IAAA,EAAA,EAAA,EAA6B;AAClC,MAAIN,IAAI,KAAKO,SAAS,CAAtB,IAAA,EAA6B;AAC3B;AACAP,IAAAA,IAAI,GAAG,KAAPA,OAAO,EAAPA;AACD;;AAED,MAAI,OAAA,IAAA,KAAJ,QAAA,EAA8B;AAC5B,WAAOG,MAAAA,CAAAA,UAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAAA,uBAAAA,EAAP,EAAOA,CAAP;AACD;;AAED,MAAI,OAAA,EAAA,KAAJ,UAAA,EAA8B;AAC5B,WAAOA,MAAAA,CAAAA,UAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAAA,uBAAAA,EAAP,EAAOA,CAAP;AACD;;AAEDH,EAAAA,IAAI,GAAGA,IAAI,CAAXA,WAAOA,EAAPA;;AAEA,MAAI,KAAA,KAAA,IAAc,KAAA,WAAA,CAAA,QAAA,CAAlB,IAAkB,CAAlB,EAAmD;AACjD,SAAA,MAAA,CAAA,IAAA,GAAmBQ,MAAM,CAANA,IAAAA,CAAY,KAAA,MAAA,CAA/B,IAAmBA,CAAnB;AADF,GAAA,MAEO;AACL;AACA;AACA,SAAA,MAAA,CAAA,IAAA,GAAmBC,6BAA6B,CAC9C,KAD8C,WAAA,EAA7BA,IAA6B,CAA7BA,CAAnB,IAAA;AAID;;AAED,MAAI,KAAA,WAAA,CAAA,QAAA,CAAJ,IAAI,CAAJ,EAAqC;AACnC,QAAMC,MAAM,GAAG,KAAA,WAAA,CAAA,QAAA,CAAA,IAAA,EAAf,IAAe,CAAf;AACAR,IAAAA,EAAE,CAAFA,IAAAA,CAAAA,IAAAA,EAAAA,IAAAA,EAAAA,MAAAA;AAFF,GAAA,MAGO;AACLA,IAAAA,EAAE,CAAFA,IAAAA,CAAAA,IAAAA,EAAc,4BAAdA,IAAAA;AACD;;AAED,SAAA,IAAA;AACD;;AAEM,SAAA,cAAA,CAAA,IAAA,EAA8B;AACnC,SAAO,CAAA,GAAA,UAAA,CAAA,SAAA,CAAA,EAAA,SAAA,EAAA,IAAA,EAAP,IAAO,CAAP;AACD","sourcesContent":["import fileType from 'file-type';\n\nimport EXIFParser from 'exif-parser';\nimport { throwError } from '@jimp/utils';\n\nimport * as constants from '../constants';\nimport * as MIME from './mime';\nimport promisify from './promisify';\n\nfunction getMIMEFromBuffer(buffer, path) {\n  const fileTypeFromBuffer = fileType(buffer);\n\n  if (fileTypeFromBuffer) {\n    // If fileType returns something for buffer, then return the mime given\n    return fileTypeFromBuffer.mime;\n  }\n\n  if (path) {\n    // If a path is supplied, and fileType yields no results, then retry with MIME\n    // Path can be either a file path or a url\n    return MIME.getType(path);\n  }\n\n  return null;\n}\n\n/*\n * Automagically rotates an image based on its EXIF data (if present)\n * @param img a constants object\n */\nfunction exifRotate(img) {\n  const exif = img._exif;\n\n  if (exif && exif.tags && exif.tags.Orientation) {\n    switch (img._exif.tags.Orientation) {\n      case 1: // Horizontal (normal)\n        // do nothing\n        break;\n      case 2: // Mirror horizontal\n        img.mirror(true, false);\n        break;\n      case 3: // Rotate 180\n        img.rotate(180);\n        break;\n      case 4: // Mirror vertical\n        img.mirror(false, true);\n        break;\n      case 5: // Mirror horizontal and rotate 270 CW\n        img.rotate(-90).mirror(true, false);\n        break;\n      case 6: // Rotate 90 CW\n        img.rotate(-90);\n        break;\n      case 7: // Mirror horizontal and rotate 90 CW\n        img.rotate(90).mirror(true, false);\n        break;\n      case 8: // Rotate 270 CW\n        img.rotate(-270);\n        break;\n      default:\n        break;\n    }\n  }\n\n  return img;\n}\n\n// parses a bitmap from the constructor to the JIMP bitmap property\nexport function parseBitmap(data, path, cb) {\n  const mime = getMIMEFromBuffer(data, path);\n\n  if (typeof mime !== 'string') {\n    return cb(new Error('Could not find MIME for Buffer <' + path + '>'));\n  }\n\n  this._originalMime = mime.toLowerCase();\n\n  try {\n    const mime = this.getMIME();\n\n    if (this.constructor.decoders[mime]) {\n      this.bitmap = this.constructor.decoders[mime](data);\n    } else {\n      return throwError.call(this, 'Unsupported MIME type: ' + mime, cb);\n    }\n  } catch (error) {\n    return cb.call(this, error, this);\n  }\n\n  try {\n    this._exif = EXIFParser.create(data).parse();\n    exifRotate(this); // EXIF data\n  } catch (error) {\n    /* meh */\n  }\n\n  cb.call(this, null, this);\n\n  return this;\n}\n\nfunction compositeBitmapOverBackground(Jimp, image) {\n  return new Jimp(\n    image.bitmap.width,\n    image.bitmap.height,\n    image._background\n  ).composite(image, 0, 0).bitmap;\n}\n\n/**\n * Converts the image to a buffer\n * @param {string} mime the mime type of the image buffer to be created\n * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n * @returns {Jimp} this for chaining of methods\n */\nexport function getBuffer(mime, cb) {\n  if (mime === constants.AUTO) {\n    // allow auto MIME detection\n    mime = this.getMIME();\n  }\n\n  if (typeof mime !== 'string') {\n    return throwError.call(this, 'mime must be a string', cb);\n  }\n\n  if (typeof cb !== 'function') {\n    return throwError.call(this, 'cb must be a function', cb);\n  }\n\n  mime = mime.toLowerCase();\n\n  if (this._rgba && this.constructor.hasAlpha[mime]) {\n    this.bitmap.data = Buffer.from(this.bitmap.data);\n  } else {\n    // when format doesn't support alpha\n    // composite onto a new image so that the background shows through alpha channels\n    this.bitmap.data = compositeBitmapOverBackground(\n      this.constructor,\n      this\n    ).data;\n  }\n\n  if (this.constructor.encoders[mime]) {\n    const buffer = this.constructor.encoders[mime](this);\n    cb.call(this, null, buffer);\n  } else {\n    cb.call(this, 'Unsupported MIME type: ' + mime);\n  }\n\n  return this;\n}\n\nexport function getBufferAsync(mime) {\n  return promisify(getBuffer, this, mime);\n}\n"]},"metadata":{},"sourceType":"script"}