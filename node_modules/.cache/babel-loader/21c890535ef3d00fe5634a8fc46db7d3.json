{"ast":null,"code":"\"use strict\";\n/**\n * Copyright (c) 2015 Guyon Roche\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\nmodule.exports = {\n  nearestNeighbor: function nearestNeighbor(src, dst) {\n    var wSrc = src.width;\n    var hSrc = src.height;\n    var wDst = dst.width;\n    var hDst = dst.height;\n    var bufSrc = src.data;\n    var bufDst = dst.data;\n\n    for (var i = 0; i < hDst; i++) {\n      for (var j = 0; j < wDst; j++) {\n        var posDst = (i * wDst + j) * 4;\n        var iSrc = Math.floor(i * hSrc / hDst);\n        var jSrc = Math.floor(j * wSrc / wDst);\n        var posSrc = (iSrc * wSrc + jSrc) * 4;\n        bufDst[posDst++] = bufSrc[posSrc++];\n        bufDst[posDst++] = bufSrc[posSrc++];\n        bufDst[posDst++] = bufSrc[posSrc++];\n        bufDst[posDst++] = bufSrc[posSrc++];\n      }\n    }\n  },\n  bilinearInterpolation: function bilinearInterpolation(src, dst) {\n    var wSrc = src.width;\n    var hSrc = src.height;\n    var wDst = dst.width;\n    var hDst = dst.height;\n    var bufSrc = src.data;\n    var bufDst = dst.data;\n\n    var interpolate = function interpolate(k, kMin, vMin, kMax, vMax) {\n      // special case - k is integer\n      if (kMin === kMax) {\n        return vMin;\n      }\n\n      return Math.round((k - kMin) * vMax + (kMax - k) * vMin);\n    };\n\n    var assign = function assign(pos, offset, x, xMin, xMax, y, yMin, yMax) {\n      var posMin = (yMin * wSrc + xMin) * 4 + offset;\n      var posMax = (yMin * wSrc + xMax) * 4 + offset;\n      var vMin = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]); // special case, y is integer\n\n      if (yMax === yMin) {\n        bufDst[pos + offset] = vMin;\n      } else {\n        posMin = (yMax * wSrc + xMin) * 4 + offset;\n        posMax = (yMax * wSrc + xMax) * 4 + offset;\n        var vMax = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);\n        bufDst[pos + offset] = interpolate(y, yMin, vMin, yMax, vMax);\n      }\n    };\n\n    for (var i = 0; i < hDst; i++) {\n      for (var j = 0; j < wDst; j++) {\n        var posDst = (i * wDst + j) * 4; // x & y in src coordinates\n\n        var x = j * wSrc / wDst;\n        var xMin = Math.floor(x);\n        var xMax = Math.min(Math.ceil(x), wSrc - 1);\n        var y = i * hSrc / hDst;\n        var yMin = Math.floor(y);\n        var yMax = Math.min(Math.ceil(y), hSrc - 1);\n        assign(posDst, 0, x, xMin, xMax, y, yMin, yMax);\n        assign(posDst, 1, x, xMin, xMax, y, yMin, yMax);\n        assign(posDst, 2, x, xMin, xMax, y, yMin, yMax);\n        assign(posDst, 3, x, xMin, xMax, y, yMin, yMax);\n      }\n    }\n  },\n  _interpolate2D: function _interpolate2D(src, dst, options, interpolate) {\n    var bufSrc = src.data;\n    var bufDst = dst.data;\n    var wSrc = src.width;\n    var hSrc = src.height;\n    var wDst = dst.width;\n    var hDst = dst.height; // when dst smaller than src/2, interpolate first to a multiple between 0.5 and 1.0 src, then sum squares\n\n    var wM = Math.max(1, Math.floor(wSrc / wDst));\n    var wDst2 = wDst * wM;\n    var hM = Math.max(1, Math.floor(hSrc / hDst));\n    var hDst2 = hDst * hM; // ===========================================================\n    // Pass 1 - interpolate rows\n    // buf1 has width of dst2 and height of src\n\n    var buf1 = Buffer.alloc(wDst2 * hSrc * 4);\n\n    for (var i = 0; i < hSrc; i++) {\n      for (var j = 0; j < wDst2; j++) {\n        // i in src coords, j in dst coords\n        // calculate x in src coords\n        // this interpolation requires 4 sample points and the two inner ones must be real\n        // the outer points can be fudged for the edges.\n        // therefore (wSrc-1)/wDst2\n        var x = j * (wSrc - 1) / wDst2;\n        var xPos = Math.floor(x);\n        var t = x - xPos;\n        var srcPos = (i * wSrc + xPos) * 4;\n        var buf1Pos = (i * wDst2 + j) * 4;\n\n        for (var k = 0; k < 4; k++) {\n          var kPos = srcPos + k;\n          var x0 = xPos > 0 ? bufSrc[kPos - 4] : 2 * bufSrc[kPos] - bufSrc[kPos + 4];\n          var x1 = bufSrc[kPos];\n          var x2 = bufSrc[kPos + 4];\n          var x3 = xPos < wSrc - 2 ? bufSrc[kPos + 8] : 2 * bufSrc[kPos + 4] - bufSrc[kPos];\n          buf1[buf1Pos + k] = interpolate(x0, x1, x2, x3, t);\n        }\n      }\n    } // this._writeFile(wDst2, hSrc, buf1, \"out/buf1.jpg\");\n    // ===========================================================\n    // Pass 2 - interpolate columns\n    // buf2 has width and height of dst2\n\n\n    var buf2 = Buffer.alloc(wDst2 * hDst2 * 4);\n\n    for (var _i = 0; _i < hDst2; _i++) {\n      for (var _j = 0; _j < wDst2; _j++) {\n        // i&j in dst2 coords\n        // calculate y in buf1 coords\n        // this interpolation requires 4 sample points and the two inner ones must be real\n        // the outer points can be fudged for the edges.\n        // therefore (hSrc-1)/hDst2\n        var y = _i * (hSrc - 1) / hDst2;\n        var yPos = Math.floor(y);\n\n        var _t = y - yPos;\n\n        var _buf1Pos = (yPos * wDst2 + _j) * 4;\n\n        var buf2Pos = (_i * wDst2 + _j) * 4;\n\n        for (var _k = 0; _k < 4; _k++) {\n          var _kPos = _buf1Pos + _k;\n\n          var y0 = yPos > 0 ? buf1[_kPos - wDst2 * 4] : 2 * buf1[_kPos] - buf1[_kPos + wDst2 * 4];\n          var y1 = buf1[_kPos];\n          var y2 = buf1[_kPos + wDst2 * 4];\n          var y3 = yPos < hSrc - 2 ? buf1[_kPos + wDst2 * 8] : 2 * buf1[_kPos + wDst2 * 4] - buf1[_kPos];\n          buf2[buf2Pos + _k] = interpolate(y0, y1, y2, y3, _t);\n        }\n      }\n    } // this._writeFile(wDst2, hDst2, buf2, \"out/buf2.jpg\");\n    // ===========================================================\n    // Pass 3 - scale to dst\n\n\n    var m = wM * hM;\n\n    if (m > 1) {\n      for (var _i2 = 0; _i2 < hDst; _i2++) {\n        for (var _j2 = 0; _j2 < wDst; _j2++) {\n          // i&j in dst bounded coords\n          var r = 0;\n          var g = 0;\n          var b = 0;\n          var a = 0;\n          var realColors = 0;\n\n          for (var _y = 0; _y < hM; _y++) {\n            var _yPos = _i2 * hM + _y;\n\n            for (var _x = 0; _x < wM; _x++) {\n              var _xPos = _j2 * wM + _x;\n\n              var xyPos = (_yPos * wDst2 + _xPos) * 4;\n              var pixelAlpha = buf2[xyPos + 3];\n\n              if (pixelAlpha) {\n                r += buf2[xyPos];\n                g += buf2[xyPos + 1];\n                b += buf2[xyPos + 2];\n                realColors++;\n              }\n\n              a += pixelAlpha;\n            }\n          }\n\n          var pos = (_i2 * wDst + _j2) * 4;\n          bufDst[pos] = realColors ? Math.round(r / realColors) : 0;\n          bufDst[pos + 1] = realColors ? Math.round(g / realColors) : 0;\n          bufDst[pos + 2] = realColors ? Math.round(b / realColors) : 0;\n          bufDst[pos + 3] = Math.round(a / m);\n        }\n      }\n    } else {\n      // replace dst buffer with buf2\n      dst.data = buf2;\n    }\n  },\n  bicubicInterpolation: function bicubicInterpolation(src, dst, options) {\n    var interpolateCubic = function interpolateCubic(x0, x1, x2, x3, t) {\n      var a0 = x3 - x2 - x0 + x1;\n      var a1 = x0 - x1 - a0;\n      var a2 = x2 - x0;\n      var a3 = x1;\n      return Math.max(0, Math.min(255, a0 * (t * t * t) + a1 * (t * t) + a2 * t + a3));\n    };\n\n    return this._interpolate2D(src, dst, options, interpolateCubic);\n  },\n  hermiteInterpolation: function hermiteInterpolation(src, dst, options) {\n    var interpolateHermite = function interpolateHermite(x0, x1, x2, x3, t) {\n      var c0 = x1;\n      var c1 = 0.5 * (x2 - x0);\n      var c2 = x0 - 2.5 * x1 + 2 * x2 - 0.5 * x3;\n      var c3 = 0.5 * (x3 - x0) + 1.5 * (x1 - x2);\n      return Math.max(0, Math.min(255, Math.round(((c3 * t + c2) * t + c1) * t + c0)));\n    };\n\n    return this._interpolate2D(src, dst, options, interpolateHermite);\n  },\n  bezierInterpolation: function bezierInterpolation(src, dst, options) {\n    // between 2 points y(n), y(n+1), use next points out, y(n-1), y(n+2)\n    // to predict control points (a & b) to be placed at n+0.5\n    //  ya(n) = y(n) + (y(n+1)-y(n-1))/4\n    //  yb(n) = y(n+1) - (y(n+2)-y(n))/4\n    // then use std bezier to interpolate [n,n+1)\n    //  y(n+t) = y(n)*(1-t)^3 + 3 * ya(n)*(1-t)^2*t + 3 * yb(n)*(1-t)*t^2 + y(n+1)*t^3\n    //  note the 3* factor for the two control points\n    // for edge cases, can choose:\n    //  y(-1) = y(0) - 2*(y(1)-y(0))\n    //  y(w) = y(w-1) + 2*(y(w-1)-y(w-2))\n    // but can go with y(-1) = y(0) and y(w) = y(w-1)\n    var interpolateBezier = function interpolateBezier(x0, x1, x2, x3, t) {\n      // x1, x2 are the knots, use x0 and x3 to calculate control points\n      var cp1 = x1 + (x2 - x0) / 4;\n      var cp2 = x2 - (x3 - x1) / 4;\n      var nt = 1 - t;\n      var c0 = x1 * nt * nt * nt;\n      var c1 = 3 * cp1 * nt * nt * t;\n      var c2 = 3 * cp2 * nt * t * t;\n      var c3 = x2 * t * t * t;\n      return Math.max(0, Math.min(255, Math.round(c0 + c1 + c2 + c3)));\n    };\n\n    return this._interpolate2D(src, dst, options, interpolateBezier);\n  }\n};","map":{"version":3,"sources":["../../src/modules/resize2.js"],"names":["module","nearestNeighbor","wSrc","src","hSrc","wDst","dst","hDst","bufSrc","bufDst","i","j","posDst","iSrc","Math","jSrc","posSrc","bilinearInterpolation","interpolate","kMin","k","kMax","assign","posMin","yMin","posMax","vMin","yMax","pos","vMax","x","xMin","xMax","y","_interpolate2D","wM","wDst2","hM","hDst2","buf1","Buffer","xPos","t","srcPos","buf1Pos","kPos","x0","x1","x2","x3","buf2","yPos","buf2Pos","y0","y1","y2","y3","m","r","g","b","a","realColors","xyPos","pixelAlpha","bicubicInterpolation","interpolateCubic","a0","a1","a2","a3","hermiteInterpolation","interpolateHermite","c0","c1","c2","c3","bezierInterpolation","interpolateBezier","cp1","cp2","nt"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015 Guyon Roche\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\nmodule.exports = {\n  nearestNeighbor(src, dst) {\n    const wSrc = src.width;\n    const hSrc = src.height;\n\n    const wDst = dst.width;\n    const hDst = dst.height;\n\n    const bufSrc = src.data;\n    const bufDst = dst.data;\n\n    for (let i = 0; i < hDst; i++) {\n      for (let j = 0; j < wDst; j++) {\n        let posDst = (i * wDst + j) * 4;\n\n        const iSrc = Math.floor((i * hSrc) / hDst);\n        const jSrc = Math.floor((j * wSrc) / wDst);\n        let posSrc = (iSrc * wSrc + jSrc) * 4;\n\n        bufDst[posDst++] = bufSrc[posSrc++];\n        bufDst[posDst++] = bufSrc[posSrc++];\n        bufDst[posDst++] = bufSrc[posSrc++];\n        bufDst[posDst++] = bufSrc[posSrc++];\n      }\n    }\n  },\n\n  bilinearInterpolation(src, dst) {\n    const wSrc = src.width;\n    const hSrc = src.height;\n\n    const wDst = dst.width;\n    const hDst = dst.height;\n\n    const bufSrc = src.data;\n    const bufDst = dst.data;\n\n    const interpolate = function(k, kMin, vMin, kMax, vMax) {\n      // special case - k is integer\n      if (kMin === kMax) {\n        return vMin;\n      }\n\n      return Math.round((k - kMin) * vMax + (kMax - k) * vMin);\n    };\n\n    const assign = function(pos, offset, x, xMin, xMax, y, yMin, yMax) {\n      let posMin = (yMin * wSrc + xMin) * 4 + offset;\n      let posMax = (yMin * wSrc + xMax) * 4 + offset;\n      const vMin = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);\n\n      // special case, y is integer\n      if (yMax === yMin) {\n        bufDst[pos + offset] = vMin;\n      } else {\n        posMin = (yMax * wSrc + xMin) * 4 + offset;\n        posMax = (yMax * wSrc + xMax) * 4 + offset;\n        const vMax = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);\n\n        bufDst[pos + offset] = interpolate(y, yMin, vMin, yMax, vMax);\n      }\n    };\n\n    for (let i = 0; i < hDst; i++) {\n      for (let j = 0; j < wDst; j++) {\n        const posDst = (i * wDst + j) * 4;\n        // x & y in src coordinates\n        const x = (j * wSrc) / wDst;\n        const xMin = Math.floor(x);\n        const xMax = Math.min(Math.ceil(x), wSrc - 1);\n\n        const y = (i * hSrc) / hDst;\n        const yMin = Math.floor(y);\n        const yMax = Math.min(Math.ceil(y), hSrc - 1);\n\n        assign(posDst, 0, x, xMin, xMax, y, yMin, yMax);\n        assign(posDst, 1, x, xMin, xMax, y, yMin, yMax);\n        assign(posDst, 2, x, xMin, xMax, y, yMin, yMax);\n        assign(posDst, 3, x, xMin, xMax, y, yMin, yMax);\n      }\n    }\n  },\n\n  _interpolate2D(src, dst, options, interpolate) {\n    const bufSrc = src.data;\n    const bufDst = dst.data;\n\n    const wSrc = src.width;\n    const hSrc = src.height;\n\n    const wDst = dst.width;\n    const hDst = dst.height;\n\n    // when dst smaller than src/2, interpolate first to a multiple between 0.5 and 1.0 src, then sum squares\n    const wM = Math.max(1, Math.floor(wSrc / wDst));\n    const wDst2 = wDst * wM;\n    const hM = Math.max(1, Math.floor(hSrc / hDst));\n    const hDst2 = hDst * hM;\n\n    // ===========================================================\n    // Pass 1 - interpolate rows\n    // buf1 has width of dst2 and height of src\n    const buf1 = Buffer.alloc(wDst2 * hSrc * 4);\n    for (let i = 0; i < hSrc; i++) {\n      for (let j = 0; j < wDst2; j++) {\n        // i in src coords, j in dst coords\n\n        // calculate x in src coords\n        // this interpolation requires 4 sample points and the two inner ones must be real\n        // the outer points can be fudged for the edges.\n        // therefore (wSrc-1)/wDst2\n        const x = (j * (wSrc - 1)) / wDst2;\n        const xPos = Math.floor(x);\n        const t = x - xPos;\n        const srcPos = (i * wSrc + xPos) * 4;\n        const buf1Pos = (i * wDst2 + j) * 4;\n\n        for (let k = 0; k < 4; k++) {\n          const kPos = srcPos + k;\n          const x0 =\n            xPos > 0 ? bufSrc[kPos - 4] : 2 * bufSrc[kPos] - bufSrc[kPos + 4];\n          const x1 = bufSrc[kPos];\n          const x2 = bufSrc[kPos + 4];\n          const x3 =\n            xPos < wSrc - 2\n              ? bufSrc[kPos + 8]\n              : 2 * bufSrc[kPos + 4] - bufSrc[kPos];\n          buf1[buf1Pos + k] = interpolate(x0, x1, x2, x3, t);\n        }\n      }\n    }\n    // this._writeFile(wDst2, hSrc, buf1, \"out/buf1.jpg\");\n\n    // ===========================================================\n    // Pass 2 - interpolate columns\n    // buf2 has width and height of dst2\n    const buf2 = Buffer.alloc(wDst2 * hDst2 * 4);\n    for (let i = 0; i < hDst2; i++) {\n      for (let j = 0; j < wDst2; j++) {\n        // i&j in dst2 coords\n\n        // calculate y in buf1 coords\n        // this interpolation requires 4 sample points and the two inner ones must be real\n        // the outer points can be fudged for the edges.\n        // therefore (hSrc-1)/hDst2\n        const y = (i * (hSrc - 1)) / hDst2;\n        const yPos = Math.floor(y);\n        const t = y - yPos;\n        const buf1Pos = (yPos * wDst2 + j) * 4;\n        const buf2Pos = (i * wDst2 + j) * 4;\n        for (let k = 0; k < 4; k++) {\n          const kPos = buf1Pos + k;\n          const y0 =\n            yPos > 0\n              ? buf1[kPos - wDst2 * 4]\n              : 2 * buf1[kPos] - buf1[kPos + wDst2 * 4];\n          const y1 = buf1[kPos];\n          const y2 = buf1[kPos + wDst2 * 4];\n          const y3 =\n            yPos < hSrc - 2\n              ? buf1[kPos + wDst2 * 8]\n              : 2 * buf1[kPos + wDst2 * 4] - buf1[kPos];\n\n          buf2[buf2Pos + k] = interpolate(y0, y1, y2, y3, t);\n        }\n      }\n    }\n    // this._writeFile(wDst2, hDst2, buf2, \"out/buf2.jpg\");\n\n    // ===========================================================\n    // Pass 3 - scale to dst\n    const m = wM * hM;\n    if (m > 1) {\n      for (let i = 0; i < hDst; i++) {\n        for (let j = 0; j < wDst; j++) {\n          // i&j in dst bounded coords\n          let r = 0;\n          let g = 0;\n          let b = 0;\n          let a = 0;\n          let realColors = 0;\n\n          for (let y = 0; y < hM; y++) {\n            const yPos = i * hM + y;\n\n            for (let x = 0; x < wM; x++) {\n              const xPos = j * wM + x;\n              const xyPos = (yPos * wDst2 + xPos) * 4;\n              const pixelAlpha = buf2[xyPos + 3];\n\n              if (pixelAlpha) {\n                r += buf2[xyPos];\n                g += buf2[xyPos + 1];\n                b += buf2[xyPos + 2];\n                realColors++;\n              }\n\n              a += pixelAlpha;\n            }\n          }\n\n          const pos = (i * wDst + j) * 4;\n          bufDst[pos] = realColors ? Math.round(r / realColors) : 0;\n          bufDst[pos + 1] = realColors ? Math.round(g / realColors) : 0;\n          bufDst[pos + 2] = realColors ? Math.round(b / realColors) : 0;\n          bufDst[pos + 3] = Math.round(a / m);\n        }\n      }\n    } else {\n      // replace dst buffer with buf2\n      dst.data = buf2;\n    }\n  },\n\n  bicubicInterpolation(src, dst, options) {\n    const interpolateCubic = function(x0, x1, x2, x3, t) {\n      const a0 = x3 - x2 - x0 + x1;\n      const a1 = x0 - x1 - a0;\n      const a2 = x2 - x0;\n      const a3 = x1;\n      return Math.max(\n        0,\n        Math.min(255, a0 * (t * t * t) + a1 * (t * t) + a2 * t + a3)\n      );\n    };\n\n    return this._interpolate2D(src, dst, options, interpolateCubic);\n  },\n\n  hermiteInterpolation(src, dst, options) {\n    const interpolateHermite = function(x0, x1, x2, x3, t) {\n      const c0 = x1;\n      const c1 = 0.5 * (x2 - x0);\n      const c2 = x0 - 2.5 * x1 + 2 * x2 - 0.5 * x3;\n      const c3 = 0.5 * (x3 - x0) + 1.5 * (x1 - x2);\n      return Math.max(\n        0,\n        Math.min(255, Math.round(((c3 * t + c2) * t + c1) * t + c0))\n      );\n    };\n\n    return this._interpolate2D(src, dst, options, interpolateHermite);\n  },\n\n  bezierInterpolation(src, dst, options) {\n    // between 2 points y(n), y(n+1), use next points out, y(n-1), y(n+2)\n    // to predict control points (a & b) to be placed at n+0.5\n    //  ya(n) = y(n) + (y(n+1)-y(n-1))/4\n    //  yb(n) = y(n+1) - (y(n+2)-y(n))/4\n    // then use std bezier to interpolate [n,n+1)\n    //  y(n+t) = y(n)*(1-t)^3 + 3 * ya(n)*(1-t)^2*t + 3 * yb(n)*(1-t)*t^2 + y(n+1)*t^3\n    //  note the 3* factor for the two control points\n    // for edge cases, can choose:\n    //  y(-1) = y(0) - 2*(y(1)-y(0))\n    //  y(w) = y(w-1) + 2*(y(w-1)-y(w-2))\n    // but can go with y(-1) = y(0) and y(w) = y(w-1)\n    const interpolateBezier = function(x0, x1, x2, x3, t) {\n      // x1, x2 are the knots, use x0 and x3 to calculate control points\n      const cp1 = x1 + (x2 - x0) / 4;\n      const cp2 = x2 - (x3 - x1) / 4;\n      const nt = 1 - t;\n      const c0 = x1 * nt * nt * nt;\n      const c1 = 3 * cp1 * nt * nt * t;\n      const c2 = 3 * cp2 * nt * t * t;\n      const c3 = x2 * t * t * t;\n      return Math.max(0, Math.min(255, Math.round(c0 + c1 + c2 + c3)));\n    };\n\n    return this._interpolate2D(src, dst, options, interpolateBezier);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}