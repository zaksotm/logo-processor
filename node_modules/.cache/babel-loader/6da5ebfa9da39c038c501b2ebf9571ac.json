{"ast":null,"code":"'use strict';\n\nvar util = require('util');\n\nvar zlib = require('zlib');\n\nvar ChunkStream = require('./chunkstream');\n\nvar FilterAsync = require('./filter-parse-async');\n\nvar Parser = require('./parser');\n\nvar bitmapper = require('./bitmapper');\n\nvar formatNormaliser = require('./format-normaliser');\n\nvar ParserAsync = module.exports = function (options) {\n  ChunkStream.call(this);\n  this._parser = new Parser(options, {\n    read: this.read.bind(this),\n    error: this._handleError.bind(this),\n    metadata: this._handleMetaData.bind(this),\n    gamma: this.emit.bind(this, 'gamma'),\n    palette: this._handlePalette.bind(this),\n    transColor: this._handleTransColor.bind(this),\n    finished: this._finished.bind(this),\n    inflateData: this._inflateData.bind(this),\n    simpleTransparency: this._simpleTransparency.bind(this),\n    headersFinished: this._headersFinished.bind(this)\n  });\n  this._options = options;\n  this.writable = true;\n\n  this._parser.start();\n};\n\nutil.inherits(ParserAsync, ChunkStream);\n\nParserAsync.prototype._handleError = function (err) {\n  this.emit('error', err);\n  this.writable = false;\n  this.destroy();\n\n  if (this._inflate && this._inflate.destroy) {\n    this._inflate.destroy();\n  }\n\n  if (this._filter) {\n    this._filter.destroy(); // For backward compatibility with Node 7 and below.\n    // Suppress errors due to _inflate calling write() even after\n    // it's destroy()'ed.\n\n\n    this._filter.on('error', function () {});\n  }\n\n  this.errord = true;\n};\n\nParserAsync.prototype._inflateData = function (data) {\n  if (!this._inflate) {\n    if (this._bitmapInfo.interlace) {\n      this._inflate = zlib.createInflate();\n\n      this._inflate.on('error', this.emit.bind(this, 'error'));\n\n      this._filter.on('complete', this._complete.bind(this));\n\n      this._inflate.pipe(this._filter);\n    } else {\n      var rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;\n      var imageSize = rowSize * this._bitmapInfo.height;\n      var chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);\n      this._inflate = zlib.createInflate({\n        chunkSize: chunkSize\n      });\n      var leftToInflate = imageSize;\n      var emitError = this.emit.bind(this, 'error');\n\n      this._inflate.on('error', function (err) {\n        if (!leftToInflate) {\n          return;\n        }\n\n        emitError(err);\n      });\n\n      this._filter.on('complete', this._complete.bind(this));\n\n      var filterWrite = this._filter.write.bind(this._filter);\n\n      this._inflate.on('data', function (chunk) {\n        if (!leftToInflate) {\n          return;\n        }\n\n        if (chunk.length > leftToInflate) {\n          chunk = chunk.slice(0, leftToInflate);\n        }\n\n        leftToInflate -= chunk.length;\n        filterWrite(chunk);\n      });\n\n      this._inflate.on('end', this._filter.end.bind(this._filter));\n    }\n  }\n\n  this._inflate.write(data);\n};\n\nParserAsync.prototype._handleMetaData = function (metaData) {\n  this._metaData = metaData;\n  this._bitmapInfo = Object.create(metaData);\n  this._filter = new FilterAsync(this._bitmapInfo);\n};\n\nParserAsync.prototype._handleTransColor = function (transColor) {\n  this._bitmapInfo.transColor = transColor;\n};\n\nParserAsync.prototype._handlePalette = function (palette) {\n  this._bitmapInfo.palette = palette;\n};\n\nParserAsync.prototype._simpleTransparency = function () {\n  this._metaData.alpha = true;\n};\n\nParserAsync.prototype._headersFinished = function () {\n  // Up until this point, we don't know if we have a tRNS chunk (alpha)\n  // so we can't emit metadata any earlier\n  this.emit('metadata', this._metaData);\n};\n\nParserAsync.prototype._finished = function () {\n  if (this.errord) {\n    return;\n  }\n\n  if (!this._inflate) {\n    this.emit('error', 'No Inflate block');\n  } else {\n    // no more data to inflate\n    this._inflate.end();\n  }\n\n  this.destroySoon();\n};\n\nParserAsync.prototype._complete = function (filteredData) {\n  if (this.errord) {\n    return;\n  }\n\n  try {\n    var bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);\n    var normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);\n    bitmapData = null;\n  } catch (ex) {\n    this._handleError(ex);\n\n    return;\n  }\n\n  this.emit('parsed', normalisedBitmapData);\n};","map":{"version":3,"sources":["/Users/zakstratton/Documents/logo-processor/node_modules/pngjs/lib/parser-async.js"],"names":["util","require","zlib","ChunkStream","FilterAsync","Parser","bitmapper","formatNormaliser","ParserAsync","module","exports","options","call","_parser","read","bind","error","_handleError","metadata","_handleMetaData","gamma","emit","palette","_handlePalette","transColor","_handleTransColor","finished","_finished","inflateData","_inflateData","simpleTransparency","_simpleTransparency","headersFinished","_headersFinished","_options","writable","start","inherits","prototype","err","destroy","_inflate","_filter","on","errord","data","_bitmapInfo","interlace","createInflate","_complete","pipe","rowSize","width","bpp","depth","imageSize","height","chunkSize","Math","max","Z_MIN_CHUNK","leftToInflate","emitError","filterWrite","write","chunk","length","slice","end","metaData","_metaData","Object","create","alpha","destroySoon","filteredData","bitmapData","dataToBitMap","normalisedBitmapData","ex"],"mappings":"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","sourcesContent":["'use strict';\n\nvar util = require('util');\nvar zlib = require('zlib');\nvar ChunkStream = require('./chunkstream');\nvar FilterAsync = require('./filter-parse-async');\nvar Parser = require('./parser');\nvar bitmapper = require('./bitmapper');\nvar formatNormaliser = require('./format-normaliser');\n\nvar ParserAsync = module.exports = function(options) {\n  ChunkStream.call(this);\n\n  this._parser = new Parser(options, {\n    read: this.read.bind(this),\n    error: this._handleError.bind(this),\n    metadata: this._handleMetaData.bind(this),\n    gamma: this.emit.bind(this, 'gamma'),\n    palette: this._handlePalette.bind(this),\n    transColor: this._handleTransColor.bind(this),\n    finished: this._finished.bind(this),\n    inflateData: this._inflateData.bind(this),\n    simpleTransparency: this._simpleTransparency.bind(this),\n    headersFinished: this._headersFinished.bind(this)\n  });\n  this._options = options;\n  this.writable = true;\n\n  this._parser.start();\n};\nutil.inherits(ParserAsync, ChunkStream);\n\n\nParserAsync.prototype._handleError = function(err) {\n\n  this.emit('error', err);\n\n  this.writable = false;\n\n  this.destroy();\n\n  if (this._inflate && this._inflate.destroy) {\n    this._inflate.destroy();\n  }\n\n  if (this._filter) {\n    this._filter.destroy();\n    // For backward compatibility with Node 7 and below.\n    // Suppress errors due to _inflate calling write() even after\n    // it's destroy()'ed.\n    this._filter.on('error', function() {});\n  }\n\n  this.errord = true;\n};\n\nParserAsync.prototype._inflateData = function(data) {\n  if (!this._inflate) {\n    if (this._bitmapInfo.interlace) {\n      this._inflate = zlib.createInflate();\n\n      this._inflate.on('error', this.emit.bind(this, 'error'));\n      this._filter.on('complete', this._complete.bind(this));\n\n      this._inflate.pipe(this._filter);\n    }\n    else {\n      var rowSize = ((this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7) >> 3) + 1;\n      var imageSize = rowSize * this._bitmapInfo.height;\n      var chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);\n\n      this._inflate = zlib.createInflate({ chunkSize: chunkSize });\n      var leftToInflate = imageSize;\n\n      var emitError = this.emit.bind(this, 'error');\n      this._inflate.on('error', function(err) {\n        if (!leftToInflate) {\n          return;\n        }\n\n        emitError(err);\n      });\n      this._filter.on('complete', this._complete.bind(this));\n\n      var filterWrite = this._filter.write.bind(this._filter);\n      this._inflate.on('data', function(chunk) {\n        if (!leftToInflate) {\n          return;\n        }\n\n        if (chunk.length > leftToInflate) {\n          chunk = chunk.slice(0, leftToInflate);\n        }\n\n        leftToInflate -= chunk.length;\n\n        filterWrite(chunk);\n      });\n\n      this._inflate.on('end', this._filter.end.bind(this._filter));\n    }\n  }\n  this._inflate.write(data);\n};\n\nParserAsync.prototype._handleMetaData = function(metaData) {\n  this._metaData = metaData;\n  this._bitmapInfo = Object.create(metaData);\n\n  this._filter = new FilterAsync(this._bitmapInfo);\n};\n\nParserAsync.prototype._handleTransColor = function(transColor) {\n  this._bitmapInfo.transColor = transColor;\n};\n\nParserAsync.prototype._handlePalette = function(palette) {\n  this._bitmapInfo.palette = palette;\n};\n\nParserAsync.prototype._simpleTransparency = function() {\n  this._metaData.alpha = true;\n};\n\nParserAsync.prototype._headersFinished = function() {\n  // Up until this point, we don't know if we have a tRNS chunk (alpha)\n  // so we can't emit metadata any earlier\n  this.emit('metadata', this._metaData);\n};\n\nParserAsync.prototype._finished = function() {\n  if (this.errord) {\n    return;\n  }\n\n  if (!this._inflate) {\n    this.emit('error', 'No Inflate block');\n  }\n  else {\n    // no more data to inflate\n    this._inflate.end();\n  }\n  this.destroySoon();\n};\n\nParserAsync.prototype._complete = function(filteredData) {\n\n  if (this.errord) {\n    return;\n  }\n\n  try {\n    var bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);\n\n    var normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);\n    bitmapData = null;\n  }\n  catch (ex) {\n    this._handleError(ex);\n    return;\n  }\n\n  this.emit('parsed', normalisedBitmapData);\n};\n"]},"metadata":{},"sourceType":"script"}