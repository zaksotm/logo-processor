{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _utils = require(\"@jimp/utils\");\n/**\n * Masks a source image on to this image using average pixel colour. A completely black pixel on the mask will turn a pixel in the image completely transparent.\n * @param {Jimp} src the source Jimp instance\n * @param {number} x the horizontal position to blit the image\n * @param {number} y the vertical position to blit the image\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n\n\nvar _default = function _default() {\n  return {\n    mask: function mask(src) {\n      var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var cb = arguments.length > 3 ? arguments[3] : undefined;\n\n      if (!(src instanceof this.constructor)) {\n        return _utils.throwError.call(this, 'The source must be a Jimp image', cb);\n      }\n\n      if (typeof x !== 'number' || typeof y !== 'number') {\n        return _utils.throwError.call(this, 'x and y must be numbers', cb);\n      } // round input\n\n\n      x = Math.round(x);\n      y = Math.round(y);\n      var w = this.bitmap.width;\n      var h = this.bitmap.height;\n      var baseImage = this;\n      src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function (sx, sy, idx) {\n        var destX = x + sx;\n        var destY = y + sy;\n\n        if (destX >= 0 && destY >= 0 && destX < w && destY < h) {\n          var dstIdx = baseImage.getPixelIndex(destX, destY);\n          var data = this.bitmap.data;\n          var avg = (data[idx + 0] + data[idx + 1] + data[idx + 2]) / 3;\n          baseImage.bitmap.data[dstIdx + 3] *= avg / 255;\n        }\n      });\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    }\n  };\n};\n\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../src/index.js"],"names":["mask","x","y","cb","src","throwError","Math","w","h","baseImage","destX","destY","dstIdx","data","avg","idx"],"mappings":";;;;;;;AAAA,IAAA,MAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAEA;;;;;;;;;;eAQe,SAAA,QAAA,GAAA;AAAA,SAAO;AACpBA,IAAAA,IADoB,EAAA,SAAA,IAAA,CAAA,GAAA,EACQ;AAAA,UAAlBC,CAAkB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAd,CAAc;AAAA,UAAXC,CAAW,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAP,CAAO;AAAA,UAAJC,EAAI,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAA,SAAA;;AAC1B,UAAI,EAAEC,GAAG,YAAY,KAArB,WAAI,CAAJ,EAAwC;AACtC,eAAOC,MAAAA,CAAAA,UAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAAA,iCAAAA,EAAP,EAAOA,CAAP;AACD;;AAED,UAAI,OAAA,CAAA,KAAA,QAAA,IAAyB,OAAA,CAAA,KAA7B,QAAA,EAAoD;AAClD,eAAOA,MAAAA,CAAAA,UAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAAA,yBAAAA,EAAP,EAAOA,CAAP;AANwB,OAAA,CAS1B;;;AACAJ,MAAAA,CAAC,GAAGK,IAAI,CAAJA,KAAAA,CAAJL,CAAIK,CAAJL;AACAC,MAAAA,CAAC,GAAGI,IAAI,CAAJA,KAAAA,CAAJJ,CAAII,CAAJJ;AAEA,UAAMK,CAAC,GAAG,KAAA,MAAA,CAAV,KAAA;AACA,UAAMC,CAAC,GAAG,KAAA,MAAA,CAAV,MAAA;AACA,UAAMC,SAAS,GAAf,IAAA;AAEAL,MAAAA,GAAG,CAAHA,SAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAoBA,GAAG,CAAHA,MAAAA,CAApBA,KAAAA,EAAsCA,GAAG,CAAHA,MAAAA,CAAtCA,MAAAA,EAAyD,UAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAIvD;AACA,YAAMM,KAAK,GAAGT,CAAC,GAAf,EAAA;AACA,YAAMU,KAAK,GAAGT,CAAC,GAAf,EAAA;;AAEA,YAAIQ,KAAK,IAALA,CAAAA,IAAcC,KAAK,IAAnBD,CAAAA,IAA4BA,KAAK,GAAjCA,CAAAA,IAAyCC,KAAK,GAAlD,CAAA,EAAwD;AACtD,cAAMC,MAAM,GAAGH,SAAS,CAATA,aAAAA,CAAAA,KAAAA,EAAf,KAAeA,CAAf;AADsD,cAE9CI,IAF8C,GAErC,KAFqC,MAErC,CAFqC,IAAA;AAGtD,cAAMC,GAAG,GAAG,CAACD,IAAI,CAACE,GAAG,GAARF,CAAI,CAAJA,GAAgBA,IAAI,CAACE,GAAG,GAAxBF,CAAoB,CAApBA,GAAgCA,IAAI,CAACE,GAAG,GAAzC,CAAqC,CAArC,IAAZ,CAAA;AAEAN,UAAAA,SAAS,CAATA,MAAAA,CAAAA,IAAAA,CAAsBG,MAAM,GAA5BH,CAAAA,KAAqCK,GAAG,GAAxCL,GAAAA;AACD;AAdHL,OAAAA;;AAiBA,UAAI,CAAA,GAAA,MAAA,CAAA,aAAA,EAAJ,EAAI,CAAJ,EAAuB;AACrBD,QAAAA,EAAE,CAAFA,IAAAA,CAAAA,IAAAA,EAAAA,IAAAA,EAAAA,IAAAA;AACD;;AAED,aAAA,IAAA;AACD;AAxCmB,GAAP","sourcesContent":["import { isNodePattern, throwError } from '@jimp/utils';\n\n/**\n * Masks a source image on to this image using average pixel colour. A completely black pixel on the mask will turn a pixel in the image completely transparent.\n * @param {Jimp} src the source Jimp instance\n * @param {number} x the horizontal position to blit the image\n * @param {number} y the vertical position to blit the image\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport default () => ({\n  mask(src, x = 0, y = 0, cb) {\n    if (!(src instanceof this.constructor)) {\n      return throwError.call(this, 'The source must be a Jimp image', cb);\n    }\n\n    if (typeof x !== 'number' || typeof y !== 'number') {\n      return throwError.call(this, 'x and y must be numbers', cb);\n    }\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n\n    const w = this.bitmap.width;\n    const h = this.bitmap.height;\n    const baseImage = this;\n\n    src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function(\n      sx,\n      sy,\n      idx\n    ) {\n      const destX = x + sx;\n      const destY = y + sy;\n\n      if (destX >= 0 && destY >= 0 && destX < w && destY < h) {\n        const dstIdx = baseImage.getPixelIndex(destX, destY);\n        const { data } = this.bitmap;\n        const avg = (data[idx + 0] + data[idx + 1] + data[idx + 2]) / 3;\n\n        baseImage.bitmap.data[dstIdx + 3] *= avg / 255;\n      }\n    });\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  }\n});\n"]},"metadata":{},"sourceType":"script"}