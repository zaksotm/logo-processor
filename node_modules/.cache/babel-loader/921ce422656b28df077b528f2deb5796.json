{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _utils = require(\"@jimp/utils\");\n/**\n * Scale the image to the given width and height keeping the aspect ratio. Some parts of the image may be letter boxed.\n * @param {number} w the width to resize the image to\n * @param {number} h the height to resize the image to\n * @param {number} alignBits (optional) A bitmask for horizontal and vertical alignment\n * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n\n\nvar _default = function _default() {\n  return {\n    contain: function contain(w, h, alignBits, mode, cb) {\n      if (typeof w !== 'number' || typeof h !== 'number') {\n        return _utils.throwError.call(this, 'w and h must be numbers', cb);\n      } // permit any sort of optional parameters combination\n\n\n      if (typeof alignBits === 'string') {\n        if (typeof mode === 'function' && typeof cb === 'undefined') cb = mode;\n        mode = alignBits;\n        alignBits = null;\n      }\n\n      if (typeof alignBits === 'function') {\n        if (typeof cb === 'undefined') cb = alignBits;\n        mode = null;\n        alignBits = null;\n      }\n\n      if (typeof mode === 'function' && typeof cb === 'undefined') {\n        cb = mode;\n        mode = null;\n      }\n\n      alignBits = alignBits || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE;\n      var hbits = alignBits & (1 << 3) - 1;\n      var vbits = alignBits >> 3; // check if more flags than one is in the bit sets\n\n      if (!(hbits !== 0 && !(hbits & hbits - 1) || vbits !== 0 && !(vbits & vbits - 1))) {\n        return _utils.throwError.call(this, 'only use one flag per alignment direction', cb);\n      }\n\n      var alignH = hbits >> 1; // 0, 1, 2\n\n      var alignV = vbits >> 1; // 0, 1, 2\n\n      var f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width;\n      var c = this.cloneQuiet().scale(f, mode);\n      this.resize(w, h, mode);\n      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        this.bitmap.data.writeUInt32BE(this._background, idx);\n      });\n      this.blit(c, (this.bitmap.width - c.bitmap.width) / 2 * alignH, (this.bitmap.height - c.bitmap.height) / 2 * alignV);\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    }\n  };\n};\n\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../src/index.js"],"names":["contain","throwError","cb","mode","alignBits","hbits","vbits","alignH","alignV","f","w","h","c"],"mappings":"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","sourcesContent":["import { isNodePattern, throwError } from '@jimp/utils';\n\n/**\n * Scale the image to the given width and height keeping the aspect ratio. Some parts of the image may be letter boxed.\n * @param {number} w the width to resize the image to\n * @param {number} h the height to resize the image to\n * @param {number} alignBits (optional) A bitmask for horizontal and vertical alignment\n * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport default () => ({\n  contain(w, h, alignBits, mode, cb) {\n    if (typeof w !== 'number' || typeof h !== 'number') {\n      return throwError.call(this, 'w and h must be numbers', cb);\n    }\n\n    // permit any sort of optional parameters combination\n    if (typeof alignBits === 'string') {\n      if (typeof mode === 'function' && typeof cb === 'undefined') cb = mode;\n      mode = alignBits;\n      alignBits = null;\n    }\n\n    if (typeof alignBits === 'function') {\n      if (typeof cb === 'undefined') cb = alignBits;\n      mode = null;\n      alignBits = null;\n    }\n\n    if (typeof mode === 'function' && typeof cb === 'undefined') {\n      cb = mode;\n      mode = null;\n    }\n\n    alignBits =\n      alignBits ||\n      this.constructor.HORIZONTAL_ALIGN_CENTER |\n        this.constructor.VERTICAL_ALIGN_MIDDLE;\n    const hbits = alignBits & ((1 << 3) - 1);\n    const vbits = alignBits >> 3;\n\n    // check if more flags than one is in the bit sets\n    if (\n      !(\n        (hbits !== 0 && !(hbits & (hbits - 1))) ||\n        (vbits !== 0 && !(vbits & (vbits - 1)))\n      )\n    ) {\n      return throwError.call(\n        this,\n        'only use one flag per alignment direction',\n        cb\n      );\n    }\n\n    const alignH = hbits >> 1; // 0, 1, 2\n    const alignV = vbits >> 1; // 0, 1, 2\n\n    const f =\n      w / h > this.bitmap.width / this.bitmap.height\n        ? h / this.bitmap.height\n        : w / this.bitmap.width;\n    const c = this.cloneQuiet().scale(f, mode);\n\n    this.resize(w, h, mode);\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n      x,\n      y,\n      idx\n    ) {\n      this.bitmap.data.writeUInt32BE(this._background, idx);\n    });\n    this.blit(\n      c,\n      ((this.bitmap.width - c.bitmap.width) / 2) * alignH,\n      ((this.bitmap.height - c.bitmap.height) / 2) * alignV\n    );\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  }\n});\n"]},"metadata":{},"sourceType":"script"}