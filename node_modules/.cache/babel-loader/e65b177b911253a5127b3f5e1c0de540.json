{"ast":null,"code":"'use strict';\n\nvar constants = require('./constants');\n\nmodule.exports = function (dataIn, width, height, options) {\n  var outHasAlpha = [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;\n\n  if (options.colorType === options.inputColorType) {\n    var bigEndian = function () {\n      var buffer = new ArrayBuffer(2);\n      new DataView(buffer).setInt16(0, 256, true\n      /* littleEndian */\n      ); // Int16Array uses the platform's endianness.\n\n      return new Int16Array(buffer)[0] !== 256;\n    }(); // If no need to convert to grayscale and alpha is present/absent in both, take a fast route\n\n\n    if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {\n      return dataIn;\n    }\n  } // map to a UInt16 array if data is 16bit, fix endianness below\n\n\n  var data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);\n  var maxValue = 255;\n  var inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];\n\n  if (inBpp === 4 && !options.inputHasAlpha) {\n    inBpp = 3;\n  }\n\n  var outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];\n\n  if (options.bitDepth === 16) {\n    maxValue = 65535;\n    outBpp *= 2;\n  }\n\n  var outData = new Buffer(width * height * outBpp);\n  var inIndex = 0;\n  var outIndex = 0;\n  var bgColor = options.bgColor || {};\n\n  if (bgColor.red === undefined) {\n    bgColor.red = maxValue;\n  }\n\n  if (bgColor.green === undefined) {\n    bgColor.green = maxValue;\n  }\n\n  if (bgColor.blue === undefined) {\n    bgColor.blue = maxValue;\n  }\n\n  function getRGBA() {\n    var red;\n    var green;\n    var blue;\n    var alpha = maxValue;\n\n    switch (options.inputColorType) {\n      case constants.COLORTYPE_COLOR_ALPHA:\n        alpha = data[inIndex + 3];\n        red = data[inIndex];\n        green = data[inIndex + 1];\n        blue = data[inIndex + 2];\n        break;\n\n      case constants.COLORTYPE_COLOR:\n        red = data[inIndex];\n        green = data[inIndex + 1];\n        blue = data[inIndex + 2];\n        break;\n\n      case constants.COLORTYPE_ALPHA:\n        alpha = data[inIndex + 1];\n        red = data[inIndex];\n        green = red;\n        blue = red;\n        break;\n\n      case constants.COLORTYPE_GRAYSCALE:\n        red = data[inIndex];\n        green = red;\n        blue = red;\n        break;\n\n      default:\n        throw new Error('input color type:' + options.inputColorType + ' is not supported at present');\n    }\n\n    if (options.inputHasAlpha) {\n      if (!outHasAlpha) {\n        alpha /= maxValue;\n        red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);\n        green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);\n        blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);\n      }\n    }\n\n    return {\n      red: red,\n      green: green,\n      blue: blue,\n      alpha: alpha\n    };\n  }\n\n  for (var y = 0; y < height; y++) {\n    for (var x = 0; x < width; x++) {\n      var rgba = getRGBA(data, inIndex);\n\n      switch (options.colorType) {\n        case constants.COLORTYPE_COLOR_ALPHA:\n        case constants.COLORTYPE_COLOR:\n          if (options.bitDepth === 8) {\n            outData[outIndex] = rgba.red;\n            outData[outIndex + 1] = rgba.green;\n            outData[outIndex + 2] = rgba.blue;\n\n            if (outHasAlpha) {\n              outData[outIndex + 3] = rgba.alpha;\n            }\n          } else {\n            outData.writeUInt16BE(rgba.red, outIndex);\n            outData.writeUInt16BE(rgba.green, outIndex + 2);\n            outData.writeUInt16BE(rgba.blue, outIndex + 4);\n\n            if (outHasAlpha) {\n              outData.writeUInt16BE(rgba.alpha, outIndex + 6);\n            }\n          }\n\n          break;\n\n        case constants.COLORTYPE_ALPHA:\n        case constants.COLORTYPE_GRAYSCALE:\n          // Convert to grayscale and alpha\n          var grayscale = (rgba.red + rgba.green + rgba.blue) / 3;\n\n          if (options.bitDepth === 8) {\n            outData[outIndex] = grayscale;\n\n            if (outHasAlpha) {\n              outData[outIndex + 1] = rgba.alpha;\n            }\n          } else {\n            outData.writeUInt16BE(grayscale, outIndex);\n\n            if (outHasAlpha) {\n              outData.writeUInt16BE(rgba.alpha, outIndex + 2);\n            }\n          }\n\n          break;\n\n        default:\n          throw new Error('unrecognised color Type ' + options.colorType);\n      }\n\n      inIndex += inBpp;\n      outIndex += outBpp;\n    }\n  }\n\n  return outData;\n};","map":{"version":3,"sources":["/Users/zakstratton/Documents/logo-processor/node_modules/pngjs/lib/bitpacker.js"],"names":["constants","require","module","exports","dataIn","width","height","options","outHasAlpha","COLORTYPE_COLOR_ALPHA","COLORTYPE_ALPHA","indexOf","colorType","inputColorType","bigEndian","buffer","ArrayBuffer","DataView","setInt16","Int16Array","bitDepth","data","Uint16Array","maxValue","inBpp","COLORTYPE_TO_BPP_MAP","inputHasAlpha","outBpp","outData","Buffer","inIndex","outIndex","bgColor","red","undefined","green","blue","getRGBA","alpha","COLORTYPE_COLOR","COLORTYPE_GRAYSCALE","Error","Math","min","max","round","y","x","rgba","writeUInt16BE","grayscale"],"mappings":"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","sourcesContent":["'use strict';\n\nvar constants = require('./constants');\n\nmodule.exports = function(dataIn, width, height, options) {\n  var outHasAlpha = [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;\n  if (options.colorType === options.inputColorType) {\n    var bigEndian = (function() {\n      var buffer = new ArrayBuffer(2);\n      new DataView(buffer).setInt16(0, 256, true /* littleEndian */);\n      // Int16Array uses the platform's endianness.\n      return new Int16Array(buffer)[0] !== 256;\n    })();\n    // If no need to convert to grayscale and alpha is present/absent in both, take a fast route\n    if (options.bitDepth === 8 || (options.bitDepth === 16 && bigEndian)) {\n      return dataIn;\n    }\n  }\n\n  // map to a UInt16 array if data is 16bit, fix endianness below\n  var data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);\n\n  var maxValue = 255;\n  var inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];\n  if (inBpp === 4 && !options.inputHasAlpha) {\n    inBpp = 3;\n  }\n  var outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];\n  if (options.bitDepth === 16) {\n    maxValue = 65535;\n    outBpp *= 2;\n  }\n  var outData = new Buffer(width * height * outBpp);\n\n  var inIndex = 0;\n  var outIndex = 0;\n\n  var bgColor = options.bgColor || {};\n  if (bgColor.red === undefined) {\n    bgColor.red = maxValue;\n  }\n  if (bgColor.green === undefined) {\n    bgColor.green = maxValue;\n  }\n  if (bgColor.blue === undefined) {\n    bgColor.blue = maxValue;\n  }\n\n  function getRGBA() {\n    var red;\n    var green;\n    var blue;\n    var alpha = maxValue;\n    switch (options.inputColorType) {\n      case constants.COLORTYPE_COLOR_ALPHA:\n        alpha = data[inIndex + 3];\n        red = data[inIndex];\n        green = data[inIndex + 1];\n        blue = data[inIndex + 2];\n        break;\n      case constants.COLORTYPE_COLOR:\n        red = data[inIndex];\n        green = data[inIndex + 1];\n        blue = data[inIndex + 2];\n        break;\n      case constants.COLORTYPE_ALPHA:\n        alpha = data[inIndex + 1];\n        red = data[inIndex];\n        green = red;\n        blue = red;\n        break;\n      case constants.COLORTYPE_GRAYSCALE:\n        red = data[inIndex];\n        green = red;\n        blue = red;\n        break;\n      default:\n        throw new Error('input color type:' + options.inputColorType + ' is not supported at present');\n    }\n\n    if (options.inputHasAlpha) {\n      if (!outHasAlpha) {\n        alpha /= maxValue;\n        red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);\n        green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);\n        blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);\n      }\n    }\n    return { red: red, green: green, blue: blue, alpha: alpha };\n  }\n\n  for (var y = 0; y < height; y++) {\n    for (var x = 0; x < width; x++) {\n      var rgba = getRGBA(data, inIndex);\n\n      switch (options.colorType) {\n        case constants.COLORTYPE_COLOR_ALPHA:\n        case constants.COLORTYPE_COLOR:\n          if (options.bitDepth === 8) {\n            outData[outIndex] = rgba.red;\n            outData[outIndex + 1] = rgba.green;\n            outData[outIndex + 2] = rgba.blue;\n            if (outHasAlpha) {\n              outData[outIndex + 3] = rgba.alpha;\n            }\n          }\n          else {\n            outData.writeUInt16BE(rgba.red, outIndex);\n            outData.writeUInt16BE(rgba.green, outIndex + 2);\n            outData.writeUInt16BE(rgba.blue, outIndex + 4);\n            if (outHasAlpha) {\n              outData.writeUInt16BE(rgba.alpha, outIndex + 6);\n            }\n          }\n          break;\n        case constants.COLORTYPE_ALPHA:\n        case constants.COLORTYPE_GRAYSCALE:\n          // Convert to grayscale and alpha\n          var grayscale = (rgba.red + rgba.green + rgba.blue) / 3;\n          if (options.bitDepth === 8) {\n            outData[outIndex] = grayscale;\n            if (outHasAlpha) {\n              outData[outIndex + 1] = rgba.alpha;\n            }\n          }\n          else {\n            outData.writeUInt16BE(grayscale, outIndex);\n            if (outHasAlpha) {\n              outData.writeUInt16BE(rgba.alpha, outIndex + 2);\n            }\n          }\n          break;\n        default:\n          throw new Error('unrecognised color Type ' + options.colorType);\n      }\n\n      inIndex += inBpp;\n      outIndex += outBpp;\n    }\n  }\n\n  return outData;\n};\n"]},"metadata":{},"sourceType":"script"}