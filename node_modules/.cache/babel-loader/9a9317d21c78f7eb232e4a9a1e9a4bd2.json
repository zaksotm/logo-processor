{"ast":null,"code":"/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, vars: true, white: true */\nmodule.exports = {\n  parseSections: function (stream, iterator) {\n    var len, markerType;\n    stream.setBigEndian(true); //stop reading the stream at the SOS (Start of Stream) marker,\n    //because its length is not stored in the header so we can't\n    //know where to jump to. The only marker after that is just EOI (End Of Image) anyway\n\n    while (stream.remainingLength() > 0 && markerType !== 0xDA) {\n      if (stream.nextUInt8() !== 0xFF) {\n        throw new Error('Invalid JPEG section offset');\n      }\n\n      markerType = stream.nextUInt8(); //don't read size from markers that have no datas\n\n      if (markerType >= 0xD0 && markerType <= 0xD9 || markerType === 0xDA) {\n        len = 0;\n      } else {\n        len = stream.nextUInt16() - 2;\n      }\n\n      iterator(markerType, stream.branch(0, len));\n      stream.skip(len);\n    }\n  },\n  //stream should be located after SOF section size and in big endian mode, like passed to parseSections iterator\n  getSizeFromSOFSection: function (stream) {\n    stream.skip(1);\n    return {\n      height: stream.nextUInt16(),\n      width: stream.nextUInt16()\n    };\n  },\n  getSectionName: function (markerType) {\n    var name, index;\n\n    switch (markerType) {\n      case 0xD8:\n        name = 'SOI';\n        break;\n\n      case 0xC4:\n        name = 'DHT';\n        break;\n\n      case 0xDB:\n        name = 'DQT';\n        break;\n\n      case 0xDD:\n        name = 'DRI';\n        break;\n\n      case 0xDA:\n        name = 'SOS';\n        break;\n\n      case 0xFE:\n        name = 'COM';\n        break;\n\n      case 0xD9:\n        name = 'EOI';\n        break;\n\n      default:\n        if (markerType >= 0xE0 && markerType <= 0xEF) {\n          name = 'APP';\n          index = markerType - 0xE0;\n        } else if (markerType >= 0xC0 && markerType <= 0xCF && markerType !== 0xC4 && markerType !== 0xC8 && markerType !== 0xCC) {\n          name = 'SOF';\n          index = markerType - 0xC0;\n        } else if (markerType >= 0xD0 && markerType <= 0xD7) {\n          name = 'RST';\n          index = markerType - 0xD0;\n        }\n\n        break;\n    }\n\n    var nameStruct = {\n      name: name\n    };\n\n    if (typeof index === 'number') {\n      nameStruct.index = index;\n    }\n\n    return nameStruct;\n  }\n};","map":{"version":3,"sources":["/Users/zakstratton/Documents/logo-processor/node_modules/exif-parser/lib/jpeg.js"],"names":["module","exports","parseSections","stream","iterator","len","markerType","setBigEndian","remainingLength","nextUInt8","Error","nextUInt16","branch","skip","getSizeFromSOFSection","height","width","getSectionName","name","index","nameStruct"],"mappings":"AAAA;AAEAA,MAAM,CAACC,OAAP,GAAiB;AAChBC,EAAAA,aAAa,EAAE,UAASC,MAAT,EAAiBC,QAAjB,EAA2B;AACzC,QAAIC,GAAJ,EAASC,UAAT;AACAH,IAAAA,MAAM,CAACI,YAAP,CAAoB,IAApB,EAFyC,CAGzC;AACA;AACA;;AACA,WAAMJ,MAAM,CAACK,eAAP,KAA2B,CAA3B,IAAgCF,UAAU,KAAK,IAArD,EAA2D;AAC1D,UAAGH,MAAM,CAACM,SAAP,OAAuB,IAA1B,EAAgC;AAC/B,cAAM,IAAIC,KAAJ,CAAU,6BAAV,CAAN;AACA;;AACDJ,MAAAA,UAAU,GAAGH,MAAM,CAACM,SAAP,EAAb,CAJ0D,CAK1D;;AACA,UAAIH,UAAU,IAAI,IAAd,IAAsBA,UAAU,IAAI,IAArC,IAA8CA,UAAU,KAAK,IAAhE,EAAsE;AACrED,QAAAA,GAAG,GAAG,CAAN;AACA,OAFD,MAEO;AACNA,QAAAA,GAAG,GAAGF,MAAM,CAACQ,UAAP,KAAsB,CAA5B;AACA;;AACDP,MAAAA,QAAQ,CAACE,UAAD,EAAaH,MAAM,CAACS,MAAP,CAAc,CAAd,EAAiBP,GAAjB,CAAb,CAAR;AACAF,MAAAA,MAAM,CAACU,IAAP,CAAYR,GAAZ;AACA;AACD,GArBe;AAsBhB;AACAS,EAAAA,qBAAqB,EAAE,UAASX,MAAT,EAAiB;AACvCA,IAAAA,MAAM,CAACU,IAAP,CAAY,CAAZ;AACA,WAAO;AACNE,MAAAA,MAAM,EAAEZ,MAAM,CAACQ,UAAP,EADF;AAENK,MAAAA,KAAK,EAAEb,MAAM,CAACQ,UAAP;AAFD,KAAP;AAIA,GA7Be;AA8BhBM,EAAAA,cAAc,EAAE,UAASX,UAAT,EAAqB;AACpC,QAAIY,IAAJ,EAAUC,KAAV;;AACA,YAAOb,UAAP;AACC,WAAK,IAAL;AAAWY,QAAAA,IAAI,GAAG,KAAP;AAAc;;AACzB,WAAK,IAAL;AAAWA,QAAAA,IAAI,GAAG,KAAP;AAAc;;AACzB,WAAK,IAAL;AAAWA,QAAAA,IAAI,GAAG,KAAP;AAAc;;AACzB,WAAK,IAAL;AAAWA,QAAAA,IAAI,GAAG,KAAP;AAAc;;AACzB,WAAK,IAAL;AAAWA,QAAAA,IAAI,GAAG,KAAP;AAAc;;AACzB,WAAK,IAAL;AAAWA,QAAAA,IAAI,GAAG,KAAP;AAAc;;AACzB,WAAK,IAAL;AAAWA,QAAAA,IAAI,GAAG,KAAP;AAAc;;AACzB;AACC,YAAGZ,UAAU,IAAI,IAAd,IAAsBA,UAAU,IAAI,IAAvC,EAA6C;AAC5CY,UAAAA,IAAI,GAAG,KAAP;AACAC,UAAAA,KAAK,GAAGb,UAAU,GAAG,IAArB;AACA,SAHD,MAIK,IAAGA,UAAU,IAAI,IAAd,IAAsBA,UAAU,IAAI,IAApC,IAA4CA,UAAU,KAAK,IAA3D,IAAmEA,UAAU,KAAK,IAAlF,IAA0FA,UAAU,KAAK,IAA5G,EAAkH;AACtHY,UAAAA,IAAI,GAAG,KAAP;AACAC,UAAAA,KAAK,GAAGb,UAAU,GAAG,IAArB;AACA,SAHI,MAIA,IAAGA,UAAU,IAAI,IAAd,IAAsBA,UAAU,IAAI,IAAvC,EAA6C;AACjDY,UAAAA,IAAI,GAAG,KAAP;AACAC,UAAAA,KAAK,GAAGb,UAAU,GAAG,IAArB;AACA;;AACD;AArBF;;AAuBA,QAAIc,UAAU,GAAG;AAChBF,MAAAA,IAAI,EAAEA;AADU,KAAjB;;AAGA,QAAG,OAAOC,KAAP,KAAiB,QAApB,EAA8B;AAC7BC,MAAAA,UAAU,CAACD,KAAX,GAAmBA,KAAnB;AACA;;AACD,WAAOC,UAAP;AACA;AA9De,CAAjB","sourcesContent":["/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, vars: true, white: true */\n\nmodule.exports = {\n\tparseSections: function(stream, iterator) {\n\t\tvar len, markerType;\n\t\tstream.setBigEndian(true);\n\t\t//stop reading the stream at the SOS (Start of Stream) marker,\n\t\t//because its length is not stored in the header so we can't\n\t\t//know where to jump to. The only marker after that is just EOI (End Of Image) anyway\n\t\twhile(stream.remainingLength() > 0 && markerType !== 0xDA) {\n\t\t\tif(stream.nextUInt8() !== 0xFF) {\n\t\t\t\tthrow new Error('Invalid JPEG section offset');\n\t\t\t}\n\t\t\tmarkerType = stream.nextUInt8();\n\t\t\t//don't read size from markers that have no datas\n\t\t\tif((markerType >= 0xD0 && markerType <= 0xD9) || markerType === 0xDA) {\n\t\t\t\tlen = 0;\n\t\t\t} else {\n\t\t\t\tlen = stream.nextUInt16() - 2;\n\t\t\t}\n\t\t\titerator(markerType, stream.branch(0, len));\n\t\t\tstream.skip(len);\n\t\t}\n\t},\n\t//stream should be located after SOF section size and in big endian mode, like passed to parseSections iterator\n\tgetSizeFromSOFSection: function(stream) {\n\t\tstream.skip(1);\n\t\treturn {\n\t\t\theight: stream.nextUInt16(),\n\t\t\twidth: stream.nextUInt16()\n\t\t};\n\t},\n\tgetSectionName: function(markerType) {\n\t\tvar name, index;\n\t\tswitch(markerType) {\n\t\t\tcase 0xD8: name = 'SOI'; break;\n\t\t\tcase 0xC4: name = 'DHT'; break;\n\t\t\tcase 0xDB: name = 'DQT'; break;\n\t\t\tcase 0xDD: name = 'DRI'; break;\n\t\t\tcase 0xDA: name = 'SOS'; break;\n\t\t\tcase 0xFE: name = 'COM'; break;\n\t\t\tcase 0xD9: name = 'EOI'; break;\n\t\t\tdefault:\n\t\t\t\tif(markerType >= 0xE0 && markerType <= 0xEF) {\n\t\t\t\t\tname = 'APP';\n\t\t\t\t\tindex = markerType - 0xE0;\n\t\t\t\t}\n\t\t\t\telse if(markerType >= 0xC0 && markerType <= 0xCF && markerType !== 0xC4 && markerType !== 0xC8 && markerType !== 0xCC) {\n\t\t\t\t\tname = 'SOF';\n\t\t\t\t\tindex = markerType - 0xC0;\n\t\t\t\t}\n\t\t\t\telse if(markerType >= 0xD0 && markerType <= 0xD7) {\n\t\t\t\t\tname = 'RST';\n\t\t\t\t\tindex = markerType - 0xD0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tvar nameStruct = {\n\t\t\tname: name\n\t\t};\n\t\tif(typeof index === 'number') {\n\t\t\tnameStruct.index = index;\n\t\t}\n\t\treturn nameStruct;\n\t}\n};"]},"metadata":{},"sourceType":"script"}