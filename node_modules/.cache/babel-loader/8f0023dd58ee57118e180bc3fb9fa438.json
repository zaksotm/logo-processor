{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _utils = require(\"@jimp/utils\");\n/**\n * Displaces the image based on the provided displacement map\n * @param {object} map the source Jimp instance\n * @param {number} offset the maximum displacement value\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n\n\nvar _default = function _default() {\n  return {\n    displace: function displace(map, offset, cb) {\n      if ((0, _typeof2[\"default\"])(map) !== 'object' || map.constructor !== this.constructor) {\n        return _utils.throwError.call(this, 'The source must be a Jimp image', cb);\n      }\n\n      if (typeof offset !== 'number') {\n        return _utils.throwError.call(this, 'factor must be a number', cb);\n      }\n\n      var source = this.cloneQuiet();\n      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        var displacement = map.bitmap.data[idx] / 256 * offset;\n        displacement = Math.round(displacement);\n        var ids = this.getPixelIndex(x + displacement, y);\n        this.bitmap.data[ids] = source.bitmap.data[idx];\n        this.bitmap.data[ids + 1] = source.bitmap.data[idx + 1];\n        this.bitmap.data[ids + 2] = source.bitmap.data[idx + 2];\n      });\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    }\n  };\n};\n\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../src/index.js"],"names":["displace","map","throwError","source","displacement","Math","ids","x","idx","cb"],"mappings":";;;;;;;;;;;AAAA,IAAA,MAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAEA;;;;;;;;;eAOe,SAAA,QAAA,GAAA;AAAA,SAAO;AACpBA,IAAAA,QADoB,EAAA,SAAA,QAAA,CAAA,GAAA,EAAA,MAAA,EAAA,EAAA,EACM;AACxB,UAAI,CAAA,GAAA,QAAA,CAAA,SAAA,CAAA,EAAA,GAAA,MAAA,QAAA,IAA2BC,GAAG,CAAHA,WAAAA,KAAoB,KAAnD,WAAA,EAAqE;AACnE,eAAOC,MAAAA,CAAAA,UAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAAA,iCAAAA,EAAP,EAAOA,CAAP;AACD;;AAED,UAAI,OAAA,MAAA,KAAJ,QAAA,EAAgC;AAC9B,eAAOA,MAAAA,CAAAA,UAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAAA,yBAAAA,EAAP,EAAOA,CAAP;AACD;;AAED,UAAMC,MAAM,GAAG,KAAf,UAAe,EAAf;AACA,WAAA,SAAA,CAAA,CAAA,EAAA,CAAA,EAAqB,KAAA,MAAA,CAArB,KAAA,EAAwC,KAAA,MAAA,CAAxC,MAAA,EAA4D,UAAA,CAAA,EAAA,CAAA,EAAA,GAAA,EAI1D;AACA,YAAIC,YAAY,GAAIH,GAAG,CAAHA,MAAAA,CAAAA,IAAAA,CAAAA,GAAAA,IAAD,GAACA,GAApB,MAAA;AACAG,QAAAA,YAAY,GAAGC,IAAI,CAAJA,KAAAA,CAAfD,YAAeC,CAAfD;AAEA,YAAME,GAAG,GAAG,KAAA,aAAA,CAAmBC,CAAC,GAApB,YAAA,EAAZ,CAAY,CAAZ;AACA,aAAA,MAAA,CAAA,IAAA,CAAA,GAAA,IAAwBJ,MAAM,CAANA,MAAAA,CAAAA,IAAAA,CAAxB,GAAwBA,CAAxB;AACA,aAAA,MAAA,CAAA,IAAA,CAAiBG,GAAG,GAApB,CAAA,IAA4BH,MAAM,CAANA,MAAAA,CAAAA,IAAAA,CAAmBK,GAAG,GAAlD,CAA4BL,CAA5B;AACA,aAAA,MAAA,CAAA,IAAA,CAAiBG,GAAG,GAApB,CAAA,IAA4BH,MAAM,CAANA,MAAAA,CAAAA,IAAAA,CAAmBK,GAAG,GAAlD,CAA4BL,CAA5B;AAXF,OAAA;;AAcA,UAAI,CAAA,GAAA,MAAA,CAAA,aAAA,EAAJ,EAAI,CAAJ,EAAuB;AACrBM,QAAAA,EAAE,CAAFA,IAAAA,CAAAA,IAAAA,EAAAA,IAAAA,EAAAA,IAAAA;AACD;;AAED,aAAA,IAAA;AACD;AA9BmB,GAAP","sourcesContent":["import { isNodePattern, throwError } from '@jimp/utils';\n\n/**\n * Displaces the image based on the provided displacement map\n * @param {object} map the source Jimp instance\n * @param {number} offset the maximum displacement value\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport default () => ({\n  displace(map, offset, cb) {\n    if (typeof map !== 'object' || map.constructor !== this.constructor) {\n      return throwError.call(this, 'The source must be a Jimp image', cb);\n    }\n\n    if (typeof offset !== 'number') {\n      return throwError.call(this, 'factor must be a number', cb);\n    }\n\n    const source = this.cloneQuiet();\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n      x,\n      y,\n      idx\n    ) {\n      let displacement = (map.bitmap.data[idx] / 256) * offset;\n      displacement = Math.round(displacement);\n\n      const ids = this.getPixelIndex(x + displacement, y);\n      this.bitmap.data[ids] = source.bitmap.data[idx];\n      this.bitmap.data[ids + 1] = source.bitmap.data[idx + 1];\n      this.bitmap.data[ids + 2] = source.bitmap.data[idx + 2];\n    });\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  }\n});\n"]},"metadata":{},"sourceType":"script"}