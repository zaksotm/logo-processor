{"ast":null,"code":"module.exports = function parseBMFontAscii(data) {\n  if (!data) throw new Error('no data provided');\n  data = data.toString().trim();\n  var output = {\n    pages: [],\n    chars: [],\n    kernings: []\n  };\n  var lines = data.split(/\\r\\n?|\\n/g);\n  if (lines.length === 0) throw new Error('no data in BMFont file');\n\n  for (var i = 0; i < lines.length; i++) {\n    var lineData = splitLine(lines[i], i);\n    if (!lineData) //skip empty lines\n      continue;\n\n    if (lineData.key === 'page') {\n      if (typeof lineData.data.id !== 'number') throw new Error('malformed file at line ' + i + ' -- needs page id=N');\n      if (typeof lineData.data.file !== 'string') throw new Error('malformed file at line ' + i + ' -- needs page file=\"path\"');\n      output.pages[lineData.data.id] = lineData.data.file;\n    } else if (lineData.key === 'chars' || lineData.key === 'kernings') {//... do nothing for these two ...\n    } else if (lineData.key === 'char') {\n      output.chars.push(lineData.data);\n    } else if (lineData.key === 'kerning') {\n      output.kernings.push(lineData.data);\n    } else {\n      output[lineData.key] = lineData.data;\n    }\n  }\n\n  return output;\n};\n\nfunction splitLine(line, idx) {\n  line = line.replace(/\\t+/g, ' ').trim();\n  if (!line) return null;\n  var space = line.indexOf(' ');\n  if (space === -1) throw new Error(\"no named row at line \" + idx);\n  var key = line.substring(0, space);\n  line = line.substring(space + 1); //clear \"letter\" field as it is non-standard and\n  //requires additional complexity to parse \" / = symbols\n\n  line = line.replace(/letter=[\\'\\\"]\\S+[\\'\\\"]/gi, '');\n  line = line.split(\"=\");\n  line = line.map(function (str) {\n    return str.trim().match(/(\".*?\"|[^\"\\s]+)+(?=\\s*|\\s*$)/g);\n  });\n  var data = [];\n\n  for (var i = 0; i < line.length; i++) {\n    var dt = line[i];\n\n    if (i === 0) {\n      data.push({\n        key: dt[0],\n        data: \"\"\n      });\n    } else if (i === line.length - 1) {\n      data[data.length - 1].data = parseData(dt[0]);\n    } else {\n      data[data.length - 1].data = parseData(dt[0]);\n      data.push({\n        key: dt[1],\n        data: \"\"\n      });\n    }\n  }\n\n  var out = {\n    key: key,\n    data: {}\n  };\n  data.forEach(function (v) {\n    out.data[v.key] = v.data;\n  });\n  return out;\n}\n\nfunction parseData(data) {\n  if (!data || data.length === 0) return \"\";\n  if (data.indexOf('\"') === 0 || data.indexOf(\"'\") === 0) return data.substring(1, data.length - 1);\n  if (data.indexOf(',') !== -1) return parseIntList(data);\n  return parseInt(data, 10);\n}\n\nfunction parseIntList(data) {\n  return data.split(',').map(function (val) {\n    return parseInt(val, 10);\n  });\n}","map":{"version":3,"sources":["/Users/zakstratton/Documents/logo-processor/node_modules/parse-bmfont-ascii/index.js"],"names":["module","exports","parseBMFontAscii","data","Error","toString","trim","output","pages","chars","kernings","lines","split","length","i","lineData","splitLine","key","id","file","push","line","idx","replace","space","indexOf","substring","map","str","match","dt","parseData","out","forEach","v","parseIntList","parseInt","val"],"mappings":"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","sourcesContent":["module.exports = function parseBMFontAscii(data) {\n  if (!data)\n    throw new Error('no data provided')\n  data = data.toString().trim()\n\n  var output = {\n    pages: [],\n    chars: [],\n    kernings: []\n  }\n\n  var lines = data.split(/\\r\\n?|\\n/g)\n\n  if (lines.length === 0)\n    throw new Error('no data in BMFont file')\n\n  for (var i = 0; i < lines.length; i++) {\n    var lineData = splitLine(lines[i], i)\n    if (!lineData) //skip empty lines\n      continue\n\n    if (lineData.key === 'page') {\n      if (typeof lineData.data.id !== 'number')\n        throw new Error('malformed file at line ' + i + ' -- needs page id=N')\n      if (typeof lineData.data.file !== 'string')\n        throw new Error('malformed file at line ' + i + ' -- needs page file=\"path\"')\n      output.pages[lineData.data.id] = lineData.data.file\n    } else if (lineData.key === 'chars' || lineData.key === 'kernings') {\n      //... do nothing for these two ...\n    } else if (lineData.key === 'char') {\n      output.chars.push(lineData.data)\n    } else if (lineData.key === 'kerning') {\n      output.kernings.push(lineData.data)\n    } else {\n      output[lineData.key] = lineData.data\n    }\n  }\n\n  return output\n}\n\nfunction splitLine(line, idx) {\n  line = line.replace(/\\t+/g, ' ').trim()\n  if (!line)\n    return null\n\n  var space = line.indexOf(' ')\n  if (space === -1) \n    throw new Error(\"no named row at line \" + idx)\n\n  var key = line.substring(0, space)\n\n  line = line.substring(space + 1)\n  //clear \"letter\" field as it is non-standard and\n  //requires additional complexity to parse \" / = symbols\n  line = line.replace(/letter=[\\'\\\"]\\S+[\\'\\\"]/gi, '')  \n  line = line.split(\"=\")\n  line = line.map(function(str) {\n    return str.trim().match((/(\".*?\"|[^\"\\s]+)+(?=\\s*|\\s*$)/g))\n  })\n\n  var data = []\n  for (var i = 0; i < line.length; i++) {\n    var dt = line[i]\n    if (i === 0) {\n      data.push({\n        key: dt[0],\n        data: \"\"\n      })\n    } else if (i === line.length - 1) {\n      data[data.length - 1].data = parseData(dt[0])\n    } else {\n      data[data.length - 1].data = parseData(dt[0])\n      data.push({\n        key: dt[1],\n        data: \"\"\n      })\n    }\n  }\n\n  var out = {\n    key: key,\n    data: {}\n  }\n\n  data.forEach(function(v) {\n    out.data[v.key] = v.data;\n  })\n\n  return out\n}\n\nfunction parseData(data) {\n  if (!data || data.length === 0)\n    return \"\"\n\n  if (data.indexOf('\"') === 0 || data.indexOf(\"'\") === 0)\n    return data.substring(1, data.length - 1)\n  if (data.indexOf(',') !== -1)\n    return parseIntList(data)\n  return parseInt(data, 10)\n}\n\nfunction parseIntList(data) {\n  return data.split(',').map(function(val) {\n    return parseInt(val, 10)\n  })\n}"]},"metadata":{},"sourceType":"script"}