{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _loadBmfont = _interopRequireDefault(require(\"load-bmfont\"));\n\nvar _utils = require(\"@jimp/utils\");\n\nvar _measureText = require(\"./measure-text\");\n\nfunction xOffsetBasedOnAlignment(constants, font, line, maxWidth, alignment) {\n  if (alignment === constants.HORIZONTAL_ALIGN_LEFT) {\n    return 0;\n  }\n\n  if (alignment === constants.HORIZONTAL_ALIGN_CENTER) {\n    return (maxWidth - (0, _measureText.measureText)(font, line)) / 2;\n  }\n\n  return maxWidth - (0, _measureText.measureText)(font, line);\n}\n\nfunction drawCharacter(image, font, x, y, _char) {\n  if (_char.width > 0 && _char.height > 0) {\n    var characterPage = font.pages[_char.page];\n    image.blit(characterPage, x + _char.xoffset, y + _char.yoffset, _char.x, _char.y, _char.width, _char.height);\n  }\n\n  return image;\n}\n\nfunction printText(font, x, y, text, defaultCharWidth) {\n  for (var i = 0; i < text.length; i++) {\n    var _char2 = void 0;\n\n    if (font.chars[text[i]]) {\n      _char2 = text[i];\n    } else if (/\\s/.test(text[i])) {\n      _char2 = '';\n    } else {\n      _char2 = '?';\n    }\n\n    var fontChar = font.chars[_char2] || {};\n    var fontKerning = font.kernings[_char2];\n    drawCharacter(this, font, x, y, fontChar || {});\n    var kerning = fontKerning && fontKerning[text[i + 1]] ? fontKerning[text[i + 1]] : 0;\n    x += kerning + (fontChar.xadvance || defaultCharWidth);\n  }\n}\n\nfunction splitLines(font, text, maxWidth) {\n  var words = text.split(' ');\n  var lines = [];\n  var currentLine = [];\n  var longestLine = 0;\n  words.forEach(function (word) {\n    var line = [].concat((0, _toConsumableArray2[\"default\"])(currentLine), [word]).join(' ');\n    var length = (0, _measureText.measureText)(font, line);\n\n    if (length <= maxWidth) {\n      if (length > longestLine) {\n        longestLine = length;\n      }\n\n      currentLine.push(word);\n    } else {\n      lines.push(currentLine);\n      currentLine = [word];\n    }\n  });\n  lines.push(currentLine);\n  return {\n    lines: lines,\n    longestLine: longestLine\n  };\n}\n\nfunction loadPages(Jimp, dir, pages) {\n  var newPages = pages.map(function (page) {\n    return Jimp.read(dir + '/' + page);\n  });\n  return Promise.all(newPages);\n}\n\nvar dir = process.env.DIRNAME || \"\".concat(__dirname, \"/../\");\n\nvar _default = function _default() {\n  return {\n    constants: {\n      measureText: _measureText.measureText,\n      measureTextHeight: _measureText.measureTextHeight,\n      FONT_SANS_8_BLACK: _path[\"default\"].join(dir, 'fonts/open-sans/open-sans-8-black/open-sans-8-black.fnt'),\n      FONT_SANS_10_BLACK: _path[\"default\"].join(dir, 'fonts/open-sans/open-sans-10-black/open-sans-10-black.fnt'),\n      FONT_SANS_12_BLACK: _path[\"default\"].join(dir, 'fonts/open-sans/open-sans-12-black/open-sans-12-black.fnt'),\n      FONT_SANS_14_BLACK: _path[\"default\"].join(dir, 'fonts/open-sans/open-sans-14-black/open-sans-14-black.fnt'),\n      FONT_SANS_16_BLACK: _path[\"default\"].join(dir, 'fonts/open-sans/open-sans-16-black/open-sans-16-black.fnt'),\n      FONT_SANS_32_BLACK: _path[\"default\"].join(dir, 'fonts/open-sans/open-sans-32-black/open-sans-32-black.fnt'),\n      FONT_SANS_64_BLACK: _path[\"default\"].join(dir, 'fonts/open-sans/open-sans-64-black/open-sans-64-black.fnt'),\n      FONT_SANS_128_BLACK: _path[\"default\"].join(dir, 'fonts/open-sans/open-sans-128-black/open-sans-128-black.fnt'),\n      FONT_SANS_8_WHITE: _path[\"default\"].join(dir, 'fonts/open-sans/open-sans-8-white/open-sans-8-white.fnt'),\n      FONT_SANS_16_WHITE: _path[\"default\"].join(dir, 'fonts/open-sans/open-sans-16-white/open-sans-16-white.fnt'),\n      FONT_SANS_32_WHITE: _path[\"default\"].join(dir, 'fonts/open-sans/open-sans-32-white/open-sans-32-white.fnt'),\n      FONT_SANS_64_WHITE: _path[\"default\"].join(dir, 'fonts/open-sans/open-sans-64-white/open-sans-64-white.fnt'),\n      FONT_SANS_128_WHITE: _path[\"default\"].join(dir, 'fonts/open-sans/open-sans-128-white/open-sans-128-white.fnt'),\n\n      /**\n       * Loads a bitmap font from a file\n       * @param {string} file the file path of a .fnt file\n       * @param {function(Error, Jimp)} cb (optional) a function to call when the font is loaded\n       * @returns {Promise} a promise\n       */\n      loadFont: function loadFont(file, cb) {\n        var _this = this;\n\n        if (typeof file !== 'string') return _utils.throwError.call(this, 'file must be a string', cb);\n        return new Promise(function (resolve, reject) {\n          cb = cb || function (err, font) {\n            if (err) reject(err);else resolve(font);\n          };\n\n          (0, _loadBmfont[\"default\"])(file, function (err, font) {\n            var chars = {};\n            var kernings = {};\n\n            if (err) {\n              return _utils.throwError.call(_this, err, cb);\n            }\n\n            for (var i = 0; i < font.chars.length; i++) {\n              chars[String.fromCharCode(font.chars[i].id)] = font.chars[i];\n            }\n\n            for (var _i = 0; _i < font.kernings.length; _i++) {\n              var firstString = String.fromCharCode(font.kernings[_i].first);\n              kernings[firstString] = kernings[firstString] || {};\n              kernings[firstString][String.fromCharCode(font.kernings[_i].second)] = font.kernings[_i].amount;\n            }\n\n            loadPages(_this, _path[\"default\"].dirname(file), font.pages).then(function (pages) {\n              cb(null, {\n                chars: chars,\n                kernings: kernings,\n                pages: pages,\n                common: font.common,\n                info: font.info\n              });\n            });\n          });\n        });\n      }\n    },\n    \"class\": {\n      /**\n       * Draws a text on a image on a given boundary\n       * @param {Jimp} font a bitmap font loaded from `Jimp.loadFont` command\n       * @param {number} x the x position to start drawing the text\n       * @param {number} y the y position to start drawing the text\n       * @param {any} text the text to draw (string or object with `text`, `alignmentX`, and/or `alignmentY`)\n       * @param {number} maxWidth (optional) the boundary width to draw in\n       * @param {number} maxHeight (optional) the boundary height to draw in\n       * @param {function(Error, Jimp)} cb (optional) a function to call when the text is written\n       * @returns {Jimp} this for chaining of methods\n       */\n      print: function print(font, x, y, text, maxWidth, maxHeight, cb) {\n        var _this2 = this;\n\n        if (typeof maxWidth === 'function' && typeof cb === 'undefined') {\n          cb = maxWidth;\n          maxWidth = Infinity;\n        }\n\n        if (typeof maxWidth === 'undefined') {\n          maxWidth = Infinity;\n        }\n\n        if (typeof maxHeight === 'function' && typeof cb === 'undefined') {\n          cb = maxHeight;\n          maxHeight = Infinity;\n        }\n\n        if (typeof maxHeight === 'undefined') {\n          maxHeight = Infinity;\n        }\n\n        if ((0, _typeof2[\"default\"])(font) !== 'object') {\n          return _utils.throwError.call(this, 'font must be a Jimp loadFont', cb);\n        }\n\n        if (typeof x !== 'number' || typeof y !== 'number' || typeof maxWidth !== 'number') {\n          return _utils.throwError.call(this, 'x, y and maxWidth must be numbers', cb);\n        }\n\n        if (typeof maxWidth !== 'number') {\n          return _utils.throwError.call(this, 'maxWidth must be a number', cb);\n        }\n\n        if (typeof maxHeight !== 'number') {\n          return _utils.throwError.call(this, 'maxHeight must be a number', cb);\n        }\n\n        var alignmentX;\n        var alignmentY;\n\n        if ((0, _typeof2[\"default\"])(text) === 'object' && text.text !== null && text.text !== undefined) {\n          alignmentX = text.alignmentX || this.constructor.HORIZONTAL_ALIGN_LEFT;\n          alignmentY = text.alignmentY || this.constructor.VERTICAL_ALIGN_TOP;\n          var _text = text;\n          text = _text.text;\n        } else {\n          alignmentX = this.constructor.HORIZONTAL_ALIGN_LEFT;\n          alignmentY = this.constructor.VERTICAL_ALIGN_TOP;\n          text = text.toString();\n        }\n\n        if (maxHeight !== Infinity && alignmentY === this.constructor.VERTICAL_ALIGN_BOTTOM) {\n          y += maxHeight - (0, _measureText.measureTextHeight)(font, text, maxWidth);\n        } else if (maxHeight !== Infinity && alignmentY === this.constructor.VERTICAL_ALIGN_MIDDLE) {\n          y += maxHeight / 2 - (0, _measureText.measureTextHeight)(font, text, maxWidth) / 2;\n        }\n\n        var defaultCharWidth = Object.entries(font.chars)[0][1].xadvance;\n\n        var _splitLines = splitLines(font, text, maxWidth),\n            lines = _splitLines.lines,\n            longestLine = _splitLines.longestLine;\n\n        lines.forEach(function (line) {\n          var lineString = line.join(' ');\n          var alignmentWidth = xOffsetBasedOnAlignment(_this2.constructor, font, lineString, maxWidth, alignmentX);\n          printText.call(_this2, font, x + alignmentWidth, y, lineString, defaultCharWidth);\n          y += font.common.lineHeight;\n        });\n\n        if ((0, _utils.isNodePattern)(cb)) {\n          cb.call(this, null, this, {\n            x: x + longestLine,\n            y: y\n          });\n        }\n\n        return this;\n      }\n    }\n  };\n};\n\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../src/index.js"],"names":["alignment","constants","maxWidth","char","characterPage","font","image","x","y","i","text","fontChar","fontKerning","drawCharacter","kerning","words","lines","currentLine","longestLine","line","length","newPages","Jimp","dir","Promise","process","measureText","measureTextHeight","FONT_SANS_8_BLACK","Path","FONT_SANS_10_BLACK","FONT_SANS_12_BLACK","FONT_SANS_14_BLACK","FONT_SANS_16_BLACK","FONT_SANS_32_BLACK","FONT_SANS_64_BLACK","FONT_SANS_128_BLACK","FONT_SANS_8_WHITE","FONT_SANS_16_WHITE","FONT_SANS_32_WHITE","FONT_SANS_64_WHITE","FONT_SANS_128_WHITE","loadFont","throwError","cb","reject","resolve","chars","kernings","String","firstString","loadPages","pages","common","info","print","maxHeight","alignmentX","alignmentY","defaultCharWidth","Object","splitLines","lineString","alignmentWidth","xOffsetBasedOnAlignment","printText"],"mappings":"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","sourcesContent":["import Path from 'path';\nimport bMFont from 'load-bmfont';\nimport { isNodePattern, throwError } from '@jimp/utils';\nimport { measureText, measureTextHeight } from './measure-text';\n\nfunction xOffsetBasedOnAlignment(constants, font, line, maxWidth, alignment) {\n  if (alignment === constants.HORIZONTAL_ALIGN_LEFT) {\n    return 0;\n  }\n\n  if (alignment === constants.HORIZONTAL_ALIGN_CENTER) {\n    return (maxWidth - measureText(font, line)) / 2;\n  }\n\n  return maxWidth - measureText(font, line);\n}\n\nfunction drawCharacter(image, font, x, y, char) {\n  if (char.width > 0 && char.height > 0) {\n    const characterPage = font.pages[char.page];\n\n    image.blit(\n      characterPage,\n      x + char.xoffset,\n      y + char.yoffset,\n      char.x,\n      char.y,\n      char.width,\n      char.height\n    );\n  }\n\n  return image;\n}\n\nfunction printText(font, x, y, text, defaultCharWidth) {\n  for (let i = 0; i < text.length; i++) {\n    let char;\n\n    if (font.chars[text[i]]) {\n      char = text[i];\n    } else if (/\\s/.test(text[i])) {\n      char = '';\n    } else {\n      char = '?';\n    }\n\n    const fontChar = font.chars[char] || {};\n    const fontKerning = font.kernings[char];\n\n    drawCharacter(this, font, x, y, fontChar || {});\n\n    const kerning =\n      fontKerning && fontKerning[text[i + 1]] ? fontKerning[text[i + 1]] : 0;\n\n    x += kerning + (fontChar.xadvance || defaultCharWidth);\n  }\n}\n\nfunction splitLines(font, text, maxWidth) {\n  const words = text.split(' ');\n  const lines = [];\n  let currentLine = [];\n  let longestLine = 0;\n\n  words.forEach(word => {\n    const line = [...currentLine, word].join(' ');\n    const length = measureText(font, line);\n\n    if (length <= maxWidth) {\n      if (length > longestLine) {\n        longestLine = length;\n      }\n\n      currentLine.push(word);\n    } else {\n      lines.push(currentLine);\n      currentLine = [word];\n    }\n  });\n\n  lines.push(currentLine);\n\n  return {\n    lines,\n    longestLine\n  };\n}\n\nfunction loadPages(Jimp, dir, pages) {\n  const newPages = pages.map(page => {\n    return Jimp.read(dir + '/' + page);\n  });\n\n  return Promise.all(newPages);\n}\n\nconst dir = process.env.DIRNAME || `${__dirname}/../`;\n\nexport default () => ({\n  constants: {\n    measureText,\n    measureTextHeight,\n    FONT_SANS_8_BLACK: Path.join(\n      dir,\n      'fonts/open-sans/open-sans-8-black/open-sans-8-black.fnt'\n    ),\n    FONT_SANS_10_BLACK: Path.join(\n      dir,\n      'fonts/open-sans/open-sans-10-black/open-sans-10-black.fnt'\n    ),\n    FONT_SANS_12_BLACK: Path.join(\n      dir,\n      'fonts/open-sans/open-sans-12-black/open-sans-12-black.fnt'\n    ),\n    FONT_SANS_14_BLACK: Path.join(\n      dir,\n      'fonts/open-sans/open-sans-14-black/open-sans-14-black.fnt'\n    ),\n    FONT_SANS_16_BLACK: Path.join(\n      dir,\n      'fonts/open-sans/open-sans-16-black/open-sans-16-black.fnt'\n    ),\n    FONT_SANS_32_BLACK: Path.join(\n      dir,\n      'fonts/open-sans/open-sans-32-black/open-sans-32-black.fnt'\n    ),\n    FONT_SANS_64_BLACK: Path.join(\n      dir,\n      'fonts/open-sans/open-sans-64-black/open-sans-64-black.fnt'\n    ),\n    FONT_SANS_128_BLACK: Path.join(\n      dir,\n      'fonts/open-sans/open-sans-128-black/open-sans-128-black.fnt'\n    ),\n\n    FONT_SANS_8_WHITE: Path.join(\n      dir,\n      'fonts/open-sans/open-sans-8-white/open-sans-8-white.fnt'\n    ),\n    FONT_SANS_16_WHITE: Path.join(\n      dir,\n      'fonts/open-sans/open-sans-16-white/open-sans-16-white.fnt'\n    ),\n    FONT_SANS_32_WHITE: Path.join(\n      dir,\n      'fonts/open-sans/open-sans-32-white/open-sans-32-white.fnt'\n    ),\n    FONT_SANS_64_WHITE: Path.join(\n      dir,\n      'fonts/open-sans/open-sans-64-white/open-sans-64-white.fnt'\n    ),\n    FONT_SANS_128_WHITE: Path.join(\n      dir,\n      'fonts/open-sans/open-sans-128-white/open-sans-128-white.fnt'\n    ),\n\n    /**\n     * Loads a bitmap font from a file\n     * @param {string} file the file path of a .fnt file\n     * @param {function(Error, Jimp)} cb (optional) a function to call when the font is loaded\n     * @returns {Promise} a promise\n     */\n    loadFont(file, cb) {\n      if (typeof file !== 'string')\n        return throwError.call(this, 'file must be a string', cb);\n\n      return new Promise((resolve, reject) => {\n        cb =\n          cb ||\n          function(err, font) {\n            if (err) reject(err);\n            else resolve(font);\n          };\n\n        bMFont(file, (err, font) => {\n          const chars = {};\n          const kernings = {};\n\n          if (err) {\n            return throwError.call(this, err, cb);\n          }\n\n          for (let i = 0; i < font.chars.length; i++) {\n            chars[String.fromCharCode(font.chars[i].id)] = font.chars[i];\n          }\n\n          for (let i = 0; i < font.kernings.length; i++) {\n            const firstString = String.fromCharCode(font.kernings[i].first);\n            kernings[firstString] = kernings[firstString] || {};\n            kernings[firstString][\n              String.fromCharCode(font.kernings[i].second)\n            ] = font.kernings[i].amount;\n          }\n\n          loadPages(this, Path.dirname(file), font.pages).then(pages => {\n            cb(null, {\n              chars,\n              kernings,\n              pages,\n              common: font.common,\n              info: font.info\n            });\n          });\n        });\n      });\n    }\n  },\n\n  class: {\n    /**\n     * Draws a text on a image on a given boundary\n     * @param {Jimp} font a bitmap font loaded from `Jimp.loadFont` command\n     * @param {number} x the x position to start drawing the text\n     * @param {number} y the y position to start drawing the text\n     * @param {any} text the text to draw (string or object with `text`, `alignmentX`, and/or `alignmentY`)\n     * @param {number} maxWidth (optional) the boundary width to draw in\n     * @param {number} maxHeight (optional) the boundary height to draw in\n     * @param {function(Error, Jimp)} cb (optional) a function to call when the text is written\n     * @returns {Jimp} this for chaining of methods\n     */\n    print(font, x, y, text, maxWidth, maxHeight, cb) {\n      if (typeof maxWidth === 'function' && typeof cb === 'undefined') {\n        cb = maxWidth;\n        maxWidth = Infinity;\n      }\n\n      if (typeof maxWidth === 'undefined') {\n        maxWidth = Infinity;\n      }\n\n      if (typeof maxHeight === 'function' && typeof cb === 'undefined') {\n        cb = maxHeight;\n        maxHeight = Infinity;\n      }\n\n      if (typeof maxHeight === 'undefined') {\n        maxHeight = Infinity;\n      }\n\n      if (typeof font !== 'object') {\n        return throwError.call(this, 'font must be a Jimp loadFont', cb);\n      }\n\n      if (\n        typeof x !== 'number' ||\n        typeof y !== 'number' ||\n        typeof maxWidth !== 'number'\n      ) {\n        return throwError.call(this, 'x, y and maxWidth must be numbers', cb);\n      }\n\n      if (typeof maxWidth !== 'number') {\n        return throwError.call(this, 'maxWidth must be a number', cb);\n      }\n\n      if (typeof maxHeight !== 'number') {\n        return throwError.call(this, 'maxHeight must be a number', cb);\n      }\n\n      let alignmentX;\n      let alignmentY;\n\n      if (\n        typeof text === 'object' &&\n        text.text !== null &&\n        text.text !== undefined\n      ) {\n        alignmentX = text.alignmentX || this.constructor.HORIZONTAL_ALIGN_LEFT;\n        alignmentY = text.alignmentY || this.constructor.VERTICAL_ALIGN_TOP;\n        ({ text } = text);\n      } else {\n        alignmentX = this.constructor.HORIZONTAL_ALIGN_LEFT;\n        alignmentY = this.constructor.VERTICAL_ALIGN_TOP;\n        text = text.toString();\n      }\n\n      if (\n        maxHeight !== Infinity &&\n        alignmentY === this.constructor.VERTICAL_ALIGN_BOTTOM\n      ) {\n        y += maxHeight - measureTextHeight(font, text, maxWidth);\n      } else if (\n        maxHeight !== Infinity &&\n        alignmentY === this.constructor.VERTICAL_ALIGN_MIDDLE\n      ) {\n        y += maxHeight / 2 - measureTextHeight(font, text, maxWidth) / 2;\n      }\n\n      const defaultCharWidth = Object.entries(font.chars)[0][1].xadvance;\n      const { lines, longestLine } = splitLines(font, text, maxWidth);\n\n      lines.forEach(line => {\n        const lineString = line.join(' ');\n        const alignmentWidth = xOffsetBasedOnAlignment(\n          this.constructor,\n          font,\n          lineString,\n          maxWidth,\n          alignmentX\n        );\n\n        printText.call(\n          this,\n          font,\n          x + alignmentWidth,\n          y,\n          lineString,\n          defaultCharWidth\n        );\n\n        y += font.common.lineHeight;\n      });\n\n      if (isNodePattern(cb)) {\n        cb.call(this, null, this, { x: x + longestLine, y });\n      }\n\n      return this;\n    }\n  }\n});\n"]},"metadata":{},"sourceType":"script"}