{"ast":null,"code":"'use strict';\n\nvar assert = require('assert').ok;\n\nvar zlib = require('zlib');\n\nvar util = require('util');\n\nvar kMaxLength = require('buffer').kMaxLength;\n\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) {\n    return new Inflate(opts);\n  }\n\n  if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {\n    opts.chunkSize = zlib.Z_MIN_CHUNK;\n  }\n\n  zlib.Inflate.call(this, opts); // Node 8 --> 9 compatibility check\n\n  this._offset = this._offset === undefined ? this._outOffset : this._offset;\n  this._buffer = this._buffer || this._outBuffer;\n\n  if (opts && opts.maxLength != null) {\n    this._maxLength = opts.maxLength;\n  }\n}\n\nfunction createInflate(opts) {\n  return new Inflate(opts);\n}\n\nfunction _close(engine, callback) {\n  if (callback) {\n    process.nextTick(callback);\n  } // Caller may invoke .close after a zlib error (which will null _handle).\n\n\n  if (!engine._handle) {\n    return;\n  }\n\n  engine._handle.close();\n\n  engine._handle = null;\n}\n\nInflate.prototype._processChunk = function (chunk, flushFlag, asyncCb) {\n  if (typeof asyncCb === 'function') {\n    return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);\n  }\n\n  var self = this;\n  var availInBefore = chunk && chunk.length;\n  var availOutBefore = this._chunkSize - this._offset;\n  var leftToInflate = this._maxLength;\n  var inOff = 0;\n  var buffers = [];\n  var nread = 0;\n  var error;\n  this.on('error', function (err) {\n    error = err;\n  });\n\n  function handleChunk(availInAfter, availOutAfter) {\n    if (self._hadError) {\n      return;\n    }\n\n    var have = availOutBefore - availOutAfter;\n    assert(have >= 0, 'have should not go down');\n\n    if (have > 0) {\n      var out = self._buffer.slice(self._offset, self._offset + have);\n\n      self._offset += have;\n\n      if (out.length > leftToInflate) {\n        out = out.slice(0, leftToInflate);\n      }\n\n      buffers.push(out);\n      nread += out.length;\n      leftToInflate -= out.length;\n\n      if (leftToInflate === 0) {\n        return false;\n      }\n    }\n\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = Buffer.allocUnsafe(self._chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      inOff += availInBefore - availInAfter;\n      availInBefore = availInAfter;\n      return true;\n    }\n\n    return false;\n  }\n\n  assert(this._handle, 'zlib binding closed');\n\n  do {\n    var res = this._handle.writeSync(flushFlag, chunk, // in\n    inOff, // in_off\n    availInBefore, // in_len\n    this._buffer, // out\n    this._offset, //out_off\n    availOutBefore); // out_len\n    // Node 8 --> 9 compatibility check\n\n\n    res = res || this._writeState;\n  } while (!this._hadError && handleChunk(res[0], res[1]));\n\n  if (this._hadError) {\n    throw error;\n  }\n\n  if (nread >= kMaxLength) {\n    _close(this);\n\n    throw new RangeError('Cannot create final Buffer. It would be larger than 0x' + kMaxLength.toString(16) + ' bytes');\n  }\n\n  var buf = Buffer.concat(buffers, nread);\n\n  _close(this);\n\n  return buf;\n};\n\nutil.inherits(Inflate, zlib.Inflate);\n\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer);\n  }\n\n  if (!(buffer instanceof Buffer)) {\n    throw new TypeError('Not a string or buffer');\n  }\n\n  var flushFlag = engine._finishFlushFlag;\n\n  if (flushFlag == null) {\n    flushFlag = zlib.Z_FINISH;\n  }\n\n  return engine._processChunk(buffer, flushFlag);\n}\n\nfunction inflateSync(buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n}\n\nmodule.exports = exports = inflateSync;\nexports.Inflate = Inflate;\nexports.createInflate = createInflate;\nexports.inflateSync = inflateSync;","map":{"version":3,"sources":["/Users/zakstratton/Documents/logo-processor/node_modules/pngjs/lib/sync-inflate.js"],"names":["assert","require","ok","zlib","util","kMaxLength","Inflate","opts","chunkSize","Z_MIN_CHUNK","call","_offset","undefined","_outOffset","_buffer","_outBuffer","maxLength","_maxLength","createInflate","_close","engine","callback","process","nextTick","_handle","close","prototype","_processChunk","chunk","flushFlag","asyncCb","self","availInBefore","length","availOutBefore","_chunkSize","leftToInflate","inOff","buffers","nread","error","on","err","handleChunk","availInAfter","availOutAfter","_hadError","have","out","slice","push","Buffer","allocUnsafe","res","writeSync","_writeState","RangeError","toString","buf","concat","inherits","zlibBufferSync","buffer","from","TypeError","_finishFlushFlag","Z_FINISH","inflateSync","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar assert = require('assert').ok;\nvar zlib = require('zlib');\nvar util = require('util');\n\nvar kMaxLength = require('buffer').kMaxLength;\n\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) {\n    return new Inflate(opts);\n  }\n\n  if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {\n    opts.chunkSize = zlib.Z_MIN_CHUNK;\n  }\n\n  zlib.Inflate.call(this, opts);\n\n  // Node 8 --> 9 compatibility check\n  this._offset = this._offset === undefined ? this._outOffset : this._offset;\n  this._buffer = this._buffer || this._outBuffer;\n\n  if (opts && opts.maxLength != null) {\n    this._maxLength = opts.maxLength;\n  }\n}\n\nfunction createInflate(opts) {\n  return new Inflate(opts);\n}\n\nfunction _close(engine, callback) {\n  if (callback) {\n    process.nextTick(callback);\n  }\n\n  // Caller may invoke .close after a zlib error (which will null _handle).\n  if (!engine._handle) {\n    return;\n  }\n\n  engine._handle.close();\n  engine._handle = null;\n}\n\nInflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {\n  if (typeof asyncCb === 'function') {\n    return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);\n  }\n\n  var self = this;\n\n  var availInBefore = chunk && chunk.length;\n  var availOutBefore = this._chunkSize - this._offset;\n  var leftToInflate = this._maxLength;\n  var inOff = 0;\n\n  var buffers = [];\n  var nread = 0;\n\n  var error;\n  this.on('error', function(err) {\n    error = err;\n  });\n\n  function handleChunk(availInAfter, availOutAfter) {\n    if (self._hadError) {\n      return;\n    }\n\n    var have = availOutBefore - availOutAfter;\n    assert(have >= 0, 'have should not go down');\n\n    if (have > 0) {\n      var out = self._buffer.slice(self._offset, self._offset + have);\n      self._offset += have;\n\n      if (out.length > leftToInflate) {\n        out = out.slice(0, leftToInflate);\n      }\n\n      buffers.push(out);\n      nread += out.length;\n      leftToInflate -= out.length;\n\n      if (leftToInflate === 0) {\n        return false;\n      }\n    }\n\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = Buffer.allocUnsafe(self._chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      inOff += (availInBefore - availInAfter);\n      availInBefore = availInAfter;\n\n      return true;\n    }\n\n    return false;\n  }\n\n  assert(this._handle, 'zlib binding closed');\n  do {\n    var res = this._handle.writeSync(flushFlag,\n      chunk, // in\n      inOff, // in_off\n      availInBefore, // in_len\n      this._buffer, // out\n      this._offset, //out_off\n      availOutBefore); // out_len\n    // Node 8 --> 9 compatibility check\n    res = res || this._writeState;\n  } while (!this._hadError && handleChunk(res[0], res[1]));\n\n  if (this._hadError) {\n    throw error;\n  }\n\n  if (nread >= kMaxLength) {\n    _close(this);\n    throw new RangeError('Cannot create final Buffer. It would be larger than 0x' + kMaxLength.toString(16) + ' bytes');\n  }\n\n  var buf = Buffer.concat(buffers, nread);\n  _close(this);\n\n  return buf;\n};\n\nutil.inherits(Inflate, zlib.Inflate);\n\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer);\n  }\n  if (!(buffer instanceof Buffer)) {\n    throw new TypeError('Not a string or buffer');\n  }\n\n  var flushFlag = engine._finishFlushFlag;\n  if (flushFlag == null) {\n    flushFlag = zlib.Z_FINISH;\n  }\n\n  return engine._processChunk(buffer, flushFlag);\n}\n\nfunction inflateSync(buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n}\n\nmodule.exports = exports = inflateSync;\nexports.Inflate = Inflate;\nexports.createInflate = createInflate;\nexports.inflateSync = inflateSync;\n"]},"metadata":{},"sourceType":"script"}