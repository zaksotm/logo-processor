{"ast":null,"code":"/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, vars: true, white: true */\nfunction readExifValue(format, stream) {\n  switch (format) {\n    case 1:\n      return stream.nextUInt8();\n\n    case 3:\n      return stream.nextUInt16();\n\n    case 4:\n      return stream.nextUInt32();\n\n    case 5:\n      return [stream.nextUInt32(), stream.nextUInt32()];\n\n    case 6:\n      return stream.nextInt8();\n\n    case 8:\n      return stream.nextUInt16();\n\n    case 9:\n      return stream.nextUInt32();\n\n    case 10:\n      return [stream.nextInt32(), stream.nextInt32()];\n\n    case 11:\n      return stream.nextFloat();\n\n    case 12:\n      return stream.nextDouble();\n\n    default:\n      throw new Error('Invalid format while decoding: ' + format);\n  }\n}\n\nfunction getBytesPerComponent(format) {\n  switch (format) {\n    case 1:\n    case 2:\n    case 6:\n    case 7:\n      return 1;\n\n    case 3:\n    case 8:\n      return 2;\n\n    case 4:\n    case 9:\n    case 11:\n      return 4;\n\n    case 5:\n    case 10:\n    case 12:\n      return 8;\n\n    default:\n      return 0;\n  }\n}\n\nfunction readExifTag(tiffMarker, stream) {\n  var tagType = stream.nextUInt16(),\n      format = stream.nextUInt16(),\n      bytesPerComponent = getBytesPerComponent(format),\n      components = stream.nextUInt32(),\n      valueBytes = bytesPerComponent * components,\n      values,\n      value,\n      c;\n  /* if the value is bigger then 4 bytes, the value is in the data section of the IFD\n  and the value present in the tag is the offset starting from the tiff header. So we replace the stream\n  with a stream that is located at the given offset in the data section. s*/\n\n  if (valueBytes > 4) {\n    stream = tiffMarker.openWithOffset(stream.nextUInt32());\n  } //we don't want to read strings as arrays\n\n\n  if (format === 2) {\n    values = stream.nextString(components); //cut off \\0 characters\n\n    var lastNull = values.indexOf('\\0');\n\n    if (lastNull !== -1) {\n      values = values.substr(0, lastNull);\n    }\n  } else if (format === 7) {\n    values = stream.nextBuffer(components);\n  } else if (format !== 0) {\n    values = [];\n\n    for (c = 0; c < components; ++c) {\n      values.push(readExifValue(format, stream));\n    }\n  } //since our stream is a stateful object, we need to skip remaining bytes\n  //so our offset stays correct\n\n\n  if (valueBytes < 4) {\n    stream.skip(4 - valueBytes);\n  }\n\n  return [tagType, values, format];\n}\n\nfunction readIFDSection(tiffMarker, stream, iterator) {\n  var numberOfEntries = stream.nextUInt16(),\n      tag,\n      i;\n\n  for (i = 0; i < numberOfEntries; ++i) {\n    tag = readExifTag(tiffMarker, stream);\n    iterator(tag[0], tag[1], tag[2]);\n  }\n}\n\nfunction readHeader(stream) {\n  var exifHeader = stream.nextString(6);\n\n  if (exifHeader !== 'Exif\\0\\0') {\n    throw new Error('Invalid EXIF header');\n  }\n\n  var tiffMarker = stream.mark();\n  var tiffHeader = stream.nextUInt16();\n\n  if (tiffHeader === 0x4949) {\n    stream.setBigEndian(false);\n  } else if (tiffHeader === 0x4D4D) {\n    stream.setBigEndian(true);\n  } else {\n    throw new Error('Invalid TIFF header');\n  }\n\n  if (stream.nextUInt16() !== 0x002A) {\n    throw new Error('Invalid TIFF data');\n  }\n\n  return tiffMarker;\n}\n\nmodule.exports = {\n  IFD0: 1,\n  IFD1: 2,\n  GPSIFD: 3,\n  SubIFD: 4,\n  InteropIFD: 5,\n  parseTags: function (stream, iterator) {\n    var tiffMarker;\n\n    try {\n      tiffMarker = readHeader(stream);\n    } catch (e) {\n      return false; //ignore APP1 sections with invalid headers\n    }\n\n    var subIfdOffset, gpsOffset, interopOffset;\n    var ifd0Stream = tiffMarker.openWithOffset(stream.nextUInt32()),\n        IFD0 = this.IFD0;\n    readIFDSection(tiffMarker, ifd0Stream, function (tagType, value, format) {\n      switch (tagType) {\n        case 0x8825:\n          gpsOffset = value[0];\n          break;\n\n        case 0x8769:\n          subIfdOffset = value[0];\n          break;\n\n        default:\n          iterator(IFD0, tagType, value, format);\n          break;\n      }\n    });\n    var ifd1Offset = ifd0Stream.nextUInt32();\n\n    if (ifd1Offset !== 0) {\n      var ifd1Stream = tiffMarker.openWithOffset(ifd1Offset);\n      readIFDSection(tiffMarker, ifd1Stream, iterator.bind(null, this.IFD1));\n    }\n\n    if (gpsOffset) {\n      var gpsStream = tiffMarker.openWithOffset(gpsOffset);\n      readIFDSection(tiffMarker, gpsStream, iterator.bind(null, this.GPSIFD));\n    }\n\n    if (subIfdOffset) {\n      var subIfdStream = tiffMarker.openWithOffset(subIfdOffset),\n          InteropIFD = this.InteropIFD;\n      readIFDSection(tiffMarker, subIfdStream, function (tagType, value, format) {\n        if (tagType === 0xA005) {\n          interopOffset = value[0];\n        } else {\n          iterator(InteropIFD, tagType, value, format);\n        }\n      });\n    }\n\n    if (interopOffset) {\n      var interopStream = tiffMarker.openWithOffset(interopOffset);\n      readIFDSection(tiffMarker, interopStream, iterator.bind(null, this.InteropIFD));\n    }\n\n    return true;\n  }\n};","map":{"version":3,"sources":["/Users/zakstratton/Documents/logo-processor/node_modules/exif-parser/lib/exif.js"],"names":["readExifValue","format","stream","nextUInt8","nextUInt16","nextUInt32","nextInt8","nextInt32","nextFloat","nextDouble","Error","getBytesPerComponent","readExifTag","tiffMarker","tagType","bytesPerComponent","components","valueBytes","values","value","c","openWithOffset","nextString","lastNull","indexOf","substr","nextBuffer","push","skip","readIFDSection","iterator","numberOfEntries","tag","i","readHeader","exifHeader","mark","tiffHeader","setBigEndian","module","exports","IFD0","IFD1","GPSIFD","SubIFD","InteropIFD","parseTags","e","subIfdOffset","gpsOffset","interopOffset","ifd0Stream","ifd1Offset","ifd1Stream","bind","gpsStream","subIfdStream","interopStream"],"mappings":"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","sourcesContent":["/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, vars: true, white: true */\n\nfunction readExifValue(format, stream) {\n\tswitch(format) {\n\t\tcase 1: return stream.nextUInt8();\n\t\tcase 3: return stream.nextUInt16();\n\t\tcase 4: return stream.nextUInt32();\n\t\tcase 5: return [stream.nextUInt32(), stream.nextUInt32()];\n\t\tcase 6: return stream.nextInt8();\n\t\tcase 8: return stream.nextUInt16();\n\t\tcase 9: return stream.nextUInt32();\n\t\tcase 10: return [stream.nextInt32(), stream.nextInt32()];\n\t\tcase 11: return stream.nextFloat();\n\t\tcase 12: return stream.nextDouble();\n\t\tdefault: throw new Error('Invalid format while decoding: ' + format);\n\t}\n}\n\nfunction getBytesPerComponent(format) {\n\tswitch(format) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 6:\n\t\tcase 7:\n\t\t\treturn 1;\n\t\tcase 3:\n\t\tcase 8:\n\t\t\treturn 2;\n\t\tcase 4:\n\t\tcase 9:\n\t\tcase 11:\n\t\t\treturn 4;\n\t\tcase 5:\n\t\tcase 10:\n\t\tcase 12:\n\t\t\treturn 8;\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\nfunction readExifTag(tiffMarker, stream) {\n\tvar tagType = stream.nextUInt16(),\n\t\tformat = stream.nextUInt16(),\n\t\tbytesPerComponent = getBytesPerComponent(format),\n\t\tcomponents = stream.nextUInt32(),\n\t\tvalueBytes = bytesPerComponent * components,\n\t\tvalues,\n\t\tvalue,\n\t\tc;\n\n\t/* if the value is bigger then 4 bytes, the value is in the data section of the IFD\n\tand the value present in the tag is the offset starting from the tiff header. So we replace the stream\n\twith a stream that is located at the given offset in the data section. s*/\n\tif(valueBytes > 4) {\n\t\tstream = tiffMarker.openWithOffset(stream.nextUInt32());\n\t}\n\t//we don't want to read strings as arrays\n\tif(format === 2) {\n\t\tvalues = stream.nextString(components);\n\t\t//cut off \\0 characters\n\t\tvar lastNull = values.indexOf('\\0');\n\t\tif(lastNull !== -1) {\n\t\t\tvalues = values.substr(0, lastNull);\n\t\t}\n\t}\n\telse if(format === 7) {\n\t\tvalues = stream.nextBuffer(components);\n\t}\n\telse if(format !== 0) {\n\t\tvalues = [];\n\t\tfor(c = 0; c < components; ++c) {\n\t\t\tvalues.push(readExifValue(format, stream));\n\t\t}\n\t}\n\t//since our stream is a stateful object, we need to skip remaining bytes\n\t//so our offset stays correct\n\tif(valueBytes < 4) {\n\t\tstream.skip(4 - valueBytes);\n\t}\n\n\treturn [tagType, values, format];\n}\n\nfunction readIFDSection(tiffMarker, stream, iterator) {\n\tvar numberOfEntries = stream.nextUInt16(), tag, i;\n\tfor(i = 0; i < numberOfEntries; ++i) {\n\t\ttag = readExifTag(tiffMarker, stream);\n\t\titerator(tag[0], tag[1], tag[2]);\n\t}\n}\n\nfunction readHeader(stream) {\n\tvar exifHeader = stream.nextString(6);\n\tif(exifHeader !== 'Exif\\0\\0') {\n\t\tthrow new Error('Invalid EXIF header');\n\t}\n\n\tvar tiffMarker = stream.mark();\n\tvar tiffHeader = stream.nextUInt16();\n\tif(tiffHeader === 0x4949) {\n\t\tstream.setBigEndian(false);\n\t} else if(tiffHeader === 0x4D4D) {\n\t\tstream.setBigEndian(true);\n\t} else {\n\t\tthrow new Error('Invalid TIFF header');\n\t}\n\tif(stream.nextUInt16() !== 0x002A) {\n\t\tthrow new Error('Invalid TIFF data');\n\t}\n\treturn tiffMarker;\n}\n\nmodule.exports = {\n\tIFD0: 1,\n\tIFD1: 2,\n\tGPSIFD: 3,\n\tSubIFD: 4,\n\tInteropIFD: 5,\n\tparseTags: function(stream, iterator) {\n\t\tvar tiffMarker;\n\t\ttry {\n\t\t\ttiffMarker = readHeader(stream);\n\t\t} catch(e) {\n\t\t\treturn false;\t//ignore APP1 sections with invalid headers\n\t\t}\n\t\tvar subIfdOffset, gpsOffset, interopOffset;\n\t\tvar ifd0Stream = tiffMarker.openWithOffset(stream.nextUInt32()),\n\t\t\tIFD0 = this.IFD0;\n\t\treadIFDSection(tiffMarker, ifd0Stream, function(tagType, value, format) {\n\t\t\tswitch(tagType) {\n\t\t\t\tcase 0x8825: gpsOffset = value[0]; break;\n\t\t\t\tcase 0x8769: subIfdOffset = value[0]; break;\n\t\t\t\tdefault: iterator(IFD0, tagType, value, format); break;\n\t\t\t}\n\t\t});\n\t\tvar ifd1Offset = ifd0Stream.nextUInt32();\n\t\tif(ifd1Offset !== 0) {\n\t\t\tvar ifd1Stream = tiffMarker.openWithOffset(ifd1Offset);\n\t\t\treadIFDSection(tiffMarker, ifd1Stream, iterator.bind(null, this.IFD1));\n\t\t}\n\n\t\tif(gpsOffset) {\n\t\t\tvar gpsStream = tiffMarker.openWithOffset(gpsOffset);\n\t\t\treadIFDSection(tiffMarker, gpsStream, iterator.bind(null, this.GPSIFD));\n\t\t}\n\n\t\tif(subIfdOffset) {\n\t\t\tvar subIfdStream = tiffMarker.openWithOffset(subIfdOffset), InteropIFD = this.InteropIFD;\n\t\t\treadIFDSection(tiffMarker, subIfdStream, function(tagType, value, format) {\n\t\t\t\tif(tagType === 0xA005) {\n\t\t\t\t\tinteropOffset = value[0];\n\t\t\t\t} else {\n\t\t\t\t\titerator(InteropIFD, tagType, value, format);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif(interopOffset) {\n\t\t\tvar interopStream = tiffMarker.openWithOffset(interopOffset);\n\t\t\treadIFDSection(tiffMarker, interopStream, iterator.bind(null, this.InteropIFD));\n\t\t}\n\t\treturn true;\n\t}\n};"]},"metadata":{},"sourceType":"script"}