{"ast":null,"code":"\"use strict\"; // JavaScript Image Resizer (c) 2012 - Grant Galitz\n// Released to public domain 29 July 2013: https://github.com/grantgalitz/JS-Image-Resizer/issues/4\n\nfunction Resize(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback) {\n  this.widthOriginal = Math.abs(Math.floor(widthOriginal) || 0);\n  this.heightOriginal = Math.abs(Math.floor(heightOriginal) || 0);\n  this.targetWidth = Math.abs(Math.floor(targetWidth) || 0);\n  this.targetHeight = Math.abs(Math.floor(targetHeight) || 0);\n  this.colorChannels = blendAlpha ? 4 : 3;\n  this.interpolationPass = Boolean(interpolationPass);\n  this.resizeCallback = typeof resizeCallback === 'function' ? resizeCallback : function () {};\n  this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels;\n  this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels;\n  this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels;\n  this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal;\n  this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight;\n  this.initialize();\n}\n\nResize.prototype.initialize = function () {\n  // Perform some checks:\n  if (this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0) {\n    this.configurePasses();\n  } else {\n    throw new Error('Invalid settings specified for the resizer.');\n  }\n};\n\nResize.prototype.configurePasses = function () {\n  if (this.widthOriginal === this.targetWidth) {\n    // Bypass the width resizer pass:\n    this.resizeWidth = this.bypassResizer;\n  } else {\n    // Setup the width resizer pass:\n    this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth;\n\n    if (this.ratioWeightWidthPass < 1 && this.interpolationPass) {\n      this.initializeFirstPassBuffers(true);\n      this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB;\n    } else {\n      this.initializeFirstPassBuffers(false);\n      this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB;\n    }\n  }\n\n  if (this.heightOriginal === this.targetHeight) {\n    // Bypass the height resizer pass:\n    this.resizeHeight = this.bypassResizer;\n  } else {\n    // Setup the height resizer pass:\n    this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight;\n\n    if (this.ratioWeightHeightPass < 1 && this.interpolationPass) {\n      this.initializeSecondPassBuffers(true);\n      this.resizeHeight = this.resizeHeightInterpolated;\n    } else {\n      this.initializeSecondPassBuffers(false);\n      this.resizeHeight = this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB;\n    }\n  }\n};\n\nResize.prototype._resizeWidthInterpolatedRGBChannels = function (buffer, fourthChannel) {\n  var channelsNum = fourthChannel ? 4 : 3;\n  var ratioWeight = this.ratioWeightWidthPass;\n  var outputBuffer = this.widthBuffer;\n  var weight = 0;\n  var finalOffset = 0;\n  var pixelOffset = 0;\n  var firstWeight = 0;\n  var secondWeight = 0;\n  var targetPosition; // Handle for only one interpolation input being valid for start calculation:\n\n  for (targetPosition = 0; weight < 1 / 3; targetPosition += channelsNum, weight += ratioWeight) {\n    for (finalOffset = targetPosition, pixelOffset = 0; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {\n      outputBuffer[finalOffset] = buffer[pixelOffset];\n      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];\n      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];\n      if (fourthChannel) outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];\n    }\n  } // Adjust for overshoot of the last pass's counter:\n\n\n  weight -= 1 / 3;\n  var interpolationWidthSourceReadStop;\n\n  for (interpolationWidthSourceReadStop = this.widthOriginal - 1; weight < interpolationWidthSourceReadStop; targetPosition += channelsNum, weight += ratioWeight) {\n    // Calculate weightings:\n    secondWeight = weight % 1;\n    firstWeight = 1 - secondWeight; // Interpolate:\n\n    for (finalOffset = targetPosition, pixelOffset = Math.floor(weight) * channelsNum; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {\n      outputBuffer[finalOffset + 0] = buffer[pixelOffset + 0] * firstWeight + buffer[pixelOffset + channelsNum + 0] * secondWeight;\n      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1] * firstWeight + buffer[pixelOffset + channelsNum + 1] * secondWeight;\n      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2] * firstWeight + buffer[pixelOffset + channelsNum + 2] * secondWeight;\n      if (fourthChannel) outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3] * firstWeight + buffer[pixelOffset + channelsNum + 3] * secondWeight;\n    }\n  } // Handle for only one interpolation input being valid for end calculation:\n\n\n  for (interpolationWidthSourceReadStop = this.originalWidthMultipliedByChannels - channelsNum; targetPosition < this.targetWidthMultipliedByChannels; targetPosition += channelsNum) {\n    for (finalOffset = targetPosition, pixelOffset = interpolationWidthSourceReadStop; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {\n      outputBuffer[finalOffset] = buffer[pixelOffset];\n      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];\n      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];\n      if (fourthChannel) outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];\n    }\n  }\n\n  return outputBuffer;\n};\n\nResize.prototype._resizeWidthRGBChannels = function (buffer, fourthChannel) {\n  var channelsNum = fourthChannel ? 4 : 3;\n  var ratioWeight = this.ratioWeightWidthPass;\n  var ratioWeightDivisor = 1 / ratioWeight;\n  var nextLineOffsetOriginalWidth = this.originalWidthMultipliedByChannels - channelsNum + 1;\n  var nextLineOffsetTargetWidth = this.targetWidthMultipliedByChannels - channelsNum + 1;\n  var output = this.outputWidthWorkBench;\n  var outputBuffer = this.widthBuffer;\n  var trustworthyColorsCount = this.outputWidthWorkBenchOpaquePixelsCount;\n  var weight = 0;\n  var amountToNext = 0;\n  var actualPosition = 0;\n  var currentPosition = 0;\n  var line = 0;\n  var pixelOffset = 0;\n  var outputOffset = 0;\n  var multiplier = 1;\n  var r = 0;\n  var g = 0;\n  var b = 0;\n  var a = 0;\n\n  do {\n    for (line = 0; line < this.originalHeightMultipliedByChannels;) {\n      output[line++] = 0;\n      output[line++] = 0;\n      output[line++] = 0;\n\n      if (fourthChannel) {\n        output[line++] = 0;\n        trustworthyColorsCount[line / channelsNum - 1] = 0;\n      }\n    }\n\n    weight = ratioWeight;\n\n    do {\n      amountToNext = 1 + actualPosition - currentPosition;\n      multiplier = Math.min(weight, amountToNext);\n\n      for (line = 0, pixelOffset = actualPosition; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {\n        r = buffer[pixelOffset];\n        g = buffer[++pixelOffset];\n        b = buffer[++pixelOffset];\n        a = fourthChannel ? buffer[++pixelOffset] : 255; // Ignore RGB values if pixel is completely transparent\n\n        output[line++] += (a ? r : 0) * multiplier;\n        output[line++] += (a ? g : 0) * multiplier;\n        output[line++] += (a ? b : 0) * multiplier;\n\n        if (fourthChannel) {\n          output[line++] += a * multiplier;\n          trustworthyColorsCount[line / channelsNum - 1] += a ? multiplier : 0;\n        }\n      }\n\n      if (weight >= amountToNext) {\n        actualPosition += channelsNum;\n        currentPosition = actualPosition;\n        weight -= amountToNext;\n      } else {\n        currentPosition += weight;\n        break;\n      }\n    } while (weight > 0 && actualPosition < this.originalWidthMultipliedByChannels);\n\n    for (line = 0, pixelOffset = outputOffset; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth) {\n      weight = fourthChannel ? trustworthyColorsCount[line / channelsNum] : 1;\n      multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;\n      outputBuffer[pixelOffset] = output[line++] * multiplier;\n      outputBuffer[++pixelOffset] = output[line++] * multiplier;\n      outputBuffer[++pixelOffset] = output[line++] * multiplier;\n      if (fourthChannel) outputBuffer[++pixelOffset] = output[line++] * ratioWeightDivisor;\n    }\n\n    outputOffset += channelsNum;\n  } while (outputOffset < this.targetWidthMultipliedByChannels);\n\n  return outputBuffer;\n};\n\nResize.prototype._resizeHeightRGBChannels = function (buffer, fourthChannel) {\n  var ratioWeight = this.ratioWeightHeightPass;\n  var ratioWeightDivisor = 1 / ratioWeight;\n  var output = this.outputHeightWorkBench;\n  var outputBuffer = this.heightBuffer;\n  var trustworthyColorsCount = this.outputHeightWorkBenchOpaquePixelsCount;\n  var weight = 0;\n  var amountToNext = 0;\n  var actualPosition = 0;\n  var currentPosition = 0;\n  var pixelOffset = 0;\n  var outputOffset = 0;\n  var caret = 0;\n  var multiplier = 1;\n  var r = 0;\n  var g = 0;\n  var b = 0;\n  var a = 0;\n\n  do {\n    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n      output[pixelOffset++] = 0;\n      output[pixelOffset++] = 0;\n      output[pixelOffset++] = 0;\n\n      if (fourthChannel) {\n        output[pixelOffset++] = 0;\n        trustworthyColorsCount[pixelOffset / 4 - 1] = 0;\n      }\n    }\n\n    weight = ratioWeight;\n\n    do {\n      amountToNext = 1 + actualPosition - currentPosition;\n      multiplier = Math.min(weight, amountToNext);\n      caret = actualPosition;\n\n      for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n        r = buffer[caret++];\n        g = buffer[caret++];\n        b = buffer[caret++];\n        a = fourthChannel ? buffer[caret++] : 255; // Ignore RGB values if pixel is completely transparent\n\n        output[pixelOffset++] += (a ? r : 0) * multiplier;\n        output[pixelOffset++] += (a ? g : 0) * multiplier;\n        output[pixelOffset++] += (a ? b : 0) * multiplier;\n\n        if (fourthChannel) {\n          output[pixelOffset++] += a * multiplier;\n          trustworthyColorsCount[pixelOffset / 4 - 1] += a ? multiplier : 0;\n        }\n      }\n\n      if (weight >= amountToNext) {\n        actualPosition = caret;\n        currentPosition = actualPosition;\n        weight -= amountToNext;\n      } else {\n        currentPosition += weight;\n        break;\n      }\n    } while (weight > 0 && actualPosition < this.widthPassResultSize);\n\n    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n      weight = fourthChannel ? trustworthyColorsCount[pixelOffset / 4] : 1;\n      multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;\n      outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);\n      outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);\n      outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);\n\n      if (fourthChannel) {\n        outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);\n      }\n    }\n  } while (outputOffset < this.finalResultSize);\n\n  return outputBuffer;\n};\n\nResize.prototype.resizeWidthInterpolatedRGB = function (buffer) {\n  return this._resizeWidthInterpolatedRGBChannels(buffer, false);\n};\n\nResize.prototype.resizeWidthInterpolatedRGBA = function (buffer) {\n  return this._resizeWidthInterpolatedRGBChannels(buffer, true);\n};\n\nResize.prototype.resizeWidthRGB = function (buffer) {\n  return this._resizeWidthRGBChannels(buffer, false);\n};\n\nResize.prototype.resizeWidthRGBA = function (buffer) {\n  return this._resizeWidthRGBChannels(buffer, true);\n};\n\nResize.prototype.resizeHeightInterpolated = function (buffer) {\n  var ratioWeight = this.ratioWeightHeightPass;\n  var outputBuffer = this.heightBuffer;\n  var weight = 0;\n  var finalOffset = 0;\n  var pixelOffset = 0;\n  var pixelOffsetAccumulated = 0;\n  var pixelOffsetAccumulated2 = 0;\n  var firstWeight = 0;\n  var secondWeight = 0;\n  var interpolationHeightSourceReadStop; // Handle for only one interpolation input being valid for start calculation:\n\n  for (; weight < 1 / 3; weight += ratioWeight) {\n    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffset++]);\n    }\n  } // Adjust for overshoot of the last pass's counter:\n\n\n  weight -= 1 / 3;\n\n  for (interpolationHeightSourceReadStop = this.heightOriginal - 1; weight < interpolationHeightSourceReadStop; weight += ratioWeight) {\n    // Calculate weightings:\n    secondWeight = weight % 1;\n    firstWeight = 1 - secondWeight; // Interpolate:\n\n    pixelOffsetAccumulated = Math.floor(weight) * this.targetWidthMultipliedByChannels;\n    pixelOffsetAccumulated2 = pixelOffsetAccumulated + this.targetWidthMultipliedByChannels;\n\n    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {\n      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++] * firstWeight + buffer[pixelOffsetAccumulated2++] * secondWeight);\n    }\n  } // Handle for only one interpolation input being valid for end calculation:\n\n\n  while (finalOffset < this.finalResultSize) {\n    for (pixelOffset = 0, pixelOffsetAccumulated = interpolationHeightSourceReadStop * this.targetWidthMultipliedByChannels; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {\n      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++]);\n    }\n  }\n\n  return outputBuffer;\n};\n\nResize.prototype.resizeHeightRGB = function (buffer) {\n  return this._resizeHeightRGBChannels(buffer, false);\n};\n\nResize.prototype.resizeHeightRGBA = function (buffer) {\n  return this._resizeHeightRGBChannels(buffer, true);\n};\n\nResize.prototype.resize = function (buffer) {\n  this.resizeCallback(this.resizeHeight(this.resizeWidth(buffer)));\n};\n\nResize.prototype.bypassResizer = function (buffer) {\n  // Just return the buffer passed:\n  return buffer;\n};\n\nResize.prototype.initializeFirstPassBuffers = function (BILINEARAlgo) {\n  // Initialize the internal width pass buffers:\n  this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize);\n\n  if (!BILINEARAlgo) {\n    this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels);\n\n    if (this.colorChannels > 3) {\n      this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal);\n    }\n  }\n};\n\nResize.prototype.initializeSecondPassBuffers = function (BILINEARAlgo) {\n  // Initialize the internal height pass buffers:\n  this.heightBuffer = this.generateUint8Buffer(this.finalResultSize);\n\n  if (!BILINEARAlgo) {\n    this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels);\n\n    if (this.colorChannels > 3) {\n      this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth);\n    }\n  }\n};\n\nResize.prototype.generateFloatBuffer = function (bufferLength) {\n  // Generate a float32 typed array buffer:\n  try {\n    return new Float32Array(bufferLength);\n  } catch (error) {\n    return [];\n  }\n};\n\nResize.prototype.generateFloat64Buffer = function (bufferLength) {\n  // Generate a float64 typed array buffer:\n  try {\n    return new Float64Array(bufferLength);\n  } catch (error) {\n    return [];\n  }\n};\n\nResize.prototype.generateUint8Buffer = function (bufferLength) {\n  // Generate a uint8 typed array buffer:\n  try {\n    return new Uint8Array(bufferLength);\n  } catch (error) {\n    return [];\n  }\n};\n\nmodule.exports = Resize;","map":{"version":3,"sources":["../../src/modules/resize.js"],"names":["Math","blendAlpha","Boolean","Resize","channelsNum","fourthChannel","ratioWeight","outputBuffer","weight","finalOffset","pixelOffset","firstWeight","secondWeight","targetPosition","buffer","interpolationWidthSourceReadStop","ratioWeightDivisor","nextLineOffsetOriginalWidth","nextLineOffsetTargetWidth","output","trustworthyColorsCount","amountToNext","actualPosition","currentPosition","line","outputOffset","multiplier","r","g","b","a","caret","pixelOffsetAccumulated","pixelOffsetAccumulated2","interpolationHeightSourceReadStop","module"],"mappings":"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","sourcesContent":["// JavaScript Image Resizer (c) 2012 - Grant Galitz\n// Released to public domain 29 July 2013: https://github.com/grantgalitz/JS-Image-Resizer/issues/4\n\nfunction Resize(\n  widthOriginal,\n  heightOriginal,\n  targetWidth,\n  targetHeight,\n  blendAlpha,\n  interpolationPass,\n  resizeCallback\n) {\n  this.widthOriginal = Math.abs(Math.floor(widthOriginal) || 0);\n  this.heightOriginal = Math.abs(Math.floor(heightOriginal) || 0);\n  this.targetWidth = Math.abs(Math.floor(targetWidth) || 0);\n  this.targetHeight = Math.abs(Math.floor(targetHeight) || 0);\n  this.colorChannels = blendAlpha ? 4 : 3;\n  this.interpolationPass = Boolean(interpolationPass);\n  this.resizeCallback =\n    typeof resizeCallback === 'function' ? resizeCallback : function() {};\n\n  this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels;\n  this.originalWidthMultipliedByChannels =\n    this.widthOriginal * this.colorChannels;\n  this.originalHeightMultipliedByChannels =\n    this.heightOriginal * this.colorChannels;\n  this.widthPassResultSize =\n    this.targetWidthMultipliedByChannels * this.heightOriginal;\n  this.finalResultSize =\n    this.targetWidthMultipliedByChannels * this.targetHeight;\n  this.initialize();\n}\n\nResize.prototype.initialize = function() {\n  // Perform some checks:\n  if (\n    this.widthOriginal > 0 &&\n    this.heightOriginal > 0 &&\n    this.targetWidth > 0 &&\n    this.targetHeight > 0\n  ) {\n    this.configurePasses();\n  } else {\n    throw new Error('Invalid settings specified for the resizer.');\n  }\n};\n\nResize.prototype.configurePasses = function() {\n  if (this.widthOriginal === this.targetWidth) {\n    // Bypass the width resizer pass:\n    this.resizeWidth = this.bypassResizer;\n  } else {\n    // Setup the width resizer pass:\n    this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth;\n    if (this.ratioWeightWidthPass < 1 && this.interpolationPass) {\n      this.initializeFirstPassBuffers(true);\n      this.resizeWidth =\n        this.colorChannels === 4\n          ? this.resizeWidthInterpolatedRGBA\n          : this.resizeWidthInterpolatedRGB;\n    } else {\n      this.initializeFirstPassBuffers(false);\n      this.resizeWidth =\n        this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB;\n    }\n  }\n\n  if (this.heightOriginal === this.targetHeight) {\n    // Bypass the height resizer pass:\n    this.resizeHeight = this.bypassResizer;\n  } else {\n    // Setup the height resizer pass:\n    this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight;\n    if (this.ratioWeightHeightPass < 1 && this.interpolationPass) {\n      this.initializeSecondPassBuffers(true);\n      this.resizeHeight = this.resizeHeightInterpolated;\n    } else {\n      this.initializeSecondPassBuffers(false);\n      this.resizeHeight =\n        this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB;\n    }\n  }\n};\n\nResize.prototype._resizeWidthInterpolatedRGBChannels = function(\n  buffer,\n  fourthChannel\n) {\n  const channelsNum = fourthChannel ? 4 : 3;\n  const ratioWeight = this.ratioWeightWidthPass;\n  const outputBuffer = this.widthBuffer;\n\n  let weight = 0;\n  let finalOffset = 0;\n  let pixelOffset = 0;\n  let firstWeight = 0;\n  let secondWeight = 0;\n  let targetPosition;\n\n  // Handle for only one interpolation input being valid for start calculation:\n  for (\n    targetPosition = 0;\n    weight < 1 / 3;\n    targetPosition += channelsNum, weight += ratioWeight\n  ) {\n    for (\n      finalOffset = targetPosition, pixelOffset = 0;\n      finalOffset < this.widthPassResultSize;\n      pixelOffset += this.originalWidthMultipliedByChannels,\n        finalOffset += this.targetWidthMultipliedByChannels\n    ) {\n      outputBuffer[finalOffset] = buffer[pixelOffset];\n      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];\n      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];\n      if (fourthChannel)\n        outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];\n    }\n  }\n\n  // Adjust for overshoot of the last pass's counter:\n  weight -= 1 / 3;\n  let interpolationWidthSourceReadStop;\n\n  for (\n    interpolationWidthSourceReadStop = this.widthOriginal - 1;\n    weight < interpolationWidthSourceReadStop;\n    targetPosition += channelsNum, weight += ratioWeight\n  ) {\n    // Calculate weightings:\n    secondWeight = weight % 1;\n    firstWeight = 1 - secondWeight;\n    // Interpolate:\n    for (\n      finalOffset = targetPosition,\n        pixelOffset = Math.floor(weight) * channelsNum;\n      finalOffset < this.widthPassResultSize;\n      pixelOffset += this.originalWidthMultipliedByChannels,\n        finalOffset += this.targetWidthMultipliedByChannels\n    ) {\n      outputBuffer[finalOffset + 0] =\n        buffer[pixelOffset + 0] * firstWeight +\n        buffer[pixelOffset + channelsNum + 0] * secondWeight;\n      outputBuffer[finalOffset + 1] =\n        buffer[pixelOffset + 1] * firstWeight +\n        buffer[pixelOffset + channelsNum + 1] * secondWeight;\n      outputBuffer[finalOffset + 2] =\n        buffer[pixelOffset + 2] * firstWeight +\n        buffer[pixelOffset + channelsNum + 2] * secondWeight;\n      if (fourthChannel)\n        outputBuffer[finalOffset + 3] =\n          buffer[pixelOffset + 3] * firstWeight +\n          buffer[pixelOffset + channelsNum + 3] * secondWeight;\n    }\n  }\n\n  // Handle for only one interpolation input being valid for end calculation:\n  for (\n    interpolationWidthSourceReadStop =\n      this.originalWidthMultipliedByChannels - channelsNum;\n    targetPosition < this.targetWidthMultipliedByChannels;\n    targetPosition += channelsNum\n  ) {\n    for (\n      finalOffset = targetPosition,\n        pixelOffset = interpolationWidthSourceReadStop;\n      finalOffset < this.widthPassResultSize;\n      pixelOffset += this.originalWidthMultipliedByChannels,\n        finalOffset += this.targetWidthMultipliedByChannels\n    ) {\n      outputBuffer[finalOffset] = buffer[pixelOffset];\n      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];\n      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];\n      if (fourthChannel)\n        outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];\n    }\n  }\n\n  return outputBuffer;\n};\n\nResize.prototype._resizeWidthRGBChannels = function(buffer, fourthChannel) {\n  const channelsNum = fourthChannel ? 4 : 3;\n  const ratioWeight = this.ratioWeightWidthPass;\n  const ratioWeightDivisor = 1 / ratioWeight;\n  const nextLineOffsetOriginalWidth =\n    this.originalWidthMultipliedByChannels - channelsNum + 1;\n  const nextLineOffsetTargetWidth =\n    this.targetWidthMultipliedByChannels - channelsNum + 1;\n  const output = this.outputWidthWorkBench;\n  const outputBuffer = this.widthBuffer;\n  const trustworthyColorsCount = this.outputWidthWorkBenchOpaquePixelsCount;\n\n  let weight = 0;\n  let amountToNext = 0;\n  let actualPosition = 0;\n  let currentPosition = 0;\n  let line = 0;\n  let pixelOffset = 0;\n  let outputOffset = 0;\n  let multiplier = 1;\n  let r = 0;\n  let g = 0;\n  let b = 0;\n  let a = 0;\n\n  do {\n    for (line = 0; line < this.originalHeightMultipliedByChannels; ) {\n      output[line++] = 0;\n      output[line++] = 0;\n      output[line++] = 0;\n      if (fourthChannel) {\n        output[line++] = 0;\n        trustworthyColorsCount[line / channelsNum - 1] = 0;\n      }\n    }\n\n    weight = ratioWeight;\n\n    do {\n      amountToNext = 1 + actualPosition - currentPosition;\n      multiplier = Math.min(weight, amountToNext);\n      for (\n        line = 0, pixelOffset = actualPosition;\n        line < this.originalHeightMultipliedByChannels;\n        pixelOffset += nextLineOffsetOriginalWidth\n      ) {\n        r = buffer[pixelOffset];\n        g = buffer[++pixelOffset];\n        b = buffer[++pixelOffset];\n        a = fourthChannel ? buffer[++pixelOffset] : 255;\n        // Ignore RGB values if pixel is completely transparent\n        output[line++] += (a ? r : 0) * multiplier;\n        output[line++] += (a ? g : 0) * multiplier;\n        output[line++] += (a ? b : 0) * multiplier;\n        if (fourthChannel) {\n          output[line++] += a * multiplier;\n          trustworthyColorsCount[line / channelsNum - 1] += a ? multiplier : 0;\n        }\n      }\n\n      if (weight >= amountToNext) {\n        actualPosition += channelsNum;\n        currentPosition = actualPosition;\n        weight -= amountToNext;\n      } else {\n        currentPosition += weight;\n        break;\n      }\n    } while (\n      weight > 0 &&\n      actualPosition < this.originalWidthMultipliedByChannels\n    );\n\n    for (\n      line = 0, pixelOffset = outputOffset;\n      line < this.originalHeightMultipliedByChannels;\n      pixelOffset += nextLineOffsetTargetWidth\n    ) {\n      weight = fourthChannel ? trustworthyColorsCount[line / channelsNum] : 1;\n      multiplier = fourthChannel\n        ? weight\n          ? 1 / weight\n          : 0\n        : ratioWeightDivisor;\n      outputBuffer[pixelOffset] = output[line++] * multiplier;\n      outputBuffer[++pixelOffset] = output[line++] * multiplier;\n      outputBuffer[++pixelOffset] = output[line++] * multiplier;\n      if (fourthChannel)\n        outputBuffer[++pixelOffset] = output[line++] * ratioWeightDivisor;\n    }\n\n    outputOffset += channelsNum;\n  } while (outputOffset < this.targetWidthMultipliedByChannels);\n\n  return outputBuffer;\n};\n\nResize.prototype._resizeHeightRGBChannels = function(buffer, fourthChannel) {\n  const ratioWeight = this.ratioWeightHeightPass;\n  const ratioWeightDivisor = 1 / ratioWeight;\n  const output = this.outputHeightWorkBench;\n  const outputBuffer = this.heightBuffer;\n  const trustworthyColorsCount = this.outputHeightWorkBenchOpaquePixelsCount;\n\n  let weight = 0;\n  let amountToNext = 0;\n  let actualPosition = 0;\n  let currentPosition = 0;\n  let pixelOffset = 0;\n  let outputOffset = 0;\n  let caret = 0;\n  let multiplier = 1;\n  let r = 0;\n  let g = 0;\n  let b = 0;\n  let a = 0;\n\n  do {\n    for (\n      pixelOffset = 0;\n      pixelOffset < this.targetWidthMultipliedByChannels;\n\n    ) {\n      output[pixelOffset++] = 0;\n      output[pixelOffset++] = 0;\n      output[pixelOffset++] = 0;\n\n      if (fourthChannel) {\n        output[pixelOffset++] = 0;\n        trustworthyColorsCount[pixelOffset / 4 - 1] = 0;\n      }\n    }\n\n    weight = ratioWeight;\n\n    do {\n      amountToNext = 1 + actualPosition - currentPosition;\n      multiplier = Math.min(weight, amountToNext);\n      caret = actualPosition;\n\n      for (\n        pixelOffset = 0;\n        pixelOffset < this.targetWidthMultipliedByChannels;\n\n      ) {\n        r = buffer[caret++];\n        g = buffer[caret++];\n        b = buffer[caret++];\n        a = fourthChannel ? buffer[caret++] : 255;\n        // Ignore RGB values if pixel is completely transparent\n        output[pixelOffset++] += (a ? r : 0) * multiplier;\n        output[pixelOffset++] += (a ? g : 0) * multiplier;\n        output[pixelOffset++] += (a ? b : 0) * multiplier;\n\n        if (fourthChannel) {\n          output[pixelOffset++] += a * multiplier;\n          trustworthyColorsCount[pixelOffset / 4 - 1] += a ? multiplier : 0;\n        }\n      }\n\n      if (weight >= amountToNext) {\n        actualPosition = caret;\n        currentPosition = actualPosition;\n        weight -= amountToNext;\n      } else {\n        currentPosition += weight;\n        break;\n      }\n    } while (weight > 0 && actualPosition < this.widthPassResultSize);\n\n    for (\n      pixelOffset = 0;\n      pixelOffset < this.targetWidthMultipliedByChannels;\n\n    ) {\n      weight = fourthChannel ? trustworthyColorsCount[pixelOffset / 4] : 1;\n      multiplier = fourthChannel\n        ? weight\n          ? 1 / weight\n          : 0\n        : ratioWeightDivisor;\n      outputBuffer[outputOffset++] = Math.round(\n        output[pixelOffset++] * multiplier\n      );\n      outputBuffer[outputOffset++] = Math.round(\n        output[pixelOffset++] * multiplier\n      );\n      outputBuffer[outputOffset++] = Math.round(\n        output[pixelOffset++] * multiplier\n      );\n\n      if (fourthChannel) {\n        outputBuffer[outputOffset++] = Math.round(\n          output[pixelOffset++] * ratioWeightDivisor\n        );\n      }\n    }\n  } while (outputOffset < this.finalResultSize);\n\n  return outputBuffer;\n};\n\nResize.prototype.resizeWidthInterpolatedRGB = function(buffer) {\n  return this._resizeWidthInterpolatedRGBChannels(buffer, false);\n};\n\nResize.prototype.resizeWidthInterpolatedRGBA = function(buffer) {\n  return this._resizeWidthInterpolatedRGBChannels(buffer, true);\n};\n\nResize.prototype.resizeWidthRGB = function(buffer) {\n  return this._resizeWidthRGBChannels(buffer, false);\n};\n\nResize.prototype.resizeWidthRGBA = function(buffer) {\n  return this._resizeWidthRGBChannels(buffer, true);\n};\n\nResize.prototype.resizeHeightInterpolated = function(buffer) {\n  const ratioWeight = this.ratioWeightHeightPass;\n  const outputBuffer = this.heightBuffer;\n\n  let weight = 0;\n  let finalOffset = 0;\n  let pixelOffset = 0;\n  let pixelOffsetAccumulated = 0;\n  let pixelOffsetAccumulated2 = 0;\n  let firstWeight = 0;\n  let secondWeight = 0;\n  let interpolationHeightSourceReadStop;\n\n  // Handle for only one interpolation input being valid for start calculation:\n  for (; weight < 1 / 3; weight += ratioWeight) {\n    for (\n      pixelOffset = 0;\n      pixelOffset < this.targetWidthMultipliedByChannels;\n\n    ) {\n      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffset++]);\n    }\n  }\n\n  // Adjust for overshoot of the last pass's counter:\n  weight -= 1 / 3;\n\n  for (\n    interpolationHeightSourceReadStop = this.heightOriginal - 1;\n    weight < interpolationHeightSourceReadStop;\n    weight += ratioWeight\n  ) {\n    // Calculate weightings:\n    secondWeight = weight % 1;\n    firstWeight = 1 - secondWeight;\n    // Interpolate:\n    pixelOffsetAccumulated =\n      Math.floor(weight) * this.targetWidthMultipliedByChannels;\n    pixelOffsetAccumulated2 =\n      pixelOffsetAccumulated + this.targetWidthMultipliedByChannels;\n    for (\n      pixelOffset = 0;\n      pixelOffset < this.targetWidthMultipliedByChannels;\n      ++pixelOffset\n    ) {\n      outputBuffer[finalOffset++] = Math.round(\n        buffer[pixelOffsetAccumulated++] * firstWeight +\n          buffer[pixelOffsetAccumulated2++] * secondWeight\n      );\n    }\n  }\n\n  // Handle for only one interpolation input being valid for end calculation:\n  while (finalOffset < this.finalResultSize) {\n    for (\n      pixelOffset = 0,\n        pixelOffsetAccumulated =\n          interpolationHeightSourceReadStop *\n          this.targetWidthMultipliedByChannels;\n      pixelOffset < this.targetWidthMultipliedByChannels;\n      ++pixelOffset\n    ) {\n      outputBuffer[finalOffset++] = Math.round(\n        buffer[pixelOffsetAccumulated++]\n      );\n    }\n  }\n\n  return outputBuffer;\n};\n\nResize.prototype.resizeHeightRGB = function(buffer) {\n  return this._resizeHeightRGBChannels(buffer, false);\n};\n\nResize.prototype.resizeHeightRGBA = function(buffer) {\n  return this._resizeHeightRGBChannels(buffer, true);\n};\n\nResize.prototype.resize = function(buffer) {\n  this.resizeCallback(this.resizeHeight(this.resizeWidth(buffer)));\n};\n\nResize.prototype.bypassResizer = function(buffer) {\n  // Just return the buffer passed:\n  return buffer;\n};\n\nResize.prototype.initializeFirstPassBuffers = function(BILINEARAlgo) {\n  // Initialize the internal width pass buffers:\n  this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize);\n\n  if (!BILINEARAlgo) {\n    this.outputWidthWorkBench = this.generateFloatBuffer(\n      this.originalHeightMultipliedByChannels\n    );\n\n    if (this.colorChannels > 3) {\n      this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(\n        this.heightOriginal\n      );\n    }\n  }\n};\n\nResize.prototype.initializeSecondPassBuffers = function(BILINEARAlgo) {\n  // Initialize the internal height pass buffers:\n  this.heightBuffer = this.generateUint8Buffer(this.finalResultSize);\n\n  if (!BILINEARAlgo) {\n    this.outputHeightWorkBench = this.generateFloatBuffer(\n      this.targetWidthMultipliedByChannels\n    );\n\n    if (this.colorChannels > 3) {\n      this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(\n        this.targetWidth\n      );\n    }\n  }\n};\n\nResize.prototype.generateFloatBuffer = function(bufferLength) {\n  // Generate a float32 typed array buffer:\n  try {\n    return new Float32Array(bufferLength);\n  } catch (error) {\n    return [];\n  }\n};\n\nResize.prototype.generateFloat64Buffer = function(bufferLength) {\n  // Generate a float64 typed array buffer:\n  try {\n    return new Float64Array(bufferLength);\n  } catch (error) {\n    return [];\n  }\n};\n\nResize.prototype.generateUint8Buffer = function(bufferLength) {\n  // Generate a uint8 typed array buffer:\n  try {\n    return new Uint8Array(bufferLength);\n  } catch (error) {\n    return [];\n  }\n};\n\nmodule.exports = Resize;\n"]},"metadata":{},"sourceType":"script"}